<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libmesh解析: libMesh::Point类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libmesh解析
   </div>
   <div id="projectbrief">本工作只是尝试解析原libmesh的代码,供学习使用</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li class="current"><a href="annotated.html"><span>类</span></a></li>
      <li><a href="files.html"><span>文件</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>类列表</span></a></li>
      <li><a href="classes.html"><span>类索引</span></a></li>
      <li><a href="inherits.html"><span>类继承关系</span></a></li>
      <li><a href="functions.html"><span>类成员</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>全部</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>类</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>命名空间</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>文件</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>函数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>变量</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>类型定义</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>枚举</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>枚举值</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>友元</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>页</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1Point.html">Point</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pro-attribs">Protected 属性</a> &#124;
<a href="#friends">友元</a> &#124;
<a href="classlibMesh_1_1Point-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::Point类 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <code><a class="el" href="classlibMesh_1_1Point.html" title="A Point defines a location in LIBMESH_DIM dimensional Real space. ">Point</a></code> defines a location in LIBMESH_DIM dimensional Real space.  
 <a href="classlibMesh_1_1Point.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="point_8h_source.html">point.h</a>&gt;</code></p>
<div class="dynheader">
类 libMesh::Point 继承关系图:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:a702b197a7ae281d7c8f893759a9a35eb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a702b197a7ae281d7c8f893759a9a35eb">value_type</a></td></tr>
<tr class="memdesc:a702b197a7ae281d7c8f893759a9a35eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">辅助 typedef 用于 C++98 泛型编程。  <a href="#a702b197a7ae281d7c8f893759a9a35eb">更多...</a><br/></td></tr>
<tr class="separator:a702b197a7ae281d7c8f893759a9a35eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e83ffbc976ec4665c112b1b6076f67"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a85e83ffbc976ec4665c112b1b6076f67">index_type</a></td></tr>
<tr class="memdesc:a85e83ffbc976ec4665c112b1b6076f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">辅助 typedef 用于泛型索引编程。  <a href="#a85e83ffbc976ec4665c112b1b6076f67">更多...</a><br/></td></tr>
<tr class="separator:a85e83ffbc976ec4665c112b1b6076f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a1d422159eca00677230dcb247daf4c21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Point.html#a1d422159eca00677230dcb247daf4c21">Point</a> (const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> x=0., const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> y=0., const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> z=0.)</td></tr>
<tr class="memdesc:a1d422159eca00677230dcb247daf4c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a1d422159eca00677230dcb247daf4c21">更多...</a><br/></td></tr>
<tr class="separator:a1d422159eca00677230dcb247daf4c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e98de819d696f360619c8d7eeaf8577"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Point.html#a8e98de819d696f360619c8d7eeaf8577">Point</a> (const <a class="el" href="classlibMesh_1_1Point.html">Point</a> &amp;p)=default</td></tr>
<tr class="memdesc:a8e98de819d696f360619c8d7eeaf8577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial copy-constructor.  <a href="#a8e98de819d696f360619c8d7eeaf8577">更多...</a><br/></td></tr>
<tr class="separator:a8e98de819d696f360619c8d7eeaf8577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a473d4b789a119bf7e36434d8872c4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Point.html#a5a473d4b789a119bf7e36434d8872c4e">Point</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;p)</td></tr>
<tr class="memdesc:a5a473d4b789a119bf7e36434d8872c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructor from non-point Typevector.  <a href="#a5a473d4b789a119bf7e36434d8872c4e">更多...</a><br/></td></tr>
<tr class="separator:a5a473d4b789a119bf7e36434d8872c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5bf41f185d4d7fb884e9189428af68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1Point.html">Point</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Point.html#abd5bf41f185d4d7fb884e9189428af68">operator=</a> (const <a class="el" href="classlibMesh_1_1Point.html">Point</a> &amp;p)=default</td></tr>
<tr class="memdesc:abd5bf41f185d4d7fb884e9189428af68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assignment operator.  <a href="#abd5bf41f185d4d7fb884e9189428af68">更多...</a><br/></td></tr>
<tr class="separator:abd5bf41f185d4d7fb884e9189428af68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a97450df9564ad3821c7587eb0dca49"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename boostcopy::enable_if_c&lt;ScalarTraits&lt;T&gt;::value,void&gt;::type&gt; </td></tr>
<tr class="memitem:a4a97450df9564ad3821c7587eb0dca49"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Point.html#a4a97450df9564ad3821c7587eb0dca49">Point</a> (const T x)</td></tr>
<tr class="memdesc:a4a97450df9564ad3821c7587eb0dca49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguate constructing from non-Real scalars.  <a href="#a4a97450df9564ad3821c7587eb0dca49">更多...</a><br/></td></tr>
<tr class="separator:a4a97450df9564ad3821c7587eb0dca49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac437fa82ea6c063ff934c2b5616da4c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Point.html#ac437fa82ea6c063ff934c2b5616da4c8">~Point</a> ()=default</td></tr>
<tr class="memdesc:ac437fa82ea6c063ff934c2b5616da4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ac437fa82ea6c063ff934c2b5616da4c8">更多...</a><br/></td></tr>
<tr class="separator:ac437fa82ea6c063ff934c2b5616da4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc6ff827f81abc236e8baa5f3e13661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a2fc6ff827f81abc236e8baa5f3e13661">assign</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;)</td></tr>
<tr class="memdesc:a2fc6ff827f81abc236e8baa5f3e13661"><td class="mdescLeft">&#160;</td><td class="mdescRight">在不创建临时对象的情况下将向量赋值给该向量。  <a href="#a2fc6ff827f81abc236e8baa5f3e13661">更多...</a><br/></td></tr>
<tr class="separator:a2fc6ff827f81abc236e8baa5f3e13661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608985f52c18676847e7acb6623beb24"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a608985f52c18676847e7acb6623beb24">operator()</a> (const unsigned int i) const</td></tr>
<tr class="memdesc:a608985f52c18676847e7acb6623beb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回向量中的第 i 个分量的常量引用。  <a href="#a608985f52c18676847e7acb6623beb24">更多...</a><br/></td></tr>
<tr class="separator:a608985f52c18676847e7acb6623beb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3568df25f9c0db5decbcaa9d42420439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a3568df25f9c0db5decbcaa9d42420439">operator()</a> (const unsigned int i)</td></tr>
<tr class="memdesc:a3568df25f9c0db5decbcaa9d42420439"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回向量中的第 i 个分量的可写引用。  <a href="#a3568df25f9c0db5decbcaa9d42420439">更多...</a><br/></td></tr>
<tr class="separator:a3568df25f9c0db5decbcaa9d42420439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792b992a3ab29cf4019e9068b6b42806"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a792b992a3ab29cf4019e9068b6b42806">slice</a> (const unsigned int i) const</td></tr>
<tr class="separator:a792b992a3ab29cf4019e9068b6b42806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fe612232c6f64b41e8122e9d2e35de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#af7fe612232c6f64b41e8122e9d2e35de">slice</a> (const unsigned int i)</td></tr>
<tr class="separator:af7fe612232c6f64b41e8122e9d2e35de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2d643d13070a1bfcee9eb566e92f78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>, T2 &gt;<br class="typebreak"/>
::supertype &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#ada2d643d13070a1bfcee9eb566e92f78">operator+</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;) const</td></tr>
<tr class="memdesc:ada2d643d13070a1bfcee9eb566e92f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">向量相加。  <a href="#ada2d643d13070a1bfcee9eb566e92f78">更多...</a><br/></td></tr>
<tr class="separator:ada2d643d13070a1bfcee9eb566e92f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c45641a3cbeabde2d926c00576e5b3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#ac9c45641a3cbeabde2d926c00576e5b3">operator+=</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;)</td></tr>
<tr class="memdesc:ac9c45641a3cbeabde2d926c00576e5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">向量相加。  <a href="#ac9c45641a3cbeabde2d926c00576e5b3">更多...</a><br/></td></tr>
<tr class="separator:ac9c45641a3cbeabde2d926c00576e5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70145631b2ca6d9090f4037446dddf98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>, T2 &gt;<br class="typebreak"/>
::supertype &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a70145631b2ca6d9090f4037446dddf98">operator-</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;) const</td></tr>
<tr class="memdesc:a70145631b2ca6d9090f4037446dddf98"><td class="mdescLeft">&#160;</td><td class="mdescRight">从另一个向量中减去该向量。  <a href="#a70145631b2ca6d9090f4037446dddf98">更多...</a><br/></td></tr>
<tr class="separator:a70145631b2ca6d9090f4037446dddf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc0e36b6b5bd587b19f819ba7495ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#aacc0e36b6b5bd587b19f819ba7495ce4">operator-</a> () const</td></tr>
<tr class="memdesc:aacc0e36b6b5bd587b19f819ba7495ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回该向量的相反向量的副本。  <a href="#aacc0e36b6b5bd587b19f819ba7495ce4">更多...</a><br/></td></tr>
<tr class="separator:aacc0e36b6b5bd587b19f819ba7495ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567bf70581fb4eba128cedcc216ce0aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a567bf70581fb4eba128cedcc216ce0aa">operator-=</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;)</td></tr>
<tr class="memdesc:a567bf70581fb4eba128cedcc216ce0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">从该向量中减去另一个向量。  <a href="#a567bf70581fb4eba128cedcc216ce0aa">更多...</a><br/></td></tr>
<tr class="separator:a567bf70581fb4eba128cedcc216ce0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63f42e523de8a8a0b7a970ec29630fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#ab63f42e523de8a8a0b7a970ec29630fa">subtract</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;)</td></tr>
<tr class="memdesc:ab63f42e523de8a8a0b7a970ec29630fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">从另一个向量中减去该向量，不创建临时对象。  <a href="#ab63f42e523de8a8a0b7a970ec29630fa">更多...</a><br/></td></tr>
<tr class="separator:ab63f42e523de8a8a0b7a970ec29630fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0190035fd2382f69a52dec56ab780c4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a0190035fd2382f69a52dec56ab780c4f">subtract_scaled</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;, const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &amp;)</td></tr>
<tr class="memdesc:a0190035fd2382f69a52dec56ab780c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">从该向量中减去另一个向量的缩放值，不创建临时对象。  <a href="#a0190035fd2382f69a52dec56ab780c4f">更多...</a><br/></td></tr>
<tr class="separator:a0190035fd2382f69a52dec56ab780c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc0452b50d53d6e48ff97f1de35c1af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlibMesh_1_1boostcopy_1_1enable__if__c.html">boostcopy::enable_if_c</a><br class="typebreak"/>
&lt; <a class="el" href="structlibMesh_1_1ScalarTraits.html">ScalarTraits</a>&lt; Scalar &gt;<br class="typebreak"/>
::<a class="el" href="xdr__io_8C.html#a11ddd051208250c32dc4985abcafa86d">value</a>, <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>, Scalar &gt;<br class="typebreak"/>
::supertype &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#afdc0452b50d53d6e48ff97f1de35c1af">operator*</a> (const Scalar &amp;) const</td></tr>
<tr class="memdesc:afdc0452b50d53d6e48ff97f1de35c1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">将该向量乘以标量值。  <a href="#afdc0452b50d53d6e48ff97f1de35c1af">更多...</a><br/></td></tr>
<tr class="separator:afdc0452b50d53d6e48ff97f1de35c1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1388c1c9def375b105b7063c051e0f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>, T2 &gt;::supertype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a1388c1c9def375b105b7063c051e0f22">operator*</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;) const</td></tr>
<tr class="memdesc:a1388c1c9def375b105b7063c051e0f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算该向量与另一个向量的点积。  <a href="#a1388c1c9def375b105b7063c051e0f22">更多...</a><br/></td></tr>
<tr class="separator:a1388c1c9def375b105b7063c051e0f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcf912ac5f3164c2aa98bd9730f893c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a0dcf912ac5f3164c2aa98bd9730f893c">operator*=</a> (const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &amp;)</td></tr>
<tr class="memdesc:a0dcf912ac5f3164c2aa98bd9730f893c"><td class="mdescLeft">&#160;</td><td class="mdescRight">将该向量乘以标量值。  <a href="#a0dcf912ac5f3164c2aa98bd9730f893c">更多...</a><br/></td></tr>
<tr class="separator:a0dcf912ac5f3164c2aa98bd9730f893c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0ea9743238361fbacd62ad318f8505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlibMesh_1_1boostcopy_1_1enable__if__c.html">boostcopy::enable_if_c</a><br class="typebreak"/>
&lt; <a class="el" href="structlibMesh_1_1ScalarTraits.html">ScalarTraits</a>&lt; Scalar &gt;<br class="typebreak"/>
::<a class="el" href="xdr__io_8C.html#a11ddd051208250c32dc4985abcafa86d">value</a>, <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>, Scalar &gt;<br class="typebreak"/>
::supertype &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a5e0ea9743238361fbacd62ad318f8505">operator/</a> (const Scalar &amp;) const</td></tr>
<tr class="memdesc:a5e0ea9743238361fbacd62ad318f8505"><td class="mdescLeft">&#160;</td><td class="mdescRight">将该向量的每个分量除以标量值。  <a href="#a5e0ea9743238361fbacd62ad318f8505">更多...</a><br/></td></tr>
<tr class="separator:a5e0ea9743238361fbacd62ad318f8505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa445230e5dc262e1f1246503d1bff1a3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#aa445230e5dc262e1f1246503d1bff1a3">operator/=</a> (const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &amp;)</td></tr>
<tr class="memdesc:aa445230e5dc262e1f1246503d1bff1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">将该向量的每个分量除以标量值。  <a href="#aa445230e5dc262e1f1246503d1bff1a3">更多...</a><br/></td></tr>
<tr class="separator:aa445230e5dc262e1f1246503d1bff1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2549251d3c12ddcc84c292ddaf9c5818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>, T2 &gt;::supertype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a2549251d3c12ddcc84c292ddaf9c5818">contract</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;) const</td></tr>
<tr class="memdesc:a2549251d3c12ddcc84c292ddaf9c5818"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回 <a class="el" href="namespacelibMesh.html#a0f88a869cb829c72bcd5145908e12742">TypeVector::operator*()</a> 的结果。  <a href="#a2549251d3c12ddcc84c292ddaf9c5818">更多...</a><br/></td></tr>
<tr class="separator:a2549251d3c12ddcc84c292ddaf9c5818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d6b8d9b0f2b60c32f27a49a21e969e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>, T2 &gt;<br class="typebreak"/>
::supertype &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a00d6b8d9b0f2b60c32f27a49a21e969e">cross</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;v) const</td></tr>
<tr class="memdesc:a00d6b8d9b0f2b60c32f27a49a21e969e"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算该向量与另一个向量的叉积。  <a href="#a00d6b8d9b0f2b60c32f27a49a21e969e">更多...</a><br/></td></tr>
<tr class="separator:a00d6b8d9b0f2b60c32f27a49a21e969e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af309ac3227a31641f8e8ecbe9bb972a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#af309ac3227a31641f8e8ecbe9bb972a5">unit</a> () const</td></tr>
<tr class="memdesc:af309ac3227a31641f8e8ecbe9bb972a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向该向量方向的单位向量。  <a href="#af309ac3227a31641f8e8ecbe9bb972a5">更多...</a><br/></td></tr>
<tr class="separator:af309ac3227a31641f8e8ecbe9bb972a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4651826286cfbc7d36fccf81ec0a5a14"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a4651826286cfbc7d36fccf81ec0a5a14">norm</a> () const -&gt; decltype(std::norm(<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>()))</td></tr>
<tr class="memdesc:a4651826286cfbc7d36fccf81ec0a5a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回向量的模，即元素平方和的平方根。  <a href="#a4651826286cfbc7d36fccf81ec0a5a14">更多...</a><br/></td></tr>
<tr class="separator:a4651826286cfbc7d36fccf81ec0a5a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2312d576bfab58b2e760ad7da3c17b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a3a2312d576bfab58b2e760ad7da3c17b">norm_sq</a> () const -&gt; decltype(<a class="el" href="namespacestd.html#a6e740e64c53e9ae1489f7eee3899c10f">std::norm</a>(<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>()))</td></tr>
<tr class="memdesc:a3a2312d576bfab58b2e760ad7da3c17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回向量的模的平方，即元素模的平方和。  <a href="#a3a2312d576bfab58b2e760ad7da3c17b">更多...</a><br/></td></tr>
<tr class="separator:a3a2312d576bfab58b2e760ad7da3c17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e06813c6340e58fffa0ddc534a643e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#ae1e06813c6340e58fffa0ddc534a643e">is_zero</a> () const</td></tr>
<tr class="memdesc:ae1e06813c6340e58fffa0ddc534a643e"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断向量的所有值是否为零。  <a href="#ae1e06813c6340e58fffa0ddc534a643e">更多...</a><br/></td></tr>
<tr class="separator:ae1e06813c6340e58fffa0ddc534a643e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4039c6e4f87fa907b3aeaafd66c0c1ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a4039c6e4f87fa907b3aeaafd66c0c1ce">zero</a> ()</td></tr>
<tr class="memdesc:a4039c6e4f87fa907b3aeaafd66c0c1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">将向量的所有分量设置为零。  <a href="#a4039c6e4f87fa907b3aeaafd66c0c1ce">更多...</a><br/></td></tr>
<tr class="separator:a4039c6e4f87fa907b3aeaafd66c0c1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510b7f78c908b4d0f2a1250bace34d88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a510b7f78c908b4d0f2a1250bace34d88">relative_fuzzy_equals</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;rhs, <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> tol=<a class="el" href="namespacelibMesh.html#aadc7666a2b443d9cccbb63174874c14f">TOLERANCE</a>) const</td></tr>
<tr class="memdesc:a510b7f78c908b4d0f2a1250bace34d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断两个向量是否在相对容差 tol 内相等。  <a href="#a510b7f78c908b4d0f2a1250bace34d88">更多...</a><br/></td></tr>
<tr class="separator:a510b7f78c908b4d0f2a1250bace34d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdea0b3d6d9b9e699a15c9a9f532d8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#aebdea0b3d6d9b9e699a15c9a9f532d8a">absolute_fuzzy_equals</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;rhs, <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> tol=<a class="el" href="namespacelibMesh.html#aadc7666a2b443d9cccbb63174874c14f">TOLERANCE</a>) const</td></tr>
<tr class="memdesc:aebdea0b3d6d9b9e699a15c9a9f532d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断两个向量是否在绝对容差 tol 内相等。  <a href="#aebdea0b3d6d9b9e699a15c9a9f532d8a">更多...</a><br/></td></tr>
<tr class="separator:aebdea0b3d6d9b9e699a15c9a9f532d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde2ea3b922e6de4e2de70c6a8b8a215"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#acde2ea3b922e6de4e2de70c6a8b8a215">operator==</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:acde2ea3b922e6de4e2de70c6a8b8a215"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断两个向量的每个分量是否相等。  <a href="#acde2ea3b922e6de4e2de70c6a8b8a215">更多...</a><br/></td></tr>
<tr class="separator:acde2ea3b922e6de4e2de70c6a8b8a215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa259f5756ea842a985cc0ed1036e73a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#aa259f5756ea842a985cc0ed1036e73a9">operator!=</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:aa259f5756ea842a985cc0ed1036e73a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断两个向量是否不相等。  <a href="#aa259f5756ea842a985cc0ed1036e73a9">更多...</a><br/></td></tr>
<tr class="separator:aa259f5756ea842a985cc0ed1036e73a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36e4c06c86f59ae24a5984c7399d886"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#ad36e4c06c86f59ae24a5984c7399d886">operator&lt;</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ad36e4c06c86f59ae24a5984c7399d886"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断该向量是否小于另一个向量。  <a href="#ad36e4c06c86f59ae24a5984c7399d886">更多...</a><br/></td></tr>
<tr class="separator:ad36e4c06c86f59ae24a5984c7399d886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fba1110685ea94a71c7c0cf494b849"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#ab2fba1110685ea94a71c7c0cf494b849">operator&lt;=</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ab2fba1110685ea94a71c7c0cf494b849"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断该向量是否小于等于另一个向量。  <a href="#ab2fba1110685ea94a71c7c0cf494b849">更多...</a><br/></td></tr>
<tr class="separator:ab2fba1110685ea94a71c7c0cf494b849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5023e588b873426b82b1f5dffd03f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a6a5023e588b873426b82b1f5dffd03f4">operator&gt;</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a6a5023e588b873426b82b1f5dffd03f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断该向量是否大于另一个向量。  <a href="#a6a5023e588b873426b82b1f5dffd03f4">更多...</a><br/></td></tr>
<tr class="separator:a6a5023e588b873426b82b1f5dffd03f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7310d6a5d83466e3eef0a4d1cb8943"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#abd7310d6a5d83466e3eef0a4d1cb8943">operator&gt;=</a> (const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:abd7310d6a5d83466e3eef0a4d1cb8943"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断该向量是否大于等于另一个向量。  <a href="#abd7310d6a5d83466e3eef0a4d1cb8943">更多...</a><br/></td></tr>
<tr class="separator:abd7310d6a5d83466e3eef0a4d1cb8943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627b1940ec29f27d62c13d31658f945e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a627b1940ec29f27d62c13d31658f945e">print</a> (std::ostream &amp;os=<a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a>) const</td></tr>
<tr class="memdesc:a627b1940ec29f27d62c13d31658f945e"><td class="mdescLeft">&#160;</td><td class="mdescRight">格式化输出，默认输出到 <a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> 流。  <a href="#a627b1940ec29f27d62c13d31658f945e">更多...</a><br/></td></tr>
<tr class="separator:a627b1940ec29f27d62c13d31658f945e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8ca43352381259a40530de1daa4dbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a2d8ca43352381259a40530de1daa4dbe">write_unformatted</a> (std::ostream &amp;out_stream, const bool newline=true) const</td></tr>
<tr class="memdesc:a2d8ca43352381259a40530de1daa4dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">无格式输出到流 out。只是将向量的元素用空格分隔打印出来。 默认情况下，还会打印一个换行符，但可以通过 newline 参数来控制这个行为。  <a href="#a2d8ca43352381259a40530de1daa4dbe">更多...</a><br/></td></tr>
<tr class="separator:a2d8ca43352381259a40530de1daa4dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected 属性</h2></td></tr>
<tr class="memitem:a164f4a8009b50213232b6fe9e47b5de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TypeVector.html#a164f4a8009b50213232b6fe9e47b5de0">_coords</a> [LIBMESH_DIM]</td></tr>
<tr class="memdesc:a164f4a8009b50213232b6fe9e47b5de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeVector 的坐标。  <a href="#a164f4a8009b50213232b6fe9e47b5de0">更多...</a><br/></td></tr>
<tr class="separator:a164f4a8009b50213232b6fe9e47b5de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
友元</h2></td></tr>
<tr class="memitem:a6db9d28bd448a131448276ee03de1e6d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Point.html#a6db9d28bd448a131448276ee03de1e6d">Node</a></td></tr>
<tr class="memdesc:a6db9d28bd448a131448276ee03de1e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the derived class a friend.  <a href="#a6db9d28bd448a131448276ee03de1e6d">更多...</a><br/></td></tr>
<tr class="separator:a6db9d28bd448a131448276ee03de1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>A <code><a class="el" href="classlibMesh_1_1Point.html" title="A Point defines a location in LIBMESH_DIM dimensional Real space. ">Point</a></code> defines a location in LIBMESH_DIM dimensional Real space. </p>
<p>Points are always real-valued, even if the library is configured with <code>&ndash;enable-complex</code>.</p>
<dl class="section author"><dt>作者</dt><dd>Benjamin S. Kirk </dd></dl>
<dl class="section date"><dt>日期</dt><dd>2003 A geometric point in (x,y,z) space. </dd></dl>

<p>在文件 <a class="el" href="point_8h_source.html">point.h</a> 第 <a class="el" href="point_8h_source.html#l00039">39</a> 行定义.</p>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a class="anchor" id="a85e83ffbc976ec4665c112b1b6076f67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::<a class="el" href="classlibMesh_1_1TypeVector.html#a85e83ffbc976ec4665c112b1b6076f67">index_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>辅助 typedef 用于泛型索引编程。 </p>

<p>在文件 <a class="el" href="type__vector_8h_source.html">type_vector.h</a> 第 <a class="el" href="type__vector_8h_source.html#l00211">211</a> 行定义.</p>

</div>
</div>
<a class="anchor" id="a702b197a7ae281d7c8f893759a9a35eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::<a class="el" href="classlibMesh_1_1TypeVector.html#a702b197a7ae281d7c8f893759a9a35eb">value_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>辅助 typedef 用于 C++98 泛型编程。 </p>

<p>在文件 <a class="el" href="type__vector_8h_source.html">type_vector.h</a> 第 <a class="el" href="type__vector_8h_source.html#l00206">206</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a class="anchor" id="a1d422159eca00677230dcb247daf4c21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Point::Point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>By default sets all entries to 0. Gives the point 0 in <code>LIBMESH_DIM</code> dimensions. </p>

<p>在文件 <a class="el" href="point_8h_source.html">point.h</a> 第 <a class="el" href="point_8h_source.html#l00047">47</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                          :</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <a class="code" href="namespacelibMesh.html#a6f5724ec09e1967def81186361cfcf42">TypeVector&lt;Real&gt;</a> (x,y,z)</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  {}</div>
<div class="ttc" id="namespacelibMesh_html_a6f5724ec09e1967def81186361cfcf42"><div class="ttname"><a href="namespacelibMesh.html#a6f5724ec09e1967def81186361cfcf42">libMesh::TypeVector&lt; Real &gt;</a></div><div class="ttdeci">template class LIBMESH_EXPORT TypeVector&lt; Real &gt;</div><div class="ttdef"><b>Definition:</b> <a href="type__vector_8C_source.html#l00227">type_vector.C:227</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8e98de819d696f360619c8d7eeaf8577"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Point::Point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trivial copy-constructor. </p>

</div>
</div>
<a class="anchor" id="a5a473d4b789a119bf7e36434d8872c4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Point::Point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructor from non-point Typevector. </p>

<p>在文件 <a class="el" href="point_8h_source.html">point.h</a> 第 <a class="el" href="point_8h_source.html#l00061">61</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                                     :</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespacelibMesh.html#a6f5724ec09e1967def81186361cfcf42">TypeVector&lt;Real&gt;</a> (p)</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  {}</div>
<div class="ttc" id="namespacelibMesh_html_a6f5724ec09e1967def81186361cfcf42"><div class="ttname"><a href="namespacelibMesh.html#a6f5724ec09e1967def81186361cfcf42">libMesh::TypeVector&lt; Real &gt;</a></div><div class="ttdeci">template class LIBMESH_EXPORT TypeVector&lt; Real &gt;</div><div class="ttdef"><b>Definition:</b> <a href="type__vector_8C_source.html#l00227">type_vector.C:227</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4a97450df9564ad3821c7587eb0dca49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename boostcopy::enable_if_c&lt;ScalarTraits&lt;T&gt;::value,void&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Point::Point </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disambiguate constructing from non-Real scalars. </p>

<p>在文件 <a class="el" href="point_8h_source.html">point.h</a> 第 <a class="el" href="point_8h_source.html#l00076">76</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                    :</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <a class="code" href="namespacelibMesh.html#a6f5724ec09e1967def81186361cfcf42">TypeVector&lt;Real&gt;</a> (x,0,0)</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  {}</div>
<div class="ttc" id="namespacelibMesh_html_a6f5724ec09e1967def81186361cfcf42"><div class="ttname"><a href="namespacelibMesh.html#a6f5724ec09e1967def81186361cfcf42">libMesh::TypeVector&lt; Real &gt;</a></div><div class="ttdeci">template class LIBMESH_EXPORT TypeVector&lt; Real &gt;</div><div class="ttdef"><b>Definition:</b> <a href="type__vector_8C_source.html#l00227">type_vector.C:227</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac437fa82ea6c063ff934c2b5616da4c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Point::~Point </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a class="anchor" id="aebdea0b3d6d9b9e699a15c9a9f532d8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::absolute_fuzzy_equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; Real  &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>tol</em> = <code>TOLERANCE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断两个向量是否在绝对容差 tol 内相等。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>另一个向量。 </td></tr>
    <tr><td class="paramname">tol</td><td>绝对容差。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果两个向量在绝对容差 tol 内相等，则返回 true。 </dd></dl>

</div>
</div>
<a class="anchor" id="a2fc6ff827f81abc236e8baa5f3e13661"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在不创建临时对象的情况下将向量赋值给该向量。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2</td><td>要从中赋值元素的向量的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>要赋值的向量。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2549251d3c12ddcc84c292ddaf9c5818"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> , T2&gt;::supertype <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回 <a class="el" href="namespacelibMesh.html#a0f88a869cb829c72bcd5145908e12742">TypeVector::operator*()</a> 的结果。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2</td><td>另一个向量的元素类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>另一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>两个向量的点积结果。 </dd></dl>

</div>
</div>
<a class="anchor" id="a00d6b8d9b0f2b60c32f27a49a21e969e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt;typename <a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> , T2&gt;::supertype&gt; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>计算该向量与另一个向量的叉积。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2</td><td>另一个向量的元素类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>另一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>两个向量的叉积结果。 </dd></dl>

</div>
</div>
<a class="anchor" id="ae1e06813c6340e58fffa0ddc534a643e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::is_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断向量的所有值是否为零。 </p>
<dl class="section return"><dt>返回</dt><dd>如果向量中所有值都为零，则返回 true。 </dd></dl>

</div>
</div>
<a class="anchor" id="a4651826286cfbc7d36fccf81ec0a5a14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const-&gt; decltype(std::norm(Real ()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回向量的模，即元素平方和的平方根。 </p>
<dl class="section return"><dt>返回</dt><dd>向量的模。 </dd></dl>

</div>
</div>
<a class="anchor" id="a3a2312d576bfab58b2e760ad7da3c17b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::norm_sq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const-&gt; decltype(<a class="el" href="namespacestd.html#a6e740e64c53e9ae1489f7eee3899c10f">std::norm</a>(Real ()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回向量的模的平方，即元素模的平方和。 </p>
<dl class="section return"><dt>返回</dt><dd>向量的模的平方。 </dd></dl>

</div>
</div>
<a class="anchor" id="aa259f5756ea842a985cc0ed1036e73a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; Real  &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断两个向量是否不相等。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>另一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果两个向量不相等，则返回 true。 </dd></dl>

</div>
</div>
<a class="anchor" id="a608985f52c18676847e7acb6623beb24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &amp; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回向量中的第 i 个分量的常量引用。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>分量的索引。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>向量中的第 i 个分量的常量引用。 </dd></dl>

</div>
</div>
<a class="anchor" id="a3568df25f9c0db5decbcaa9d42420439"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &amp; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回向量中的第 i 个分量的可写引用。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>分量的索引。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>向量中的第 i 个分量的可写引用。 </dd></dl>

</div>
</div>
<a class="anchor" id="afdc0452b50d53d6e48ff97f1de35c1af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibMesh_1_1boostcopy_1_1enable__if__c.html">boostcopy::enable_if_c</a>&lt; <a class="el" href="structlibMesh_1_1ScalarTraits.html">ScalarTraits</a>&lt;Scalar&gt;::<a class="el" href="xdr__io_8C.html#a11ddd051208250c32dc4985abcafa86d">value</a>, <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt;typename <a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> , Scalar&gt;::supertype&gt; &gt;::type <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将该向量乘以标量值。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>标量值的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>要乘以的标量值。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>结果的副本，该向量保持不变。 </dd></dl>

</div>
</div>
<a class="anchor" id="a1388c1c9def375b105b7063c051e0f22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> , T2&gt;::supertype <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>计算该向量与另一个向量的点积。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2</td><td>另一个向量的元素类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>另一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>两个向量的点积结果。</dd></dl>
<dl class="section note"><dt>注解</dt><dd>在复数情况下，不进行复共轭操作。 </dd>
<dd>
这两个向量可以包含不同的数值类型。 </dd></dl>

</div>
</div>
<a class="anchor" id="a0dcf912ac5f3164c2aa98bd9730f893c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt;&amp; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Real  &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将该向量乘以标量值。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>标量值的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>要乘以的标量值。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>指向 *this 的引用。 </dd></dl>

</div>
</div>
<a class="anchor" id="ada2d643d13070a1bfcee9eb566e92f78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt;typename <a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> , T2&gt;::supertype&gt; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>向量相加。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2</td><td>另一个向量的元素类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>要相加的另一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>结果的副本，该向量保持不变。 </dd></dl>

</div>
</div>
<a class="anchor" id="ac9c45641a3cbeabde2d926c00576e5b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt;&amp; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>向量相加。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2</td><td>另一个向量的元素类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>要相加的另一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>指向 *this 的引用。 </dd></dl>

</div>
</div>
<a class="anchor" id="a70145631b2ca6d9090f4037446dddf98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt;typename <a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> , T2&gt;::supertype&gt; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>从另一个向量中减去该向量。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2</td><td>另一个向量的元素类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>要从中减去的向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>结果的副本，该向量保持不变。 </dd></dl>

</div>
</div>
<a class="anchor" id="aacc0e36b6b5bd587b19f819ba7495ce4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回该向量的相反向量的副本。 </p>
<dl class="section return"><dt>返回</dt><dd>相反向量的副本。 </dd></dl>

</div>
</div>
<a class="anchor" id="a567bf70581fb4eba128cedcc216ce0aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt;&amp; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>从该向量中减去另一个向量。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2</td><td>另一个向量的元素类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>要从中减去的向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>指向 *this 的引用。 </dd></dl>

</div>
</div>
<a class="anchor" id="a5e0ea9743238361fbacd62ad318f8505"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibMesh_1_1boostcopy_1_1enable__if__c.html">boostcopy::enable_if_c</a>&lt; <a class="el" href="structlibMesh_1_1ScalarTraits.html">ScalarTraits</a>&lt;Scalar&gt;::<a class="el" href="xdr__io_8C.html#a11ddd051208250c32dc4985abcafa86d">value</a>, <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt;typename <a class="el" href="structlibMesh_1_1CompareTypes.html">CompareTypes</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> , Scalar&gt;::supertype&gt; &gt;::type <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将该向量的每个分量除以标量值。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>标量值的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>要除以的标量值。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>结果的副本，该向量保持不变。 </dd></dl>

</div>
</div>
<a class="anchor" id="aa445230e5dc262e1f1246503d1bff1a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt;&amp; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Real  &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将该向量的每个分量除以标量值。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>标量值的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>要除以的标量值。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>指向 *this 的引用。 </dd></dl>

</div>
</div>
<a class="anchor" id="ad36e4c06c86f59ae24a5984c7399d886"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; Real  &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断该向量是否小于另一个向量。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>另一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果该向量小于另一个向量，则返回 true。</dd></dl>
<p>用于排序。还用于选择某些任意基函数的方向。 </p>

</div>
</div>
<a class="anchor" id="ab2fba1110685ea94a71c7c0cf494b849"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; Real  &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断该向量是否小于等于另一个向量。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>另一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果该向量小于等于另一个向量，则返回 true。</dd></dl>
<p>用于排序。还用于选择某些任意约束方程的方向。 </p>

</div>
</div>
<a class="anchor" id="abd5bf41f185d4d7fb884e9189428af68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1Point.html">Point</a>&amp; libMesh::Point::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assignment operator. </p>

</div>
</div>
<a class="anchor" id="acde2ea3b922e6de4e2de70c6a8b8a215"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; Real  &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断两个向量的每个分量是否相等。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>另一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果两个向量的每个分量都相等，则返回 true。</dd></dl>
<dl class="section note"><dt>注解</dt><dd>对于浮点类型 T，可能更适合使用 <a class="el" href="classlibMesh_1_1TypeVector.html#aebdea0b3d6d9b9e699a15c9a9f532d8a" title="判断两个向量是否在绝对容差 tol 内相等。 ">absolute_fuzzy_equals()</a> 函数。 </dd></dl>

<p>参考自 <a class="el" href="node_8C_source.html#l00037">libMesh::Node::operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a5023e588b873426b82b1f5dffd03f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; Real  &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断该向量是否大于另一个向量。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>另一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果该向量大于另一个向量，则返回 true。</dd></dl>
<p>用于排序。还用于选择某些任意基函数的方向。 </p>

</div>
</div>
<a class="anchor" id="abd7310d6a5d83466e3eef0a4d1cb8943"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; Real  &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断该向量是否大于等于另一个向量。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>另一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果该向量大于等于另一个向量，则返回 true。</dd></dl>
<p>用于排序。还用于选择某些任意约束方程的方向。 </p>

</div>
</div>
<a class="anchor" id="a627b1940ec29f27d62c13d31658f945e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code><a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>格式化输出，默认输出到 <a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> 流。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>输出流，默认为 libMesh::out。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a510b7f78c908b4d0f2a1250bace34d88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::relative_fuzzy_equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; Real  &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>tol</em> = <code>TOLERANCE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断两个向量是否在相对容差 tol 内相等。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>另一个向量。 </td></tr>
    <tr><td class="paramname">tol</td><td>相对容差。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果两个向量在相对容差 tol 内相等，则返回 true。 </dd></dl>

</div>
</div>
<a class="anchor" id="a792b992a3ab29cf4019e9068b6b42806"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &amp; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="type__vector_8h_source.html">type_vector.h</a> 第 <a class="el" href="type__vector_8h_source.html#l00262">262</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;{ <span class="keywordflow">return</span> (*<span class="keyword">this</span>)(i); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af7fe612232c6f64b41e8122e9d2e35de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &amp; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="type__vector_8h_source.html">type_vector.h</a> 第 <a class="el" href="type__vector_8h_source.html#l00271">271</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;{ <span class="keywordflow">return</span> (*<span class="keyword">this</span>)(i); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab63f42e523de8a8a0b7a970ec29630fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>从另一个向量中减去该向量，不创建临时对象。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2</td><td>另一个向量的元素类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>要从中减去的向量。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0190035fd2382f69a52dec56ab780c4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::subtract_scaled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real  &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>从该向量中减去另一个向量的缩放值，不创建临时对象。 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2</td><td>另一个向量的元素类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>要从中减去的向量。 </td></tr>
    <tr><td class="paramname">scale</td><td>缩放值。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af309ac3227a31641f8e8ecbe9bb972a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1TypeVector.html">TypeVector</a>&lt;<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::unit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向该向量方向的单位向量。 </p>
<dl class="section return"><dt>返回</dt><dd>单位向量。 </dd></dl>

</div>
</div>
<a class="anchor" id="a2d8ca43352381259a40530de1daa4dbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::write_unformatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>newline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>无格式输出到流 out。只是将向量的元素用空格分隔打印出来。 默认情况下，还会打印一个换行符，但可以通过 newline 参数来控制这个行为。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out_stream</td><td>输出流。 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">newline</td><td>是否打印换行符，默认为 true。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4039c6e4f87fa907b3aeaafd66c0c1ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将向量的所有分量设置为零。 </p>

</div>
</div>
<h2 class="groupheader">友元及相关函数文档</h2>
<a class="anchor" id="a6db9d28bd448a131448276ee03de1e6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classlibMesh_1_1Node.html">Node</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the derived class a friend. </p>

<p>在文件 <a class="el" href="point_8h_source.html">point.h</a> 第 <a class="el" href="point_8h_source.html#l00090">90</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a class="anchor" id="a164f4a8009b50213232b6fe9e47b5de0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  <a class="el" href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  &gt;::_coords[LIBMESH_DIM]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TypeVector 的坐标。 </p>

<p>在文件 <a class="el" href="type__vector_8h_source.html">type_vector.h</a> 第 <a class="el" href="type__vector_8h_source.html#l00565">565</a> 行定义.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>/home/lwz/libmesh/include/geom/<a class="el" href="point_8h_source.html">point.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2023年 十二月 20日 星期三 12:09:32 , 为 libmesh解析使用  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
