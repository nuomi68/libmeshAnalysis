<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libmesh解析: libMesh::AdaptiveTimeSolver类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libmesh解析
   </div>
   <div id="projectbrief">本工作只是尝试解析原libmesh的代码,供学习使用</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li class="current"><a href="annotated.html"><span>类</span></a></li>
      <li><a href="files.html"><span>文件</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>类列表</span></a></li>
      <li><a href="classes.html"><span>类索引</span></a></li>
      <li><a href="inherits.html"><span>类继承关系</span></a></li>
      <li><a href="functions.html"><span>类成员</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>全部</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>类</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>命名空间</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>文件</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>函数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>变量</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>类型定义</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>枚举</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>枚举值</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>友元</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>页</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html">AdaptiveTimeSolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="#pub-attribs">Public 属性</a> &#124;
<a href="#pro-types">Protected 类型</a> &#124;
<a href="#pro-methods">Protected 成员函数</a> &#124;
<a href="#pro-attribs">Protected 属性</a> &#124;
<a href="#pro-static-attribs">静态 Protected 属性</a> &#124;
<a href="classlibMesh_1_1AdaptiveTimeSolver-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::AdaptiveTimeSolver类 参考<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class wraps another <a class="el" href="classlibMesh_1_1UnsteadySolver.html" title="This is a generic class that defines a solver to handle time integration of DifferentiableSystems. ">UnsteadySolver</a> derived class, and compares the results of timestepping with deltat and timestepping with 2*deltat to adjust future timestep lengths.  
 <a href="classlibMesh_1_1AdaptiveTimeSolver.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a>&gt;</code></p>
<div class="dynheader">
类 libMesh::AdaptiveTimeSolver 继承关系图:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:ace5314b1c800e607e8b51f1953450a7a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classlibMesh_1_1FirstOrderUnsteadySolver.html">FirstOrderUnsteadySolver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#ace5314b1c800e607e8b51f1953450a7a">Parent</a></td></tr>
<tr class="memdesc:ace5314b1c800e607e8b51f1953450a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent class.  <a href="#ace5314b1c800e607e8b51f1953450a7a">更多...</a><br/></td></tr>
<tr class="separator:ace5314b1c800e607e8b51f1953450a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7363e989661b62466ed602c1189f5a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classlibMesh_1_1DifferentiableSystem.html">DifferentiableSystem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#a4e7363e989661b62466ed602c1189f5a">sys_type</a></td></tr>
<tr class="memdesc:a4e7363e989661b62466ed602c1189f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of system.  <a href="#a4e7363e989661b62466ed602c1189f5a">更多...</a><br/></td></tr>
<tr class="separator:a4e7363e989661b62466ed602c1189f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:ac9d39e0aca9faaa22f2afc948645b93a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#ac9d39e0aca9faaa22f2afc948645b93a">AdaptiveTimeSolver</a> (<a class="el" href="classlibMesh_1_1TimeSolver.html#a4e7363e989661b62466ed602c1189f5a">sys_type</a> &amp;s)</td></tr>
<tr class="memdesc:ac9d39e0aca9faaa22f2afc948645b93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ac9d39e0aca9faaa22f2afc948645b93a">更多...</a><br/></td></tr>
<tr class="separator:ac9d39e0aca9faaa22f2afc948645b93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1c823f34455546af9f6cecaec91245"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a8c1c823f34455546af9f6cecaec91245">~AdaptiveTimeSolver</a> ()</td></tr>
<tr class="memdesc:a8c1c823f34455546af9f6cecaec91245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a8c1c823f34455546af9f6cecaec91245">更多...</a><br/></td></tr>
<tr class="separator:a8c1c823f34455546af9f6cecaec91245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ff3926455efb7259d4bcc0c23daa54"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#ae8ff3926455efb7259d4bcc0c23daa54">init</a> () override</td></tr>
<tr class="memdesc:ae8ff3926455efb7259d4bcc0c23daa54"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initialization function.  <a href="#ae8ff3926455efb7259d4bcc0c23daa54">更多...</a><br/></td></tr>
<tr class="separator:ae8ff3926455efb7259d4bcc0c23daa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056c5a74107f6609bd2c96a040c9ddd0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a056c5a74107f6609bd2c96a040c9ddd0">reinit</a> () override</td></tr>
<tr class="memdesc:a056c5a74107f6609bd2c96a040c9ddd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reinitialization function.  <a href="#a056c5a74107f6609bd2c96a040c9ddd0">更多...</a><br/></td></tr>
<tr class="separator:a056c5a74107f6609bd2c96a040c9ddd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115b029ab169245296d22487b3d83c46"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a115b029ab169245296d22487b3d83c46">solve</a> () override=0</td></tr>
<tr class="memdesc:a115b029ab169245296d22487b3d83c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method solves for the solution at the next timestep.  <a href="#a115b029ab169245296d22487b3d83c46">更多...</a><br/></td></tr>
<tr class="separator:a115b029ab169245296d22487b3d83c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53adbea7f55f2adc3aade0a2d6799a4c"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; unsigned <br class="typebreak"/>
int, <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a53adbea7f55f2adc3aade0a2d6799a4c">adjoint_solve</a> (const <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> &amp;qoi_indices) override=0</td></tr>
<tr class="memdesc:a53adbea7f55f2adc3aade0a2d6799a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method solves for the adjoint solution at the next adjoint timestep (or a steady state adjoint solve)  <a href="#a53adbea7f55f2adc3aade0a2d6799a4c">更多...</a><br/></td></tr>
<tr class="separator:a53adbea7f55f2adc3aade0a2d6799a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879ee9dc3c4324313f820b1a6302d95b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a879ee9dc3c4324313f820b1a6302d95b">advance_timestep</a> () override</td></tr>
<tr class="memdesc:a879ee9dc3c4324313f820b1a6302d95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method advances the solution to the next timestep, after a <a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a115b029ab169245296d22487b3d83c46" title="This method solves for the solution at the next timestep. ">solve()</a> has been performed.  <a href="#a879ee9dc3c4324313f820b1a6302d95b">更多...</a><br/></td></tr>
<tr class="separator:a879ee9dc3c4324313f820b1a6302d95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0f733d6c8e54cb535fb88d3d5a4300"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a0f0f733d6c8e54cb535fb88d3d5a4300">adjoint_advance_timestep</a> () override</td></tr>
<tr class="memdesc:a0f0f733d6c8e54cb535fb88d3d5a4300"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method advances the adjoint solution to the previous timestep, after an <a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a53adbea7f55f2adc3aade0a2d6799a4c" title="This method solves for the adjoint solution at the next adjoint timestep (or a steady state adjoint s...">adjoint_solve()</a> has been performed.  <a href="#a0f0f733d6c8e54cb535fb88d3d5a4300">更多...</a><br/></td></tr>
<tr class="separator:a0f0f733d6c8e54cb535fb88d3d5a4300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55437fc1f7a75daec617e64c4f2e87e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#ae55437fc1f7a75daec617e64c4f2e87e">retrieve_timestep</a> () override</td></tr>
<tr class="memdesc:ae55437fc1f7a75daec617e64c4f2e87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method retrieves all the stored solutions at the current system.time.  <a href="#ae55437fc1f7a75daec617e64c4f2e87e">更多...</a><br/></td></tr>
<tr class="separator:ae55437fc1f7a75daec617e64c4f2e87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d86173ce93b7ab991a1dfbc5efe73c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a29d86173ce93b7ab991a1dfbc5efe73c">integrate_qoi_timestep</a> () override=0</td></tr>
<tr class="memdesc:a29d86173ce93b7ab991a1dfbc5efe73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method to integrate the system::QoI functionals.  <a href="#a29d86173ce93b7ab991a1dfbc5efe73c">更多...</a><br/></td></tr>
<tr class="separator:a29d86173ce93b7ab991a1dfbc5efe73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50282a676145e736e62ba87202e570a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a50282a676145e736e62ba87202e570a9">integrate_adjoint_sensitivity</a> (const <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> &amp;qois, const <a class="el" href="classlibMesh_1_1ParameterVector.html">ParameterVector</a> &amp;parameter_vector, <a class="el" href="classlibMesh_1_1SensitivityData.html">SensitivityData</a> &amp;sensitivities) override=0</td></tr>
<tr class="memdesc:a50282a676145e736e62ba87202e570a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method to integrate the adjoint sensitivity w.r.t a given parameter vector.  <a href="#a50282a676145e736e62ba87202e570a9">更多...</a><br/></td></tr>
<tr class="separator:a50282a676145e736e62ba87202e570a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cb688f5178159af6aec8e52e39cd62"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a57cb688f5178159af6aec8e52e39cd62">integrate_adjoint_refinement_error_estimate</a> (<a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;adjoint_refinement_error_estimator, <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;QoI_elementwise_error) override=0</td></tr>
<tr class="memdesc:a57cb688f5178159af6aec8e52e39cd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method to compute the adjoint refinement error estimate at the current timestep.  <a href="#a57cb688f5178159af6aec8e52e39cd62">更多...</a><br/></td></tr>
<tr class="separator:a57cb688f5178159af6aec8e52e39cd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3c0328f3b600cc93c90b1dbc397674"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a9e3c0328f3b600cc93c90b1dbc397674">last_completed_timestep_size</a> () override</td></tr>
<tr class="memdesc:a9e3c0328f3b600cc93c90b1dbc397674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns system.deltat if fixed timestep solver is used, the complete timestep size (sum of all substeps) if the adaptive time solver is used.  <a href="#a9e3c0328f3b600cc93c90b1dbc397674">更多...</a><br/></td></tr>
<tr class="separator:a9e3c0328f3b600cc93c90b1dbc397674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41ef7eb1270e12967fc809f79d2e5cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#ae41ef7eb1270e12967fc809f79d2e5cb">error_order</a> () const override</td></tr>
<tr class="memdesc:ae41ef7eb1270e12967fc809f79d2e5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is passed on to the core_time_solver.  <a href="#ae41ef7eb1270e12967fc809f79d2e5cb">更多...</a><br/></td></tr>
<tr class="separator:ae41ef7eb1270e12967fc809f79d2e5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73faaabfe147582753d984c86207fc7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#ab73faaabfe147582753d984c86207fc7">element_residual</a> (bool get_jacobian, <a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;) override</td></tr>
<tr class="memdesc:ab73faaabfe147582753d984c86207fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is passed on to the core_time_solver.  <a href="#ab73faaabfe147582753d984c86207fc7">更多...</a><br/></td></tr>
<tr class="separator:ab73faaabfe147582753d984c86207fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc68e6b09cf4f44dfbb163e364c5f81"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6fc68e6b09cf4f44dfbb163e364c5f81">side_residual</a> (bool get_jacobian, <a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;) override</td></tr>
<tr class="memdesc:a6fc68e6b09cf4f44dfbb163e364c5f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is passed on to the core_time_solver.  <a href="#a6fc68e6b09cf4f44dfbb163e364c5f81">更多...</a><br/></td></tr>
<tr class="separator:a6fc68e6b09cf4f44dfbb163e364c5f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf71c8e982a9dda1a65e2a0b09831a6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#abdf71c8e982a9dda1a65e2a0b09831a6">nonlocal_residual</a> (bool get_jacobian, <a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;) override</td></tr>
<tr class="memdesc:abdf71c8e982a9dda1a65e2a0b09831a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is passed on to the core_time_solver.  <a href="#abdf71c8e982a9dda1a65e2a0b09831a6">更多...</a><br/></td></tr>
<tr class="separator:abdf71c8e982a9dda1a65e2a0b09831a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24466af444ea6d56e98407c155a42ac"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classlibMesh_1_1DiffSolver.html">DiffSolver</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#aa24466af444ea6d56e98407c155a42ac">diff_solver</a> () override</td></tr>
<tr class="memdesc:aa24466af444ea6d56e98407c155a42ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implicit linear or nonlinear solver to use at each timestep.  <a href="#aa24466af444ea6d56e98407c155a42ac">更多...</a><br/></td></tr>
<tr class="separator:aa24466af444ea6d56e98407c155a42ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd477c84431a2a3e932f3df911c7fe1"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classlibMesh_1_1LinearSolver.html">LinearSolver</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a3cd477c84431a2a3e932f3df911c7fe1">linear_solver</a> () override</td></tr>
<tr class="memdesc:a3cd477c84431a2a3e932f3df911c7fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implicit linear solver to use for adjoint and sensitivity problems.  <a href="#a3cd477c84431a2a3e932f3df911c7fe1">更多...</a><br/></td></tr>
<tr class="separator:a3cd477c84431a2a3e932f3df911c7fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89b1912967ede85ed664eb254dd8382"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1FirstOrderUnsteadySolver.html#ae89b1912967ede85ed664eb254dd8382">time_order</a> () const override</td></tr>
<tr class="separator:ae89b1912967ede85ed664eb254dd8382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc7d50d6e18bc1be3efcc91e86b5529"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#a2bc7d50d6e18bc1be3efcc91e86b5529">init_adjoints</a> () override</td></tr>
<tr class="memdesc:a2bc7d50d6e18bc1be3efcc91e86b5529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add adjoint vectors and old_adjoint_vectors as per the indices of <a class="el" href="classlibMesh_1_1QoISet.html" title="Data structure for specifying which Quantities of Interest should be calculated in an adjoint or a pa...">QoISet</a>.  <a href="#a2bc7d50d6e18bc1be3efcc91e86b5529">更多...</a><br/></td></tr>
<tr class="separator:a2bc7d50d6e18bc1be3efcc91e86b5529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5427a0c0cf6d022c9c3ce9e71fa3d8f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#a5427a0c0cf6d022c9c3ce9e71fa3d8f4">init_data</a> () override</td></tr>
<tr class="memdesc:a5427a0c0cf6d022c9c3ce9e71fa3d8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data initialization function.  <a href="#a5427a0c0cf6d022c9c3ce9e71fa3d8f4">更多...</a><br/></td></tr>
<tr class="separator:a5427a0c0cf6d022c9c3ce9e71fa3d8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbec9f5e45a2b2f3c8e3fdcb1e2abd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#a3fbec9f5e45a2b2f3c8e3fdcb1e2abd7">update</a> ()</td></tr>
<tr class="separator:a3fbec9f5e45a2b2f3c8e3fdcb1e2abd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a15d929fc0179d7a2e88928ad719ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#aa3a15d929fc0179d7a2e88928ad719ad">old_nonlinear_solution</a> (const <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> global_dof_number) const </td></tr>
<tr class="separator:aa3a15d929fc0179d7a2e88928ad719ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066acfcd6a68ce24f01fe145ff64b90b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#a066acfcd6a68ce24f01fe145ff64b90b">du</a> (const <a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> &amp;norm) const override</td></tr>
<tr class="memdesc:a066acfcd6a68ce24f01fe145ff64b90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the size of ||u^{n+1} - u^{n}|| in some norm.  <a href="#a066acfcd6a68ce24f01fe145ff64b90b">更多...</a><br/></td></tr>
<tr class="separator:a066acfcd6a68ce24f01fe145ff64b90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9edb1f593be85de005e80fdc273f44"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#a3e9edb1f593be85de005e80fdc273f44">is_steady</a> () const override</td></tr>
<tr class="memdesc:a3e9edb1f593be85de005e80fdc273f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is not a steady-state solver.  <a href="#a3e9edb1f593be85de005e80fdc273f44">更多...</a><br/></td></tr>
<tr class="separator:a3e9edb1f593be85de005e80fdc273f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd07c68ca275025276a9a0fcc921262d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#afd07c68ca275025276a9a0fcc921262d">set_first_adjoint_step</a> (bool first_adjoint_step_setting)</td></tr>
<tr class="memdesc:afd07c68ca275025276a9a0fcc921262d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A setter for the first_adjoint_step boolean.  <a href="#afd07c68ca275025276a9a0fcc921262d">更多...</a><br/></td></tr>
<tr class="separator:afd07c68ca275025276a9a0fcc921262d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d14b4501a87b26e726976656d435f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#a6d14b4501a87b26e726976656d435f47">set_first_solve</a> (bool first_solve_setting)</td></tr>
<tr class="separator:a6d14b4501a87b26e726976656d435f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c634934e73a55d1cb397bbdb745904"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#ab8c634934e73a55d1cb397bbdb745904">before_timestep</a> ()</td></tr>
<tr class="memdesc:ab8c634934e73a55d1cb397bbdb745904"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is for subclasses or users to override to do arbitrary processing between timesteps.  <a href="#ab8c634934e73a55d1cb397bbdb745904">更多...</a><br/></td></tr>
<tr class="separator:ab8c634934e73a55d1cb397bbdb745904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72073432986fac3e0f54a1d312955e34"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1TimeSolver.html#a4e7363e989661b62466ed602c1189f5a">sys_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#a72073432986fac3e0f54a1d312955e34">system</a> () const </td></tr>
<tr class="separator:a72073432986fac3e0f54a1d312955e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac973fc3e98afd2e50a536fe9b5501d58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1TimeSolver.html#a4e7363e989661b62466ed602c1189f5a">sys_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#ac973fc3e98afd2e50a536fe9b5501d58">system</a> ()</td></tr>
<tr class="separator:ac973fc3e98afd2e50a536fe9b5501d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd9a20cf257999196a258c936fb79aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#a3dd9a20cf257999196a258c936fb79aa">set_solution_history</a> (const <a class="el" href="classlibMesh_1_1SolutionHistory.html">SolutionHistory</a> &amp;_solution_history)</td></tr>
<tr class="memdesc:a3dd9a20cf257999196a258c936fb79aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A setter function users will employ if they need to do something other than save no solution history.  <a href="#a3dd9a20cf257999196a258c936fb79aa">更多...</a><br/></td></tr>
<tr class="separator:a3dd9a20cf257999196a258c936fb79aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53943438a376aced23535cc111c3033c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1SolutionHistory.html">SolutionHistory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#a53943438a376aced23535cc111c3033c">get_solution_history</a> ()</td></tr>
<tr class="memdesc:a53943438a376aced23535cc111c3033c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A getter function that returns a reference to the solution history object owned by <a class="el" href="classlibMesh_1_1TimeSolver.html" title="This is a generic class that defines a solver to handle time integration of DifferentiableSystems. ">TimeSolver</a>.  <a href="#a53943438a376aced23535cc111c3033c">更多...</a><br/></td></tr>
<tr class="separator:a53943438a376aced23535cc111c3033c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4fe54b2f4feb0a49829a0f15652211"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#abd4fe54b2f4feb0a49829a0f15652211">is_adjoint</a> () const </td></tr>
<tr class="memdesc:abd4fe54b2f4feb0a49829a0f15652211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for querying whether we need to do a primal or adjoint solve.  <a href="#abd4fe54b2f4feb0a49829a0f15652211">更多...</a><br/></td></tr>
<tr class="separator:abd4fe54b2f4feb0a49829a0f15652211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c67591fc3ee089d9a673c11d5fe7c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#a0c67591fc3ee089d9a673c11d5fe7c30">set_is_adjoint</a> (bool _is_adjoint_value)</td></tr>
<tr class="memdesc:a0c67591fc3ee089d9a673c11d5fe7c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for setting whether we need to do a primal or adjoint solve.  <a href="#a0c67591fc3ee089d9a673c11d5fe7c30">更多...</a><br/></td></tr>
<tr class="separator:a0c67591fc3ee089d9a673c11d5fe7c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:a103b37125ae9eaaadf6f7854df17faa2"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a103b37125ae9eaaadf6f7854df17faa2">get_info</a> ()</td></tr>
<tr class="memdesc:a103b37125ae9eaaadf6f7854df17faa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string containing the reference information.  <a href="#a103b37125ae9eaaadf6f7854df17faa2">更多...</a><br/></td></tr>
<tr class="separator:a103b37125ae9eaaadf6f7854df17faa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ce734a14ffd1dbb6496dab702da8e1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a13ce734a14ffd1dbb6496dab702da8e1">print_info</a> (std::ostream &amp;out_stream=<a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a>)</td></tr>
<tr class="memdesc:a13ce734a14ffd1dbb6496dab702da8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the reference information, by default to <code><a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></code>.  <a href="#a13ce734a14ffd1dbb6496dab702da8e1">更多...</a><br/></td></tr>
<tr class="separator:a13ce734a14ffd1dbb6496dab702da8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e74641afc6e2870c9e1ce412f8c44f"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a50e74641afc6e2870c9e1ce412f8c44f">n_objects</a> ()</td></tr>
<tr class="memdesc:a50e74641afc6e2870c9e1ce412f8c44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the number of outstanding (created, but not yet destroyed) objects.  <a href="#a50e74641afc6e2870c9e1ce412f8c44f">更多...</a><br/></td></tr>
<tr class="separator:a50e74641afc6e2870c9e1ce412f8c44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86837c50216b2ddb800b3836d2a08c09"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a86837c50216b2ddb800b3836d2a08c09">enable_print_counter_info</a> ()</td></tr>
<tr class="memdesc:a86837c50216b2ddb800b3836d2a08c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods to enable/disable the reference counter output from <a class="el" href="classlibMesh_1_1ReferenceCounter.html#a13ce734a14ffd1dbb6496dab702da8e1" title="Prints the reference information, by default to libMesh::out. ">print_info()</a>  <a href="#a86837c50216b2ddb800b3836d2a08c09">更多...</a><br/></td></tr>
<tr class="separator:a86837c50216b2ddb800b3836d2a08c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0a2d3d3c531f9f069b0d623d4ace0f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a5c0a2d3d3c531f9f069b0d623d4ace0f">disable_print_counter_info</a> ()</td></tr>
<tr class="separator:a5c0a2d3d3c531f9f069b0d623d4ace0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public 属性</h2></td></tr>
<tr class="memitem:a6cdd1f46101a1c62ee0fcabb4baeac8b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1UnsteadySolver.html">UnsteadySolver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a></td></tr>
<tr class="memdesc:a6cdd1f46101a1c62ee0fcabb4baeac8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object is used to take timesteps.  <a href="#a6cdd1f46101a1c62ee0fcabb4baeac8b">更多...</a><br/></td></tr>
<tr class="separator:a6cdd1f46101a1c62ee0fcabb4baeac8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a933b429ce060d4c14002db6245136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a59a933b429ce060d4c14002db6245136">component_norm</a></td></tr>
<tr class="memdesc:a59a933b429ce060d4c14002db6245136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error calculations are done in this norm, DISCRETE_L2 by default.  <a href="#a59a933b429ce060d4c14002db6245136">更多...</a><br/></td></tr>
<tr class="separator:a59a933b429ce060d4c14002db6245136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e331379cc4db63ccc8f2cc59551dde"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#ad3e331379cc4db63ccc8f2cc59551dde">component_scale</a></td></tr>
<tr class="memdesc:ad3e331379cc4db63ccc8f2cc59551dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">If component_norms is non-empty, each variable's contribution to the error of a system will also be scaled by component_scale[var], unless component_scale is empty in which case all variables will be weighted equally.  <a href="#ad3e331379cc4db63ccc8f2cc59551dde">更多...</a><br/></td></tr>
<tr class="separator:ad3e331379cc4db63ccc8f2cc59551dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9e4ce98150b7452299c990c6d13741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#aca9e4ce98150b7452299c990c6d13741">target_tolerance</a></td></tr>
<tr class="memdesc:aca9e4ce98150b7452299c990c6d13741"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tolerance is the target relative error between an exact time integration and a single time step output, scaled by deltat.  <a href="#aca9e4ce98150b7452299c990c6d13741">更多...</a><br/></td></tr>
<tr class="separator:aca9e4ce98150b7452299c990c6d13741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d15b5d216cbb6657055125da543c388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a4d15b5d216cbb6657055125da543c388">upper_tolerance</a></td></tr>
<tr class="memdesc:a4d15b5d216cbb6657055125da543c388"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tolerance is the maximum relative error between an exact time integration and a single time step output, scaled by deltat.  <a href="#a4d15b5d216cbb6657055125da543c388">更多...</a><br/></td></tr>
<tr class="separator:a4d15b5d216cbb6657055125da543c388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b378583a8e5d6da9d1408a49b8a0a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a93b378583a8e5d6da9d1408a49b8a0a9">max_deltat</a></td></tr>
<tr class="memdesc:a93b378583a8e5d6da9d1408a49b8a0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not allow the adaptive time solver to select deltat &gt; max_deltat.  <a href="#a93b378583a8e5d6da9d1408a49b8a0a9">更多...</a><br/></td></tr>
<tr class="separator:a93b378583a8e5d6da9d1408a49b8a0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef4f9c102adce5c8ef9cacab1b8cd7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a3ef4f9c102adce5c8ef9cacab1b8cd7c">min_deltat</a></td></tr>
<tr class="memdesc:a3ef4f9c102adce5c8ef9cacab1b8cd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not allow the adaptive time solver to select deltat &lt; min_deltat.  <a href="#a3ef4f9c102adce5c8ef9cacab1b8cd7c">更多...</a><br/></td></tr>
<tr class="separator:a3ef4f9c102adce5c8ef9cacab1b8cd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada68f2f70960a70215aa8978105d9df2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#ada68f2f70960a70215aa8978105d9df2">max_growth</a></td></tr>
<tr class="memdesc:ada68f2f70960a70215aa8978105d9df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not allow the adaptive time solver to select a new deltat greater than max_growth times the old deltat.  <a href="#ada68f2f70960a70215aa8978105d9df2">更多...</a><br/></td></tr>
<tr class="separator:ada68f2f70960a70215aa8978105d9df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3688a87be263c45e7db268869a54e1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a3688a87be263c45e7db268869a54e1e4">completed_timestep_size</a></td></tr>
<tr class="memdesc:a3688a87be263c45e7db268869a54e1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The adaptive time solver's have two notions of deltat.  <a href="#a3688a87be263c45e7db268869a54e1e4">更多...</a><br/></td></tr>
<tr class="separator:a3688a87be263c45e7db268869a54e1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf5c408d7a99cb7d27a819404b85ea3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#accf5c408d7a99cb7d27a819404b85ea3">global_tolerance</a></td></tr>
<tr class="memdesc:accf5c408d7a99cb7d27a819404b85ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This flag, which is true by default, grows (shrinks) the timestep based on the expected global accuracy of the timestepping scheme.  <a href="#accf5c408d7a99cb7d27a819404b85ea3">更多...</a><br/></td></tr>
<tr class="separator:accf5c408d7a99cb7d27a819404b85ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa84acc193756038a9a9361d687f877e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a><br class="typebreak"/>
&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">old_local_nonlinear_solution</a></td></tr>
<tr class="memdesc:aaa84acc193756038a9a9361d687f877e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial vector of _system.get_vector("_old_nonlinear_solution") This is a shared_ptr so that it can be shared between different derived class instances, as in e.g.  <a href="#aaa84acc193756038a9a9361d687f877e">更多...</a><br/></td></tr>
<tr class="separator:aaa84acc193756038a9a9361d687f877e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dff23f37925276a226b06b6f78c136"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#af0dff23f37925276a226b06b6f78c136">quiet</a></td></tr>
<tr class="memdesc:af0dff23f37925276a226b06b6f78c136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print extra debugging information if quiet == false.  <a href="#af0dff23f37925276a226b06b6f78c136">更多...</a><br/></td></tr>
<tr class="separator:af0dff23f37925276a226b06b6f78c136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b77957719eae28de2e753d9a99d825e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#a9b77957719eae28de2e753d9a99d825e">reduce_deltat_on_diffsolver_failure</a></td></tr>
<tr class="memdesc:a9b77957719eae28de2e753d9a99d825e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value (which defaults to zero) is the number of times the <a class="el" href="classlibMesh_1_1TimeSolver.html" title="This is a generic class that defines a solver to handle time integration of DifferentiableSystems. ">TimeSolver</a> is allowed to halve deltat and let the <a class="el" href="classlibMesh_1_1DiffSolver.html" title="This is a generic class that defines a solver to handle ImplicitSystem classes, including NonlinearIm...">DiffSolver</a> repeat the latest failed solve with a reduced timestep.  <a href="#a9b77957719eae28de2e753d9a99d825e">更多...</a><br/></td></tr>
<tr class="separator:a9b77957719eae28de2e753d9a99d825e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected 类型</h2></td></tr>
<tr class="memitem:a2bef2e6f4f3010907ca9a6c9183d475a"><td class="memItemLeft" align="right" valign="top">typedef bool(DifferentiablePhysics::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#a2bef2e6f4f3010907ca9a6c9183d475a">ResFuncType</a> )(bool, <a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;)</td></tr>
<tr class="memdesc:a2bef2e6f4f3010907ca9a6c9183d475a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of argument types for use in refactoring subclasses.  <a href="#a2bef2e6f4f3010907ca9a6c9183d475a">更多...</a><br/></td></tr>
<tr class="separator:a2bef2e6f4f3010907ca9a6c9183d475a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede0ea91f377e087b0f3a5d8f12a0643"><td class="memItemLeft" align="right" valign="top">typedef void(DiffContext::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#aede0ea91f377e087b0f3a5d8f12a0643">ReinitFuncType</a> )(<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>)</td></tr>
<tr class="separator:aede0ea91f377e087b0f3a5d8f12a0643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5daadc989c1fe71ec8d173adf0ed1e"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
std::pair&lt; unsigned int, <br class="typebreak"/>
unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#adb5daadc989c1fe71ec8d173adf0ed1e">Counts</a></td></tr>
<tr class="memdesc:adb5daadc989c1fe71ec8d173adf0ed1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to log the information.  <a href="#adb5daadc989c1fe71ec8d173adf0ed1e">更多...</a><br/></td></tr>
<tr class="separator:adb5daadc989c1fe71ec8d173adf0ed1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected 成员函数</h2></td></tr>
<tr class="memitem:a24cf02c068643d8cd3e4c25d96895a8a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a24cf02c068643d8cd3e4c25d96895a8a">calculate_norm</a> (<a class="el" href="classlibMesh_1_1System.html">System</a> &amp;, <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a24cf02c068643d8cd3e4c25d96895a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to calculate error norms.  <a href="#a24cf02c068643d8cd3e4c25d96895a8a">更多...</a><br/></td></tr>
<tr class="separator:a24cf02c068643d8cd3e4c25d96895a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e53509b111f7bee8137ca33642b11f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1FirstOrderUnsteadySolver.html#a0e53509b111f7bee8137ca33642b11f0">prepare_accel</a> (<a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;context)</td></tr>
<tr class="memdesc:a0e53509b111f7bee8137ca33642b11f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there are second order variables in the system, then we also prepare the accel for those variables so the user can treat them as such.  <a href="#a0e53509b111f7bee8137ca33642b11f0">更多...</a><br/></td></tr>
<tr class="separator:a0e53509b111f7bee8137ca33642b11f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0804044301e3a7fc7ff88aa8e20cadd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1FirstOrderUnsteadySolver.html#a0804044301e3a7fc7ff88aa8e20cadd1">compute_second_order_eqns</a> (bool compute_jacobian, <a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;c)</td></tr>
<tr class="memdesc:a0804044301e3a7fc7ff88aa8e20cadd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there are second order variables, then we need to compute their residual equations and corresponding Jacobian.  <a href="#a0804044301e3a7fc7ff88aa8e20cadd1">更多...</a><br/></td></tr>
<tr class="separator:a0804044301e3a7fc7ff88aa8e20cadd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cd2f1fbd46c66dade1e750436ee7ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#af0cd2f1fbd46c66dade1e750436ee7ab">increment_constructor_count</a> (const std::string &amp;name) noexcept</td></tr>
<tr class="memdesc:af0cd2f1fbd46c66dade1e750436ee7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the construction counter.  <a href="#af0cd2f1fbd46c66dade1e750436ee7ab">更多...</a><br/></td></tr>
<tr class="separator:af0cd2f1fbd46c66dade1e750436ee7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769ddb2e2299db1aafcdfb33dfb830d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a769ddb2e2299db1aafcdfb33dfb830d8">increment_destructor_count</a> (const std::string &amp;name) noexcept</td></tr>
<tr class="memdesc:a769ddb2e2299db1aafcdfb33dfb830d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the destruction counter.  <a href="#a769ddb2e2299db1aafcdfb33dfb830d8">更多...</a><br/></td></tr>
<tr class="separator:a769ddb2e2299db1aafcdfb33dfb830d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected 属性</h2></td></tr>
<tr class="memitem:ad5be0a1a2852028cc39b995b0d07bef6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#ad5be0a1a2852028cc39b995b0d07bef6">first_solve</a></td></tr>
<tr class="memdesc:ad5be0a1a2852028cc39b995b0d07bef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bool that will be true the first time <a class="el" href="classlibMesh_1_1UnsteadySolver.html#aad83b8429f49f336a0cbc1e044c7ab83" title="This method solves for the solution at the next timestep. ">solve()</a> is called, and false thereafter.  <a href="#ad5be0a1a2852028cc39b995b0d07bef6">更多...</a><br/></td></tr>
<tr class="separator:ad5be0a1a2852028cc39b995b0d07bef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437131696784e0e31a35315e3387c7b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#a437131696784e0e31a35315e3387c7b5">first_adjoint_step</a></td></tr>
<tr class="memdesc:a437131696784e0e31a35315e3387c7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bool that will be true the first time <a class="el" href="classlibMesh_1_1UnsteadySolver.html#a18254c1c7119b509057383f084c906f2" title="This method advances the adjoint solution to the previous timestep, after an adjoint_solve() has been...">adjoint_advance_timestep()</a> is called, (when the primal solution is to be used to set adjoint boundary conditions) and false thereafter.  <a href="#a437131696784e0e31a35315e3387c7b5">更多...</a><br/></td></tr>
<tr class="separator:a437131696784e0e31a35315e3387c7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001031a19a5f3ed4df851dc7b2ddbe1a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#a001031a19a5f3ed4df851dc7b2ddbe1a">old_adjoints</a></td></tr>
<tr class="memdesc:a001031a19a5f3ed4df851dc7b2ddbe1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of pointers to vectors holding the adjoint solution at the last time step.  <a href="#a001031a19a5f3ed4df851dc7b2ddbe1a">更多...</a><br/></td></tr>
<tr class="separator:a001031a19a5f3ed4df851dc7b2ddbe1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d9abb032bfe813f79db0c44d3cf40e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#af7d9abb032bfe813f79db0c44d3cf40e">last_step_deltat</a></td></tr>
<tr class="memdesc:af7d9abb032bfe813f79db0c44d3cf40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">We will need to move the system.time around to ensure that residuals are built with the right deltat and the right time.  <a href="#af7d9abb032bfe813f79db0c44d3cf40e">更多...</a><br/></td></tr>
<tr class="separator:af7d9abb032bfe813f79db0c44d3cf40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6c4c3cc9a4f677605bf74593a27509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1UnsteadySolver.html#a1c6c4c3cc9a4f677605bf74593a27509">next_step_deltat</a></td></tr>
<tr class="separator:a1c6c4c3cc9a4f677605bf74593a27509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cec9fe947573d455870bef253903946"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1DiffSolver.html">DiffSolver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#a5cec9fe947573d455870bef253903946">_diff_solver</a></td></tr>
<tr class="memdesc:a5cec9fe947573d455870bef253903946"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implicit linear or nonlinear solver to use at each timestep.  <a href="#a5cec9fe947573d455870bef253903946">更多...</a><br/></td></tr>
<tr class="separator:a5cec9fe947573d455870bef253903946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e03ec65a4db32fa56daec851c5d73ee"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1LinearSolver.html">LinearSolver</a><br class="typebreak"/>
&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#a9e03ec65a4db32fa56daec851c5d73ee">_linear_solver</a></td></tr>
<tr class="memdesc:a9e03ec65a4db32fa56daec851c5d73ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implicit linear solver to use for adjoint problems.  <a href="#a9e03ec65a4db32fa56daec851c5d73ee">更多...</a><br/></td></tr>
<tr class="separator:a9e03ec65a4db32fa56daec851c5d73ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf14c8b81127d014c49c45d88dfaf46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1TimeSolver.html#a4e7363e989661b62466ed602c1189f5a">sys_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a></td></tr>
<tr class="memdesc:a0cf14c8b81127d014c49c45d88dfaf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to the system we are solving.  <a href="#a0cf14c8b81127d014c49c45d88dfaf46">更多...</a><br/></td></tr>
<tr class="separator:a0cf14c8b81127d014c49c45d88dfaf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e23d6b0c8a4844fef98915a28c52d0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1SolutionHistory.html">SolutionHistory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#ad7e23d6b0c8a4844fef98915a28c52d0">solution_history</a></td></tr>
<tr class="memdesc:ad7e23d6b0c8a4844fef98915a28c52d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::unique_ptr to a <a class="el" href="classlibMesh_1_1SolutionHistory.html" title="A SolutionHistory class that enables the storage and retrieval of timesteps and (in the future) adapt...">SolutionHistory</a> object.  <a href="#ad7e23d6b0c8a4844fef98915a28c52d0">更多...</a><br/></td></tr>
<tr class="separator:ad7e23d6b0c8a4844fef98915a28c52d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b025ebd4bdaaf60b3f2bcef91408a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1TimeSolver.html#a80b025ebd4bdaaf60b3f2bcef91408a1">last_deltat</a></td></tr>
<tr class="memdesc:a80b025ebd4bdaaf60b3f2bcef91408a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The deltat for the last completed timestep before the current one.  <a href="#a80b025ebd4bdaaf60b3f2bcef91408a1">更多...</a><br/></td></tr>
<tr class="separator:a80b025ebd4bdaaf60b3f2bcef91408a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
静态 Protected 属性</h2></td></tr>
<tr class="memitem:a7c913252d05560f8bc7c75a63547c4c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlibMesh_1_1ReferenceCounter.html#adb5daadc989c1fe71ec8d173adf0ed1e">Counts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">_counts</a></td></tr>
<tr class="memdesc:a7c913252d05560f8bc7c75a63547c4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually holds the data.  <a href="#a7c913252d05560f8bc7c75a63547c4c3">更多...</a><br/></td></tr>
<tr class="separator:a7c913252d05560f8bc7c75a63547c4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c30f0f71dcd00f00faa8e46aa3e043"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlibMesh_1_1Threads_1_1atomic.html">Threads::atomic</a><br class="typebreak"/>
&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#ad2c30f0f71dcd00f00faa8e46aa3e043">_n_objects</a></td></tr>
<tr class="memdesc:ad2c30f0f71dcd00f00faa8e46aa3e043"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of objects.  <a href="#ad2c30f0f71dcd00f00faa8e46aa3e043">更多...</a><br/></td></tr>
<tr class="separator:ad2c30f0f71dcd00f00faa8e46aa3e043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedbd3a4ce19686187449a8a0557b74b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlibMesh_1_1Threads_1_1spin__mutex.html">Threads::spin_mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#abedbd3a4ce19686187449a8a0557b74b">_mutex</a></td></tr>
<tr class="memdesc:abedbd3a4ce19686187449a8a0557b74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutual exclusion object to enable thread-safe reference counting.  <a href="#abedbd3a4ce19686187449a8a0557b74b">更多...</a><br/></td></tr>
<tr class="separator:abedbd3a4ce19686187449a8a0557b74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f75e8a4a280f2c41636f2ae1307a311"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">_enable_print_counter</a> = true</td></tr>
<tr class="memdesc:a8f75e8a4a280f2c41636f2ae1307a311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to control whether reference count information is printed when print_info is called.  <a href="#a8f75e8a4a280f2c41636f2ae1307a311">更多...</a><br/></td></tr>
<tr class="separator:a8f75e8a4a280f2c41636f2ae1307a311"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>This class wraps another <a class="el" href="classlibMesh_1_1UnsteadySolver.html" title="This is a generic class that defines a solver to handle time integration of DifferentiableSystems. ">UnsteadySolver</a> derived class, and compares the results of timestepping with deltat and timestepping with 2*deltat to adjust future timestep lengths. </p>
<p>Currently this class only works on fully coupled Systems</p>
<p>This class is part of the new <a class="el" href="classlibMesh_1_1DifferentiableSystem.html" title="该类提供了一个特定的系统类。它旨在泛化任何系统，线性或非线性，提供残差和雅可比矩阵。 ">DifferentiableSystem</a> framework, which is still experimental. Users of this framework should beware of bugs and future API changes.</p>
<dl class="section author"><dt>作者</dt><dd>Roy H. Stogner </dd></dl>
<dl class="section date"><dt>日期</dt><dd>2007 </dd></dl>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00049">49</a> 行定义.</p>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a class="anchor" id="adb5daadc989c1fe71ec8d173adf0ed1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, std::pair&lt;unsigned int, unsigned int&gt; &gt; <a class="el" href="classlibMesh_1_1ReferenceCounter.html#adb5daadc989c1fe71ec8d173adf0ed1e">libMesh::ReferenceCounter::Counts</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data structure to log the information. </p>
<p>The log is identified by the class name. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00119">119</a> 行定义.</p>

</div>
</div>
<a class="anchor" id="ace5314b1c800e607e8b51f1953450a7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classlibMesh_1_1FirstOrderUnsteadySolver.html">FirstOrderUnsteadySolver</a> <a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#ace5314b1c800e607e8b51f1953450a7a">libMesh::AdaptiveTimeSolver::Parent</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The parent class. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00055">55</a> 行定义.</p>

</div>
</div>
<a class="anchor" id="aede0ea91f377e087b0f3a5d8f12a0643"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(DiffContext::* libMesh::TimeSolver::ReinitFuncType)(<a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00327">327</a> 行定义.</p>

</div>
</div>
<a class="anchor" id="a2bef2e6f4f3010907ca9a6c9183d475a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(DifferentiablePhysics::* libMesh::TimeSolver::ResFuncType)(bool, <a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definitions of argument types for use in refactoring subclasses. </p>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00325">325</a> 行定义.</p>

</div>
</div>
<a class="anchor" id="a4e7363e989661b62466ed602c1189f5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classlibMesh_1_1DifferentiableSystem.html">DifferentiableSystem</a> <a class="el" href="classlibMesh_1_1TimeSolver.html#a4e7363e989661b62466ed602c1189f5a">libMesh::TimeSolver::sys_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of system. </p>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00069">69</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a class="anchor" id="ac9d39e0aca9faaa22f2afc948645b93a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::AdaptiveTimeSolver::AdaptiveTimeSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1TimeSolver.html#a4e7363e989661b62466ed602c1189f5a">sys_type</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Requires a reference to the system to be solved. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00033">33</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  : <a class="code" href="classlibMesh_1_1FirstOrderUnsteadySolver.html#ab4562016c5b4cbbe8643c98eed542973">FirstOrderUnsteadySolver</a>(s),</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>(),</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#aca9e4ce98150b7452299c990c6d13741">target_tolerance</a>(1.e-3),</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a4d15b5d216cbb6657055125da543c388">upper_tolerance</a>(0.0),</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a93b378583a8e5d6da9d1408a49b8a0a9">max_deltat</a>(0.),</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a3ef4f9c102adce5c8ef9cacab1b8cd7c">min_deltat</a>(0.),</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#ada68f2f70960a70215aa8978105d9df2">max_growth</a>(0.),</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a3688a87be263c45e7db268869a54e1e4">completed_timestep_size</a>(s.deltat),</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#accf5c408d7a99cb7d27a819404b85ea3">global_tolerance</a>(<span class="keyword">true</span>)</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;{</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  <span class="comment">// the child class must populate core_time_solver</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  <span class="comment">// with whatever actual time solver is to be used</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a3688a87be263c45e7db268869a54e1e4"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a3688a87be263c45e7db268869a54e1e4">libMesh::AdaptiveTimeSolver::completed_timestep_size</a></div><div class="ttdeci">Real completed_timestep_size</div><div class="ttdoc">The adaptive time solver&amp;#39;s have two notions of deltat. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00205">adaptive_time_solver.h:205</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_aca9e4ce98150b7452299c990c6d13741"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#aca9e4ce98150b7452299c990c6d13741">libMesh::AdaptiveTimeSolver::target_tolerance</a></div><div class="ttdeci">Real target_tolerance</div><div class="ttdoc">This tolerance is the target relative error between an exact time integration and a single time step ...</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00160">adaptive_time_solver.h:160</a></div></div>
<div class="ttc" id="classlibMesh_1_1FirstOrderUnsteadySolver_html_ab4562016c5b4cbbe8643c98eed542973"><div class="ttname"><a href="classlibMesh_1_1FirstOrderUnsteadySolver.html#ab4562016c5b4cbbe8643c98eed542973">libMesh::FirstOrderUnsteadySolver::FirstOrderUnsteadySolver</a></div><div class="ttdeci">FirstOrderUnsteadySolver(sys_type &amp;s)</div><div class="ttdoc">Constructor. </div><div class="ttdef"><b>Definition:</b> <a href="first__order__unsteady__solver_8h_source.html#l00082">first_order_unsteady_solver.h:82</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_accf5c408d7a99cb7d27a819404b85ea3"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#accf5c408d7a99cb7d27a819404b85ea3">libMesh::AdaptiveTimeSolver::global_tolerance</a></div><div class="ttdeci">bool global_tolerance</div><div class="ttdoc">This flag, which is true by default, grows (shrinks) the timestep based on the expected global accura...</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00222">adaptive_time_solver.h:222</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a93b378583a8e5d6da9d1408a49b8a0a9"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a93b378583a8e5d6da9d1408a49b8a0a9">libMesh::AdaptiveTimeSolver::max_deltat</a></div><div class="ttdeci">Real max_deltat</div><div class="ttdoc">Do not allow the adaptive time solver to select deltat &amp;gt; max_deltat. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00183">adaptive_time_solver.h:183</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a4d15b5d216cbb6657055125da543c388"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a4d15b5d216cbb6657055125da543c388">libMesh::AdaptiveTimeSolver::upper_tolerance</a></div><div class="ttdeci">Real upper_tolerance</div><div class="ttdoc">This tolerance is the maximum relative error between an exact time integration and a single time step...</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00177">adaptive_time_solver.h:177</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a3ef4f9c102adce5c8ef9cacab1b8cd7c"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a3ef4f9c102adce5c8ef9cacab1b8cd7c">libMesh::AdaptiveTimeSolver::min_deltat</a></div><div class="ttdeci">Real min_deltat</div><div class="ttdoc">Do not allow the adaptive time solver to select deltat &amp;lt; min_deltat. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00189">adaptive_time_solver.h:189</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_ada68f2f70960a70215aa8978105d9df2"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#ada68f2f70960a70215aa8978105d9df2">libMesh::AdaptiveTimeSolver::max_growth</a></div><div class="ttdeci">Real max_growth</div><div class="ttdoc">Do not allow the adaptive time solver to select a new deltat greater than max_growth times the old de...</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00197">adaptive_time_solver.h:197</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8c1c823f34455546af9f6cecaec91245"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::AdaptiveTimeSolver::~AdaptiveTimeSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a class="anchor" id="a0f0f733d6c8e54cb535fb88d3d5a4300"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::AdaptiveTimeSolver::adjoint_advance_timestep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method advances the adjoint solution to the previous timestep, after an <a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a53adbea7f55f2adc3aade0a2d6799a4c" title="This method solves for the adjoint solution at the next adjoint timestep (or a steady state adjoint s...">adjoint_solve()</a> has been performed. </p>
<p>This will be done before every <a class="el" href="classlibMesh_1_1UnsteadySolver.html#ad3f30ba7292ed67db6992a8cb716e218" title="This method solves for the adjoint solution at the next adjoint timestep (or a steady state adjoint s...">UnsteadySolver::adjoint_solve()</a>. </p>

<p>重载 <a class="el" href="classlibMesh_1_1UnsteadySolver.html#a18254c1c7119b509057383f084c906f2">libMesh::UnsteadySolver</a> .</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00126">126</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00312">libMesh::TimeSolver::_system</a>, <a class="el" href="adaptive__time__solver_8h_source.html#l00130">core_time_solver</a>, <a class="el" href="diff__system_8h_source.html#l00254">libMesh::DifferentiableSystem::deltat</a>, <a class="el" href="unsteady__solver_8h_source.html#l00226">libMesh::UnsteadySolver::first_adjoint_step</a>, <a class="el" href="system_8C_source.html#l01192">libMesh::System::get_adjoint_solution()</a>, <a class="el" href="system_8h_source.html#l02293">libMesh::System::get_dof_map()</a>, <a class="el" href="dof__map_8h_source.html#l00511">libMesh::DofMap::get_send_list()</a>, <a class="el" href="system_8C_source.html#l00917">libMesh::System::get_vector()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a7348b5b027adf716016354847e0df0b6">libMesh::NumericVector&lt; T &gt;::localize()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a>, <a class="el" href="system_8h_source.html#l02516">libMesh::System::n_qois()</a>, <a class="el" href="unsteady__solver_8h_source.html#l00178">libMesh::UnsteadySolver::old_local_nonlinear_solution</a> , 以及 <a class="el" href="system_8h_source.html#l01595">libMesh::System::time</a>.</p>
<div class="fragment"><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;{</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  <span class="comment">// Store the computed full step adjoint solution for future use (sub steps are handled internally by the core time solver)</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;get_solution_history().store(<span class="keyword">true</span>, <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a90b0537fa503134bfa91865a6995742e">time</a>);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="comment">// For the first adjoint step ensure that we use the last primal timestep.</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1UnsteadySolver.html#a437131696784e0e31a35315e3387c7b5">first_adjoint_step</a>)</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  {</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1DifferentiableSystem.html#a2b792f8f71393719e56312995d863b04">deltat</a> = <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(<a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>).time_solver-&gt;TimeSolver::last_completed_timestep_size();</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    <a class="code" href="classlibMesh_1_1UnsteadySolver.html#a437131696784e0e31a35315e3387c7b5">first_adjoint_step</a> = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  }</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  <span class="comment">// Before moving to the next time instant, copy over the current adjoint solutions into _old_adjoint_solutions</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  <span class="keywordflow">for</span>(<span class="keyword">auto</span> i : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(<a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a993ffd888b690f4af0e1dd5a3df49b3f">n_qois</a>()))</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  {</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;   std::string old_adjoint_solution_name = <span class="stringliteral">&quot;_old_adjoint_solution&quot;</span>;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;   old_adjoint_solution_name+= std::to_string(i);</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;   <a class="code" href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">NumericVector&lt;Number&gt;</a> &amp; old_adjoint_solution_i = <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a2398b253d3fd1ec124777c4cbb6ba6c0">get_vector</a>(old_adjoint_solution_name);</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;   <a class="code" href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">NumericVector&lt;Number&gt;</a> &amp; adjoint_solution_i = <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#aeaf02ff714b2d9b6aca4e8d696856529">get_adjoint_solution</a>(i);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;   old_adjoint_solution_i = adjoint_solution_i;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  }</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a90b0537fa503134bfa91865a6995742e">time</a> -= <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1DifferentiableSystem.html#a2b792f8f71393719e56312995d863b04">deltat</a>;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  <span class="comment">// For the adaptive time solver, all SH operations</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="comment">// are handled by the core_time_solver&#39;s SH object</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <span class="comment">// Retrieve the primal solution for the next adjoint calculation,</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  <span class="comment">// by using the core time solver&#39;s solution history object.</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;get_solution_history().retrieve(<span class="keyword">true</span>, <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a90b0537fa503134bfa91865a6995742e">time</a>);</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  <span class="comment">// We also need to tell the core time solver that the adjoint initial conditions have been set</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;set_first_adjoint_step(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  <span class="comment">// Dont forget to localize the old_nonlinear_solution !</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a2398b253d3fd1ec124777c4cbb6ba6c0">get_vector</a>(<span class="stringliteral">&quot;_old_nonlinear_solution&quot;</span>).<a class="code" href="classlibMesh_1_1NumericVector.html#a7348b5b027adf716016354847e0df0b6">localize</a></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    (*<a class="code" href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">old_local_nonlinear_solution</a>,</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a3b392c8791f781092d6326e51856f553">get_dof_map</a>().<a class="code" href="classlibMesh_1_1DofMap.html#a31c127241d3271719ede3d0a6902e9e4">get_send_list</a>());</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1System_html_a90b0537fa503134bfa91865a6995742e"><div class="ttname"><a href="classlibMesh_1_1System.html#a90b0537fa503134bfa91865a6995742e">libMesh::System::time</a></div><div class="ttdeci">Real time</div><div class="ttdoc">For time-dependent problems, this is the time t at the beginning of the current timestep. </div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l01595">system.h:1595</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a993ffd888b690f4af0e1dd5a3df49b3f"><div class="ttname"><a href="classlibMesh_1_1System.html#a993ffd888b690f4af0e1dd5a3df49b3f">libMesh::System::n_qois</a></div><div class="ttdeci">unsigned int n_qois() const </div><div class="ttdoc">Number of currently active quantities of interest. </div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l02516">system.h:2516</a></div></div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a0cf14c8b81127d014c49c45d88dfaf46"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">libMesh::TimeSolver::_system</a></div><div class="ttdeci">sys_type &amp; _system</div><div class="ttdoc">A reference to the system we are solving. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00312">time_solver.h:312</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a3b392c8791f781092d6326e51856f553"><div class="ttname"><a href="classlibMesh_1_1System.html#a3b392c8791f781092d6326e51856f553">libMesh::System::get_dof_map</a></div><div class="ttdeci">const DofMap &amp; get_dof_map() const </div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l02293">system.h:2293</a></div></div>
<div class="ttc" id="classlibMesh_1_1UnsteadySolver_html_aaa84acc193756038a9a9361d687f877e"><div class="ttname"><a href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">libMesh::UnsteadySolver::old_local_nonlinear_solution</a></div><div class="ttdeci">std::shared_ptr&lt; NumericVector&lt; Number &gt; &gt; old_local_nonlinear_solution</div><div class="ttdoc">Serial vector of _system.get_vector(&amp;quot;_old_nonlinear_solution&amp;quot;) This is a shared_ptr so that it can be...</div><div class="ttdef"><b>Definition:</b> <a href="unsteady__solver_8h_source.html#l00178">unsteady_solver.h:178</a></div></div>
<div class="ttc" id="classlibMesh_1_1DifferentiableSystem_html_a2b792f8f71393719e56312995d863b04"><div class="ttname"><a href="classlibMesh_1_1DifferentiableSystem.html#a2b792f8f71393719e56312995d863b04">libMesh::DifferentiableSystem::deltat</a></div><div class="ttdeci">Real deltat</div><div class="ttdoc">对于时变问题，这是将解决方案在时间上推进deltat的量。 </div><div class="ttdef"><b>Definition:</b> <a href="diff__system_8h_source.html#l00254">diff_system.h:254</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_aeaf02ff714b2d9b6aca4e8d696856529"><div class="ttname"><a href="classlibMesh_1_1System.html#aeaf02ff714b2d9b6aca4e8d696856529">libMesh::System::get_adjoint_solution</a></div><div class="ttdeci">NumericVector&lt; Number &gt; &amp; get_adjoint_solution(unsigned int i=0)</div><div class="ttdef"><b>Definition:</b> <a href="system_8C_source.html#l01192">system.C:1192</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a2398b253d3fd1ec124777c4cbb6ba6c0"><div class="ttname"><a href="classlibMesh_1_1System.html#a2398b253d3fd1ec124777c4cbb6ba6c0">libMesh::System::get_vector</a></div><div class="ttdeci">const NumericVector&lt; Number &gt; &amp; get_vector(std::string_view vec_name) const </div><div class="ttdef"><b>Definition:</b> <a href="system_8C_source.html#l00917">system.C:917</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofMap_html_a31c127241d3271719ede3d0a6902e9e4"><div class="ttname"><a href="classlibMesh_1_1DofMap.html#a31c127241d3271719ede3d0a6902e9e4">libMesh::DofMap::get_send_list</a></div><div class="ttdeci">const std::vector&lt; dof_id_type &gt; &amp; get_send_list() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__map_8h_source.html#l00511">dof_map.h:511</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af63481288585b5ba172278c33c726667"><div class="ttname"><a href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">libMesh::NumericVector&lt; Number &gt;</a></div><div class="ttdeci">template class LIBMESH_EXPORT NumericVector&lt; Number &gt;</div><div class="ttdef"><b>Definition:</b> <a href="numeric__vector_8C_source.html#l00436">numeric_vector.C:436</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
<div class="ttc" id="classlibMesh_1_1UnsteadySolver_html_a437131696784e0e31a35315e3387c7b5"><div class="ttname"><a href="classlibMesh_1_1UnsteadySolver.html#a437131696784e0e31a35315e3387c7b5">libMesh::UnsteadySolver::first_adjoint_step</a></div><div class="ttdeci">bool first_adjoint_step</div><div class="ttdoc">A bool that will be true the first time adjoint_advance_timestep() is called, (when the primal soluti...</div><div class="ttdef"><b>Definition:</b> <a href="unsteady__solver_8h_source.html#l00226">unsteady_solver.h:226</a></div></div>
<div class="ttc" id="classlibMesh_1_1NumericVector_html_a7348b5b027adf716016354847e0df0b6"><div class="ttname"><a href="classlibMesh_1_1NumericVector.html#a7348b5b027adf716016354847e0df0b6">libMesh::NumericVector::localize</a></div><div class="ttdeci">virtual void localize(std::vector&lt; T &gt; &amp;v_local) const =0</div><div class="ttdoc">创建全局向量的副本并存储在本地向量 v_local 中。 </div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a53adbea7f55f2adc3aade0a2d6799a4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;unsigned int, <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&gt; libMesh::AdaptiveTimeSolver::adjoint_solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> &amp;&#160;</td>
          <td class="paramname"><em>qoi_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method solves for the adjoint solution at the next adjoint timestep (or a steady state adjoint solve) </p>

<p>重载 <a class="el" href="classlibMesh_1_1UnsteadySolver.html#ad3f30ba7292ed67db6992a8cb716e218">libMesh::UnsteadySolver</a> .</p>

<p>在 <a class="el" href="classlibMesh_1_1TwostepTimeSolver.html#a84de3cd87bdfeaf3e9f89043f192c2a9">libMesh::TwostepTimeSolver</a> 内被实现.</p>

</div>
</div>
<a class="anchor" id="a879ee9dc3c4324313f820b1a6302d95b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::AdaptiveTimeSolver::advance_timestep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method advances the solution to the next timestep, after a <a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a115b029ab169245296d22487b3d83c46" title="This method solves for the solution at the next timestep. ">solve()</a> has been performed. </p>
<p>Often this will be done after every <a class="el" href="classlibMesh_1_1UnsteadySolver.html#aad83b8429f49f336a0cbc1e044c7ab83" title="This method solves for the solution at the next timestep. ">UnsteadySolver::solve()</a>, but adaptive mesh refinement and/or adaptive time step selection may require some <a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html#a115b029ab169245296d22487b3d83c46" title="This method solves for the solution at the next timestep. ">solve()</a> steps to be repeated. </p>

<p>重载 <a class="el" href="classlibMesh_1_1UnsteadySolver.html#a9425624ccf6aafbdbbe4392d71bcec4b">libMesh::UnsteadySolver</a> .</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00089">89</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00312">libMesh::TimeSolver::_system</a>, <a class="el" href="adaptive__time__solver_8h_source.html#l00205">completed_timestep_size</a>, <a class="el" href="adaptive__time__solver_8h_source.html#l00130">core_time_solver</a>, <a class="el" href="unsteady__solver_8h_source.html#l00220">libMesh::UnsteadySolver::first_solve</a>, <a class="el" href="system_8h_source.html#l02293">libMesh::System::get_dof_map()</a>, <a class="el" href="dof__map_8h_source.html#l00511">libMesh::DofMap::get_send_list()</a>, <a class="el" href="system_8C_source.html#l00917">libMesh::System::get_vector()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a7348b5b027adf716016354847e0df0b6">libMesh::NumericVector&lt; T &gt;::localize()</a>, <a class="el" href="unsteady__solver_8h_source.html#l00178">libMesh::UnsteadySolver::old_local_nonlinear_solution</a>, <a class="el" href="system_8h_source.html#l01573">libMesh::System::solution</a> , 以及 <a class="el" href="system_8h_source.html#l01595">libMesh::System::time</a>.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a>.</p>
<div class="fragment"><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;{</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <span class="comment">// The first access of advance_timestep happens via solve, not user code</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <span class="comment">// It is used here to store any initial conditions data</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="classlibMesh_1_1UnsteadySolver.html#ad5be0a1a2852028cc39b995b0d07bef6">first_solve</a>)</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a90b0537fa503134bfa91865a6995742e">time</a> += this-&gt;<a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a3688a87be263c45e7db268869a54e1e4">completed_timestep_size</a>;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    }</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="comment">// We are here because of a call to advance_timestep that happens</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="comment">// via solve, the very first solve. All we are doing here is storing</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="comment">// the initial condition. The actual solution computed via this solve</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="comment">// will be stored when we call advance_timestep in the user&#39;s timestep loop</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <a class="code" href="classlibMesh_1_1UnsteadySolver.html#ad5be0a1a2852028cc39b995b0d07bef6">first_solve</a> = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;set_first_solve(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="comment">// For the adaptive time solver, all SH operations</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  <span class="comment">// are handled by the core_time_solver&#39;s SH object</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  <span class="comment">// Sub solution storage is handled internally by the core time solver,</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  <span class="comment">// but the &#39;full step&#39; solution is stored here to maintain consistency</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  <span class="comment">// with the fixed timestep scheme.</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;get_solution_history().store(<span class="keyword">false</span>, <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a90b0537fa503134bfa91865a6995742e">time</a>);</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <a class="code" href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">NumericVector&lt;Number&gt;</a> &amp; old_nonlinear_soln =</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a2398b253d3fd1ec124777c4cbb6ba6c0">get_vector</a>(<span class="stringliteral">&quot;_old_nonlinear_solution&quot;</span>);</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <a class="code" href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">NumericVector&lt;Number&gt;</a> &amp; nonlinear_solution =</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    *(<a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#aa07e1093c49fa5f0877488d3351f4c86">solution</a>);</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  old_nonlinear_soln = nonlinear_solution;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  old_nonlinear_soln.localize</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    (*<a class="code" href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">old_local_nonlinear_solution</a>,</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;     <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a3b392c8791f781092d6326e51856f553">get_dof_map</a>().<a class="code" href="classlibMesh_1_1DofMap.html#a31c127241d3271719ede3d0a6902e9e4">get_send_list</a>());</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1System_html_a90b0537fa503134bfa91865a6995742e"><div class="ttname"><a href="classlibMesh_1_1System.html#a90b0537fa503134bfa91865a6995742e">libMesh::System::time</a></div><div class="ttdeci">Real time</div><div class="ttdoc">For time-dependent problems, this is the time t at the beginning of the current timestep. </div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l01595">system.h:1595</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a3688a87be263c45e7db268869a54e1e4"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a3688a87be263c45e7db268869a54e1e4">libMesh::AdaptiveTimeSolver::completed_timestep_size</a></div><div class="ttdeci">Real completed_timestep_size</div><div class="ttdoc">The adaptive time solver&amp;#39;s have two notions of deltat. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00205">adaptive_time_solver.h:205</a></div></div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a0cf14c8b81127d014c49c45d88dfaf46"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">libMesh::TimeSolver::_system</a></div><div class="ttdeci">sys_type &amp; _system</div><div class="ttdoc">A reference to the system we are solving. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00312">time_solver.h:312</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a3b392c8791f781092d6326e51856f553"><div class="ttname"><a href="classlibMesh_1_1System.html#a3b392c8791f781092d6326e51856f553">libMesh::System::get_dof_map</a></div><div class="ttdeci">const DofMap &amp; get_dof_map() const </div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l02293">system.h:2293</a></div></div>
<div class="ttc" id="classlibMesh_1_1UnsteadySolver_html_aaa84acc193756038a9a9361d687f877e"><div class="ttname"><a href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">libMesh::UnsteadySolver::old_local_nonlinear_solution</a></div><div class="ttdeci">std::shared_ptr&lt; NumericVector&lt; Number &gt; &gt; old_local_nonlinear_solution</div><div class="ttdoc">Serial vector of _system.get_vector(&amp;quot;_old_nonlinear_solution&amp;quot;) This is a shared_ptr so that it can be...</div><div class="ttdef"><b>Definition:</b> <a href="unsteady__solver_8h_source.html#l00178">unsteady_solver.h:178</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_aa07e1093c49fa5f0877488d3351f4c86"><div class="ttname"><a href="classlibMesh_1_1System.html#aa07e1093c49fa5f0877488d3351f4c86">libMesh::System::solution</a></div><div class="ttdeci">std::unique_ptr&lt; NumericVector&lt; Number &gt; &gt; solution</div><div class="ttdoc">Data structure to hold solution values. </div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l01573">system.h:1573</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a2398b253d3fd1ec124777c4cbb6ba6c0"><div class="ttname"><a href="classlibMesh_1_1System.html#a2398b253d3fd1ec124777c4cbb6ba6c0">libMesh::System::get_vector</a></div><div class="ttdeci">const NumericVector&lt; Number &gt; &amp; get_vector(std::string_view vec_name) const </div><div class="ttdef"><b>Definition:</b> <a href="system_8C_source.html#l00917">system.C:917</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofMap_html_a31c127241d3271719ede3d0a6902e9e4"><div class="ttname"><a href="classlibMesh_1_1DofMap.html#a31c127241d3271719ede3d0a6902e9e4">libMesh::DofMap::get_send_list</a></div><div class="ttdeci">const std::vector&lt; dof_id_type &gt; &amp; get_send_list() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__map_8h_source.html#l00511">dof_map.h:511</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af63481288585b5ba172278c33c726667"><div class="ttname"><a href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">libMesh::NumericVector&lt; Number &gt;</a></div><div class="ttdeci">template class LIBMESH_EXPORT NumericVector&lt; Number &gt;</div><div class="ttdef"><b>Definition:</b> <a href="numeric__vector_8C_source.html#l00436">numeric_vector.C:436</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
<div class="ttc" id="classlibMesh_1_1UnsteadySolver_html_ad5be0a1a2852028cc39b995b0d07bef6"><div class="ttname"><a href="classlibMesh_1_1UnsteadySolver.html#ad5be0a1a2852028cc39b995b0d07bef6">libMesh::UnsteadySolver::first_solve</a></div><div class="ttdeci">bool first_solve</div><div class="ttdoc">A bool that will be true the first time solve() is called, and false thereafter. </div><div class="ttdef"><b>Definition:</b> <a href="unsteady__solver_8h_source.html#l00220">unsteady_solver.h:220</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab8c634934e73a55d1cb397bbdb745904"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::TimeSolver::before_timestep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is for subclasses or users to override to do arbitrary processing between timesteps. </p>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00205">205</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;{}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a24cf02c068643d8cd3e4c25d96895a8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::AdaptiveTimeSolver::calculate_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1System.html">System</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function to calculate error norms. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00225">225</a> 行定义.</p>

<p>参考 <a class="el" href="system_8C_source.html#l01671">libMesh::System::calculate_norm()</a> , 以及 <a class="el" href="adaptive__time__solver_8h_source.html#l00135">component_norm</a>.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a>.</p>
<div class="fragment"><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;{</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  <span class="keywordflow">return</span> s.calculate_norm(v, <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a59a933b429ce060d4c14002db6245136">component_norm</a>);</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a59a933b429ce060d4c14002db6245136"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a59a933b429ce060d4c14002db6245136">libMesh::AdaptiveTimeSolver::component_norm</a></div><div class="ttdeci">SystemNorm component_norm</div><div class="ttdoc">Error calculations are done in this norm, DISCRETE_L2 by default. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00135">adaptive_time_solver.h:135</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0804044301e3a7fc7ff88aa8e20cadd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::FirstOrderUnsteadySolver::compute_second_order_eqns </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If there are second order variables, then we need to compute their residual equations and corresponding Jacobian. </p>
<p>The residual equation will simply be <img class="formulaInl" alt="$ \dot{u} - v = 0 $" src="form_148.png"/>, where <img class="formulaInl" alt="$ u $" src="form_149.png"/> is the second order variable add by the user and <img class="formulaInl" alt="$ v $" src="form_150.png"/> is the variable added by the time-solver as the "velocity" variable. </p>

<p>在文件 <a class="el" href="first__order__unsteady__solver_8C_source.html">first_order_unsteady_solver.C</a> 第 <a class="el" href="first__order__unsteady__solver_8C_source.html#l00032">32</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00312">libMesh::TimeSolver::_system</a>, <a class="el" href="diff__context_8h_source.html#l00336">libMesh::DiffContext::get_dof_indices()</a>, <a class="el" href="diff__context_8h_source.html#l00252">libMesh::DiffContext::get_elem_jacobian()</a>, <a class="el" href="diff__context_8h_source.html#l00222">libMesh::DiffContext::get_elem_residual()</a>, <a class="el" href="diff__context_8h_source.html#l00400">libMesh::DiffContext::get_elem_solution_derivative()</a>, <a class="el" href="diff__context_8h_source.html#l00407">libMesh::DiffContext::get_elem_solution_rate_derivative()</a>, <a class="el" href="fem__context_8h_source.html#l00277">libMesh::FEMContext::get_element_fe()</a>, <a class="el" href="fem__context_8h_source.html#l00802">libMesh::FEMContext::get_element_qrule()</a>, <a class="el" href="diff__system_8C_source.html#l00306">libMesh::DifferentiableSystem::get_second_order_dot_var()</a>, <a class="el" href="diff__context_8h_source.html#l00096">libMesh::DiffContext::get_system()</a>, <a class="el" href="fem__context_8C_source.html#l01351">libMesh::FEMContext::interior_rate()</a>, <a class="el" href="fem__context_8C_source.html#l00404">libMesh::FEMContext::interior_value()</a>, <a class="el" href="diff__physics_8h_source.html#l00522">libMesh::DifferentiablePhysics::is_second_order_var()</a>, <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a>, <a class="el" href="quadrature_8h_source.html#l00123">libMesh::QBase::n_points()</a>, <a class="el" href="diff__context_8h_source.html#l00090">libMesh::DiffContext::n_vars()</a>, <a class="el" href="variable_8h_source.html#l00140">libMesh::Variable::type()</a> , 以及 <a class="el" href="system_8h_source.html#l02377">libMesh::System::variable()</a>.</p>

<p>参考自 <a class="el" href="euler__solver_8C_source.html#l00102">libMesh::EulerSolver::_general_residual()</a>, <a class="el" href="euler2__solver_8C_source.html#l00103">libMesh::Euler2Solver::_general_residual()</a>, <a class="el" href="euler__solver_8C_source.html#l00053">libMesh::EulerSolver::element_residual()</a>, <a class="el" href="euler2__solver_8C_source.html#l00054">libMesh::Euler2Solver::element_residual()</a>, <a class="el" href="euler__solver_8C_source.html#l00085">libMesh::EulerSolver::nonlocal_residual()</a> , 以及 <a class="el" href="euler2__solver_8C_source.html#l00086">libMesh::Euler2Solver::nonlocal_residual()</a>.</p>
<div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  FEMContext &amp; context = cast_ref&lt;FEMContext &amp;&gt;(c);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_qpoints = context.get_element_qrule().n_points();</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> var : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(context.n_vars()))</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    {</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;      <span class="keywordflow">if</span> (!this-&gt;<a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1DifferentiablePhysics.html#aadcb53357db196860e5bc0b762555c2b">is_second_order_var</a>(var))</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dot_var = this-&gt;<a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1DifferentiableSystem.html#a0ca2e533a7009a9c64425a61560aa085">get_second_order_dot_var</a>(var);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;      <span class="comment">// We&#39;re assuming that the FE space for var and dot_var are the same</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;      <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>( context.get_system().variable(var).type() ==</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                      context.get_system().variable(dot_var).type() );</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;      <a class="code" href="namespacelibMesh.html#adf7aee34b8c6fe4be28c90fe132a73a0">FEBase</a> * elem_fe = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;      context.get_element_fe( var, elem_fe );</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      <span class="keyword">const</span> std::vector&lt;Real&gt; &amp; JxW = elem_fe-&gt;get_JxW();</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      <span class="keyword">const</span> std::vector&lt;std::vector&lt;Real&gt;&gt; &amp; phi = elem_fe-&gt;get_phi();</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs = cast_int&lt;unsigned int&gt;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        (context.get_dof_indices(dot_var).size());</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;      DenseSubVector&lt;Number&gt; &amp; Fu = context.get_elem_residual(var);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;      DenseSubMatrix&lt;Number&gt; &amp; Kuu = context.get_elem_jacobian( var, var );</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;      DenseSubMatrix&lt;Number&gt; &amp; Kuv = context.get_elem_jacobian( var, dot_var );</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qp = 0; qp != n_qpoints; ++qp)</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;          <a class="code" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> udot, v;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;          context.interior_rate(var, qp, udot);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;          context.interior_value(dot_var, qp, v);</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; i++)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;              Fu(i) += JxW[qp]*(udot-v)*phi[i][qp];</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;              <span class="keywordflow">if</span> (compute_jacobian)</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                  <a class="code" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> rate_factor = JxW[qp]*context.get_elem_solution_rate_derivative()*phi[i][qp];</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                  <a class="code" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> soln_factor = JxW[qp]*context.get_elem_solution_derivative()*phi[i][qp];</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                  Kuu(i,i) += rate_factor*phi[i][qp];</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                  Kuv(i,i) -= soln_factor*phi[i][qp];</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i+1; j &lt; n_dofs; j++)</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                    {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                      Kuu(i,j) += rate_factor*phi[j][qp];</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                      Kuu(j,i) += rate_factor*phi[j][qp];</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                      Kuv(i,j) -= soln_factor*phi[j][qp];</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                      Kuv(j,i) -= soln_factor*phi[j][qp];</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                    }</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                }</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            }</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        }</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    }</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="keywordflow">return</span> compute_jacobian;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1DifferentiableSystem_html_a0ca2e533a7009a9c64425a61560aa085"><div class="ttname"><a href="classlibMesh_1_1DifferentiableSystem.html#a0ca2e533a7009a9c64425a61560aa085">libMesh::DifferentiableSystem::get_second_order_dot_var</a></div><div class="ttdeci">unsigned int get_second_order_dot_var(unsigned int var) const </div><div class="ttdoc">对于给定的时间变量var的二阶（在时间上）变量，此方法将返回对应的“dot”变量的索引。 对于FirstOrderUnsteadySolver类，将自动添加“dot”变量，并且返回的索引将对应于该变量。...</div><div class="ttdef"><b>Definition:</b> <a href="diff__system_8C_source.html#l00306">diff_system.C:306</a></div></div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a0cf14c8b81127d014c49c45d88dfaf46"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">libMesh::TimeSolver::_system</a></div><div class="ttdeci">sys_type &amp; _system</div><div class="ttdoc">A reference to the system we are solving. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00312">time_solver.h:312</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="namespacelibMesh_html_adf7aee34b8c6fe4be28c90fe132a73a0"><div class="ttname"><a href="namespacelibMesh.html#adf7aee34b8c6fe4be28c90fe132a73a0">libMesh::FEBase</a></div><div class="ttdeci">FEGenericBase&lt; Real &gt; FEBase</div><div class="ttdef"><b>Definition:</b> <a href="exact__error__estimator_8h_source.html#l00039">exact_error_estimator.h:39</a></div></div>
<div class="ttc" id="classlibMesh_1_1DifferentiablePhysics_html_aadcb53357db196860e5bc0b762555c2b"><div class="ttname"><a href="classlibMesh_1_1DifferentiablePhysics.html#aadcb53357db196860e5bc0b762555c2b">libMesh::DifferentiablePhysics::is_second_order_var</a></div><div class="ttdeci">bool is_second_order_var(unsigned int var) const </div><div class="ttdef"><b>Definition:</b> <a href="diff__physics_8h_source.html#l00522">diff_physics.h:522</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a8b17bf24a15bc292850c3a3894e2e8f9"><div class="ttname"><a href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">libMesh::Number</a></div><div class="ttdeci">Real Number</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00214">libmesh_common.h:214</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa24466af444ea6d56e98407c155a42ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1DiffSolver.html">DiffSolver</a> &gt; &amp; libMesh::AdaptiveTimeSolver::diff_solver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An implicit linear or nonlinear solver to use at each timestep. </p>

<p>重载 <a class="el" href="classlibMesh_1_1TimeSolver.html#ae9caa0cd069f90cd21a834346712c7d1">libMesh::TimeSolver</a> .</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00211">211</a> 行定义.</p>

<p>参考 <a class="el" href="adaptive__time__solver_8h_source.html#l00130">core_time_solver</a>.</p>
<div class="fragment"><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;{</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;diff_solver();</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5c0a2d3d3c531f9f069b0d623d4ace0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ReferenceCounter::disable_print_counter_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="reference__counter_8C_source.html">reference_counter.C</a> 第 <a class="el" href="reference__counter_8C_source.html#l00100">100</a> 行定义.</p>

<p>参考 <a class="el" href="reference__counter_8h_source.html#l00143">libMesh::ReferenceCounter::_enable_print_counter</a>.</p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;{</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">_enable_print_counter</a> = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a8f75e8a4a280f2c41636f2ae1307a311"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">libMesh::ReferenceCounter::_enable_print_counter</a></div><div class="ttdeci">static bool _enable_print_counter</div><div class="ttdoc">Flag to control whether reference count information is printed when print_info is called...</div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00143">reference_counter.h:143</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a066acfcd6a68ce24f01fe145ff64b90b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::UnsteadySolver::du </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the size of ||u^{n+1} - u^{n}|| in some norm. </p>
<dl class="section note"><dt>注解</dt><dd>While you can always call this function, its result may or may not be very meaningful. For example, if you call this function right after calling <a class="el" href="classlibMesh_1_1UnsteadySolver.html#a9425624ccf6aafbdbbe4392d71bcec4b" title="This method advances the solution to the next timestep, after a solve() has been performed. ">advance_timestep()</a> then you'll get a result of zero since old_nonlinear_solution is set equal to nonlinear_solution in this function. </dd></dl>

<p>实现了 <a class="el" href="classlibMesh_1_1TimeSolver.html#ad9f91c868ac40017ed2e1a74cf8e511a">libMesh::TimeSolver</a>.</p>

<p>在文件 <a class="el" href="unsteady__solver_8C_source.html">unsteady_solver.C</a> 第 <a class="el" href="unsteady__solver_8C_source.html#l00348">348</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00312">libMesh::TimeSolver::_system</a>, <a class="el" href="system_8C_source.html#l01671">libMesh::System::calculate_norm()</a>, <a class="el" href="system_8C_source.html#l00917">libMesh::System::get_vector()</a> , 以及 <a class="el" href="system_8h_source.html#l01573">libMesh::System::solution</a>.</p>
<div class="fragment"><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;{</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;  std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt; solution_copy =</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#aa07e1093c49fa5f0877488d3351f4c86">solution</a>-&gt;clone();</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  solution_copy-&gt;add(-1., <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a2398b253d3fd1ec124777c4cbb6ba6c0">get_vector</a>(<span class="stringliteral">&quot;_old_nonlinear_solution&quot;</span>));</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  solution_copy-&gt;close();</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a2058825c4de9fba1da920a4247c60d3a">calculate_norm</a>(*solution_copy, <a class="code" href="namespacestd.html#a6e740e64c53e9ae1489f7eee3899c10f">norm</a>);</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a0cf14c8b81127d014c49c45d88dfaf46"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">libMesh::TimeSolver::_system</a></div><div class="ttdeci">sys_type &amp; _system</div><div class="ttdoc">A reference to the system we are solving. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00312">time_solver.h:312</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_aa07e1093c49fa5f0877488d3351f4c86"><div class="ttname"><a href="classlibMesh_1_1System.html#aa07e1093c49fa5f0877488d3351f4c86">libMesh::System::solution</a></div><div class="ttdeci">std::unique_ptr&lt; NumericVector&lt; Number &gt; &gt; solution</div><div class="ttdoc">Data structure to hold solution values. </div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l01573">system.h:1573</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a2058825c4de9fba1da920a4247c60d3a"><div class="ttname"><a href="classlibMesh_1_1System.html#a2058825c4de9fba1da920a4247c60d3a">libMesh::System::calculate_norm</a></div><div class="ttdeci">Real calculate_norm(const NumericVector&lt; Number &gt; &amp;v, unsigned int var, FEMNormType norm_type, std::set&lt; unsigned int &gt; *skip_dimensions=nullptr) const </div><div class="ttdef"><b>Definition:</b> <a href="system_8C_source.html#l01671">system.C:1671</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a2398b253d3fd1ec124777c4cbb6ba6c0"><div class="ttname"><a href="classlibMesh_1_1System.html#a2398b253d3fd1ec124777c4cbb6ba6c0">libMesh::System::get_vector</a></div><div class="ttdeci">const NumericVector&lt; Number &gt; &amp; get_vector(std::string_view vec_name) const </div><div class="ttdef"><b>Definition:</b> <a href="system_8C_source.html#l00917">system.C:917</a></div></div>
<div class="ttc" id="namespacestd_html_a6e740e64c53e9ae1489f7eee3899c10f"><div class="ttname"><a href="namespacestd.html#a6e740e64c53e9ae1489f7eee3899c10f">std::norm</a></div><div class="ttdeci">ADRealEigenVector&lt; T, D, asd &gt; norm(const ADRealEigenVector&lt; T, D, asd &gt; &amp;)</div><div class="ttdoc">计算自动微分实数向量的范数。 </div><div class="ttdef"><b>Definition:</b> <a href="type__vector_8h_source.html#l00064">type_vector.h:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab73faaabfe147582753d984c86207fc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::AdaptiveTimeSolver::element_residual </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is passed on to the core_time_solver. </p>

<p>实现了 <a class="el" href="classlibMesh_1_1TimeSolver.html#ae93a1e73cc5e4bea79942c738d038dd5">libMesh::TimeSolver</a>.</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00181">181</a> 行定义.</p>

<p>参考 <a class="el" href="adaptive__time__solver_8h_source.html#l00130">core_time_solver</a> , 以及 <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>.</p>
<div class="fragment"><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;{</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(<a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>.get());</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;element_residual(request_jacobian, context);</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a86837c50216b2ddb800b3836d2a08c09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ReferenceCounter::enable_print_counter_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods to enable/disable the reference counter output from <a class="el" href="classlibMesh_1_1ReferenceCounter.html#a13ce734a14ffd1dbb6496dab702da8e1" title="Prints the reference information, by default to libMesh::out. ">print_info()</a> </p>

<p>在文件 <a class="el" href="reference__counter_8C_source.html">reference_counter.C</a> 第 <a class="el" href="reference__counter_8C_source.html#l00094">94</a> 行定义.</p>

<p>参考 <a class="el" href="reference__counter_8h_source.html#l00143">libMesh::ReferenceCounter::_enable_print_counter</a>.</p>
<div class="fragment"><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;{</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">_enable_print_counter</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a8f75e8a4a280f2c41636f2ae1307a311"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">libMesh::ReferenceCounter::_enable_print_counter</a></div><div class="ttdeci">static bool _enable_print_counter</div><div class="ttdoc">Flag to control whether reference count information is printed when print_info is called...</div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00143">reference_counter.h:143</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae41ef7eb1270e12967fc809f79d2e5cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::AdaptiveTimeSolver::error_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is passed on to the core_time_solver. </p>

<p>实现了 <a class="el" href="classlibMesh_1_1UnsteadySolver.html#a54a7e63ce7ae0e82f983886661ccecbf">libMesh::UnsteadySolver</a>.</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00172">172</a> 行定义.</p>

<p>参考 <a class="el" href="adaptive__time__solver_8h_source.html#l00130">core_time_solver</a> , 以及 <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>.</p>
<div class="fragment"><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;{</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(<a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>.get());</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;error_order();</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a103b37125ae9eaaadf6f7854df17faa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string libMesh::ReferenceCounter::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a string containing the reference information. </p>

<p>在文件 <a class="el" href="reference__counter_8C_source.html">reference_counter.C</a> 第 <a class="el" href="reference__counter_8C_source.html#l00047">47</a> 行定义.</p>

<p>参考 <a class="el" href="reference__counter_8h_source.html#l00124">libMesh::ReferenceCounter::_counts</a> , 以及 <a class="el" href="elem__quality_8C_source.html#l00042">libMesh::Quality::name()</a>.</p>

<p>参考自 <a class="el" href="reference__counter_8C_source.html#l00081">libMesh::ReferenceCounter::print_info()</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;{</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="preprocessor">#if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) &amp;&amp; defined(DEBUG)</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  std::ostringstream oss;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  oss &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      &lt;&lt; <span class="stringliteral">&quot; ---------------------------------------------------------------------------- \n&quot;</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;| Reference count information                                                |\n&quot;</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;      &lt;&lt; <span class="stringliteral">&quot; ---------------------------------------------------------------------------- \n&quot;</span>;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; [<a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a>, cd] : <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">_counts</a>)</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    oss &lt;&lt; <span class="stringliteral">&quot;| &quot;</span> &lt;&lt; <a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a> &lt;&lt; <span class="stringliteral">&quot; reference count information:\n&quot;</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;|  Creations:    &quot;</span> &lt;&lt; cd.first    &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;|  Destructions: &quot;</span> &lt;&lt; cd.second &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  oss &lt;&lt; <span class="stringliteral">&quot; ---------------------------------------------------------------------------- \n&quot;</span>;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  <span class="keywordflow">return</span> oss.str();</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="preprocessor"></span>}</div>
<div class="ttc" id="namespacelibMesh_1_1Quality_html_a1d3617b89c15ade245910fc9a4ddfa34"><div class="ttname"><a href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">libMesh::Quality::name</a></div><div class="ttdeci">std::string name(const ElemQuality q)</div><div class="ttdoc">This function returns a string containing some name for q. </div><div class="ttdef"><b>Definition:</b> <a href="elem__quality_8C_source.html#l00042">elem_quality.C:42</a></div></div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a7c913252d05560f8bc7c75a63547c4c3"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">libMesh::ReferenceCounter::_counts</a></div><div class="ttdeci">static Counts _counts</div><div class="ttdoc">Actually holds the data. </div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00124">reference_counter.h:124</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a53943438a376aced23535cc111c3033c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1SolutionHistory.html">SolutionHistory</a> &amp; libMesh::TimeSolver::get_solution_history </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A getter function that returns a reference to the solution history object owned by <a class="el" href="classlibMesh_1_1TimeSolver.html" title="This is a generic class that defines a solver to handle time integration of DifferentiableSystems. ">TimeSolver</a>. </p>

<p>在文件 <a class="el" href="time__solver_8C_source.html">time_solver.C</a> 第 <a class="el" href="time__solver_8C_source.html#l00124">124</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00319">libMesh::TimeSolver::solution_history</a>.</p>

<p>参考自 <a class="el" href="adaptive__time__solver_8C_source.html#l00054">init()</a>.</p>
<div class="fragment"><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;{</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  <span class="keywordflow">return</span> *<a class="code" href="classlibMesh_1_1TimeSolver.html#ad7e23d6b0c8a4844fef98915a28c52d0">solution_history</a>;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_ad7e23d6b0c8a4844fef98915a28c52d0"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#ad7e23d6b0c8a4844fef98915a28c52d0">libMesh::TimeSolver::solution_history</a></div><div class="ttdeci">std::unique_ptr&lt; SolutionHistory &gt; solution_history</div><div class="ttdoc">A std::unique_ptr to a SolutionHistory object. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00319">time_solver.h:319</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af0cd2f1fbd46c66dade1e750436ee7ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ReferenceCounter::increment_constructor_count </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the construction counter. </p>
<p>Should be called in the constructor of any derived class that will be reference counted. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00183">183</a> 行定义.</p>

<p>参考 <a class="el" href="libmesh__common_8h_source.html#l00101">libMesh::err</a>, <a class="el" href="ostream__proxy_8h_source.html#l00217">libMesh::BasicOStreamProxy&lt; charT, traits &gt;::get()</a>, <a class="el" href="elem__quality_8C_source.html#l00042">libMesh::Quality::name()</a> , 以及 <a class="el" href="threads_8C_source.html#l00030">libMesh::Threads::spin_mtx</a>.</p>

<p>参考自 <a class="el" href="reference__counted__object_8h_source.html#l00074">libMesh::ReferenceCountedObject&lt; RBParametrized &gt;::ReferenceCountedObject()</a>.</p>
<div class="fragment"><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;{</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  libmesh_try</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  {</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    Threads::spin_mutex::scoped_lock lock(<a class="code" href="namespacelibMesh_1_1Threads.html#a29932e1987dacf7e89b1b27bb49bf0c9">Threads::spin_mtx</a>);</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    std::pair&lt;unsigned int, unsigned int&gt; &amp; p = <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">_counts</a>[<a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a>];</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    p.first++;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  }</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  libmesh_catch (...)</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <span class="keyword">auto</span> stream = <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a>.<a class="code" href="classlibMesh_1_1BasicOStreamProxy.html#ae2d18b50fc63d23e47d46fcee630b4f5">get</a>();</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    stream-&gt;exceptions(stream-&gt;goodbit); <span class="comment">// stream must not throw</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt; <span class="stringliteral">&quot;Encountered unrecoverable error while calling &quot;</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot;ReferenceCounter::increment_constructor_count() &quot;</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot;for a(n) &quot;</span> &lt;&lt; <a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a> &lt;&lt; <span class="stringliteral">&quot; object.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    std::terminate();</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  }</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_1_1Quality_html_a1d3617b89c15ade245910fc9a4ddfa34"><div class="ttname"><a href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">libMesh::Quality::name</a></div><div class="ttdeci">std::string name(const ElemQuality q)</div><div class="ttdoc">This function returns a string containing some name for q. </div><div class="ttdef"><b>Definition:</b> <a href="elem__quality_8C_source.html#l00042">elem_quality.C:42</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a74e5bc8a72d210b3d87b0221b1f69db1"><div class="ttname"><a href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a></div><div class="ttdeci">OStreamProxy err(std::cerr)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00101">libmesh_common.h:101</a></div></div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a7c913252d05560f8bc7c75a63547c4c3"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">libMesh::ReferenceCounter::_counts</a></div><div class="ttdeci">static Counts _counts</div><div class="ttdoc">Actually holds the data. </div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00124">reference_counter.h:124</a></div></div>
<div class="ttc" id="classlibMesh_1_1BasicOStreamProxy_html_ae2d18b50fc63d23e47d46fcee630b4f5"><div class="ttname"><a href="classlibMesh_1_1BasicOStreamProxy.html#ae2d18b50fc63d23e47d46fcee630b4f5">libMesh::BasicOStreamProxy::get</a></div><div class="ttdeci">streamT * get()</div><div class="ttdoc">Rather than implement every ostream/ios/ios_base function, we&amp;#39;ll be lazy and make esoteric uses go th...</div><div class="ttdef"><b>Definition:</b> <a href="ostream__proxy_8h_source.html#l00217">ostream_proxy.h:217</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Threads_html_a29932e1987dacf7e89b1b27bb49bf0c9"><div class="ttname"><a href="namespacelibMesh_1_1Threads.html#a29932e1987dacf7e89b1b27bb49bf0c9">libMesh::Threads::spin_mtx</a></div><div class="ttdeci">spin_mutex spin_mtx</div><div class="ttdoc">A convenient spin mutex object which can be used for obtaining locks. </div><div class="ttdef"><b>Definition:</b> <a href="threads_8C_source.html#l00030">threads.C:30</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a769ddb2e2299db1aafcdfb33dfb830d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ReferenceCounter::increment_destructor_count </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the destruction counter. </p>
<p>Should be called in the destructor of any derived class that will be reference counted. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00207">207</a> 行定义.</p>

<p>参考 <a class="el" href="libmesh__common_8h_source.html#l00101">libMesh::err</a>, <a class="el" href="ostream__proxy_8h_source.html#l00217">libMesh::BasicOStreamProxy&lt; charT, traits &gt;::get()</a>, <a class="el" href="elem__quality_8C_source.html#l00042">libMesh::Quality::name()</a> , 以及 <a class="el" href="threads_8C_source.html#l00030">libMesh::Threads::spin_mtx</a>.</p>

<p>参考自 <a class="el" href="reference__counted__object_8h_source.html#l00127">libMesh::ReferenceCountedObject&lt; RBParametrized &gt;::~ReferenceCountedObject()</a>.</p>
<div class="fragment"><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;{</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;  libmesh_try</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;  {</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    Threads::spin_mutex::scoped_lock lock(<a class="code" href="namespacelibMesh_1_1Threads.html#a29932e1987dacf7e89b1b27bb49bf0c9">Threads::spin_mtx</a>);</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    std::pair&lt;unsigned int, unsigned int&gt; &amp; p = <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">_counts</a>[<a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a>];</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    p.second++;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  }</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  libmesh_catch (...)</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  {</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="keyword">auto</span> stream = <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a>.<a class="code" href="classlibMesh_1_1BasicOStreamProxy.html#ae2d18b50fc63d23e47d46fcee630b4f5">get</a>();</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    stream-&gt;exceptions(stream-&gt;goodbit); <span class="comment">// stream must not throw</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt; <span class="stringliteral">&quot;Encountered unrecoverable error while calling &quot;</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot;ReferenceCounter::increment_destructor_count() &quot;</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot;for a(n) &quot;</span> &lt;&lt; <a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a> &lt;&lt; <span class="stringliteral">&quot; object.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    std::terminate();</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  }</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_1_1Quality_html_a1d3617b89c15ade245910fc9a4ddfa34"><div class="ttname"><a href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">libMesh::Quality::name</a></div><div class="ttdeci">std::string name(const ElemQuality q)</div><div class="ttdoc">This function returns a string containing some name for q. </div><div class="ttdef"><b>Definition:</b> <a href="elem__quality_8C_source.html#l00042">elem_quality.C:42</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a74e5bc8a72d210b3d87b0221b1f69db1"><div class="ttname"><a href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a></div><div class="ttdeci">OStreamProxy err(std::cerr)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00101">libmesh_common.h:101</a></div></div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a7c913252d05560f8bc7c75a63547c4c3"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">libMesh::ReferenceCounter::_counts</a></div><div class="ttdeci">static Counts _counts</div><div class="ttdoc">Actually holds the data. </div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00124">reference_counter.h:124</a></div></div>
<div class="ttc" id="classlibMesh_1_1BasicOStreamProxy_html_ae2d18b50fc63d23e47d46fcee630b4f5"><div class="ttname"><a href="classlibMesh_1_1BasicOStreamProxy.html#ae2d18b50fc63d23e47d46fcee630b4f5">libMesh::BasicOStreamProxy::get</a></div><div class="ttdeci">streamT * get()</div><div class="ttdoc">Rather than implement every ostream/ios/ios_base function, we&amp;#39;ll be lazy and make esoteric uses go th...</div><div class="ttdef"><b>Definition:</b> <a href="ostream__proxy_8h_source.html#l00217">ostream_proxy.h:217</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Threads_html_a29932e1987dacf7e89b1b27bb49bf0c9"><div class="ttname"><a href="namespacelibMesh_1_1Threads.html#a29932e1987dacf7e89b1b27bb49bf0c9">libMesh::Threads::spin_mtx</a></div><div class="ttdeci">spin_mutex spin_mtx</div><div class="ttdoc">A convenient spin mutex object which can be used for obtaining locks. </div><div class="ttdef"><b>Definition:</b> <a href="threads_8C_source.html#l00030">threads.C:30</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae8ff3926455efb7259d4bcc0c23daa54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::AdaptiveTimeSolver::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The initialization function. </p>
<p>This method is used to initialize internal data structures before a simulation begins. </p>

<p>重载 <a class="el" href="classlibMesh_1_1UnsteadySolver.html#a0bf00d1d581c41693ca7df9c4b110f2b">libMesh::UnsteadySolver</a> .</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00054">54</a> 行定义.</p>

<p>参考 <a class="el" href="adaptive__time__solver_8h_source.html#l00130">core_time_solver</a>, <a class="el" href="time__solver_8C_source.html#l00124">libMesh::TimeSolver::get_solution_history()</a>, <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>, <a class="el" href="unsteady__solver_8h_source.html#l00178">libMesh::UnsteadySolver::old_local_nonlinear_solution</a> , 以及 <a class="el" href="time__solver_8C_source.html#l00119">libMesh::TimeSolver::set_solution_history()</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;{</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(<a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>.get());</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <span class="comment">// We override this because our core_time_solver is the one that</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="comment">// needs to handle new vectors, diff_solver-&gt;init(), etc</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;init();</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="comment">// Set the core_time_solver&#39;s solution history object to be the same one as</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  <span class="comment">// that for the outer adaptive time solver</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;set_solution_history((this-&gt;<a class="code" href="classlibMesh_1_1TimeSolver.html#a53943438a376aced23535cc111c3033c">get_solution_history</a>()));</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <span class="comment">// Now that we have set the SolutionHistory object for the coretimesolver,</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="comment">// we set the SolutionHistory type for the timesolver to be NoSolutionHistory</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="comment">// All storage and retrieval will be handled by the coretimesolver directly.</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  NoSolutionHistory outersolver_solution_history;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1TimeSolver.html#a3dd9a20cf257999196a258c936fb79aa">set_solution_history</a>(outersolver_solution_history);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="comment">// As an UnsteadySolver, we have an old_local_nonlinear_solution, but it</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  <span class="comment">// isn&#39;t pointing to the right place - fix it</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <a class="code" href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">old_local_nonlinear_solution</a> = <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;old_local_nonlinear_solution;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1UnsteadySolver_html_aaa84acc193756038a9a9361d687f877e"><div class="ttname"><a href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">libMesh::UnsteadySolver::old_local_nonlinear_solution</a></div><div class="ttdeci">std::shared_ptr&lt; NumericVector&lt; Number &gt; &gt; old_local_nonlinear_solution</div><div class="ttdoc">Serial vector of _system.get_vector(&amp;quot;_old_nonlinear_solution&amp;quot;) This is a shared_ptr so that it can be...</div><div class="ttdef"><b>Definition:</b> <a href="unsteady__solver_8h_source.html#l00178">unsteady_solver.h:178</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a3dd9a20cf257999196a258c936fb79aa"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a3dd9a20cf257999196a258c936fb79aa">libMesh::TimeSolver::set_solution_history</a></div><div class="ttdeci">void set_solution_history(const SolutionHistory &amp;_solution_history)</div><div class="ttdoc">A setter function users will employ if they need to do something other than save no solution history...</div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8C_source.html#l00119">time_solver.C:119</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a53943438a376aced23535cc111c3033c"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a53943438a376aced23535cc111c3033c">libMesh::TimeSolver::get_solution_history</a></div><div class="ttdeci">SolutionHistory &amp; get_solution_history()</div><div class="ttdoc">A getter function that returns a reference to the solution history object owned by TimeSolver...</div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8C_source.html#l00124">time_solver.C:124</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2bc7d50d6e18bc1be3efcc91e86b5529"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::UnsteadySolver::init_adjoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add adjoint vectors and old_adjoint_vectors as per the indices of <a class="el" href="classlibMesh_1_1QoISet.html" title="Data structure for specifying which Quantities of Interest should be calculated in an adjoint or a pa...">QoISet</a>. </p>

<p>重载 <a class="el" href="classlibMesh_1_1TimeSolver.html#a049099726264e06b88164b37ef939cb6">libMesh::TimeSolver</a> .</p>

<p>在文件 <a class="el" href="unsteady__solver_8C_source.html">unsteady_solver.C</a> 第 <a class="el" href="unsteady__solver_8C_source.html#l00068">68</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00312">libMesh::TimeSolver::_system</a>, <a class="el" href="system_8C_source.html#l00750">libMesh::System::add_vector()</a>, <a class="el" href="enum__parallel__type_8h_source.html#l00037">libMesh::GHOSTED</a>, <a class="el" href="time__solver_8C_source.html#l00083">libMesh::TimeSolver::init_adjoints()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a> , 以及 <a class="el" href="system_8h_source.html#l02516">libMesh::System::n_qois()</a>.</p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;{</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <a class="code" href="classlibMesh_1_1TimeSolver.html#a049099726264e06b88164b37ef939cb6">TimeSolver::init_adjoints</a>();</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="comment">// Add old adjoint solutions</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  <span class="comment">// To keep the number of vectors consistent between the primal and adjoint</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <span class="comment">// time loops, we will also add the adjoint rhs vector during initialization</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="keywordflow">for</span>(<span class="keyword">auto</span> i : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(<a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a993ffd888b690f4af0e1dd5a3df49b3f">n_qois</a>()))</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  {</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    std::string old_adjoint_solution_name = <span class="stringliteral">&quot;_old_adjoint_solution&quot;</span>;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    old_adjoint_solution_name+= std::to_string(i);</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a73b89c8295f639035ee70666476a1606">add_vector</a>(old_adjoint_solution_name, <span class="keyword">false</span>, <a class="code" href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d">GHOSTED</a>);</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    std::string adjoint_rhs_name = <span class="stringliteral">&quot;adjoint_rhs&quot;</span>;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    adjoint_rhs_name+= std::to_string(i);</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a73b89c8295f639035ee70666476a1606">add_vector</a>(adjoint_rhs_name, <span class="keyword">false</span>, <a class="code" href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d">GHOSTED</a>);</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  }</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1System_html_a993ffd888b690f4af0e1dd5a3df49b3f"><div class="ttname"><a href="classlibMesh_1_1System.html#a993ffd888b690f4af0e1dd5a3df49b3f">libMesh::System::n_qois</a></div><div class="ttdeci">unsigned int n_qois() const </div><div class="ttdoc">Number of currently active quantities of interest. </div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l02516">system.h:2516</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a73b89c8295f639035ee70666476a1606"><div class="ttname"><a href="classlibMesh_1_1System.html#a73b89c8295f639035ee70666476a1606">libMesh::System::add_vector</a></div><div class="ttdeci">NumericVector&lt; Number &gt; &amp; add_vector(std::string_view vec_name, const bool projections=true, const ParallelType type=PARALLEL)</div><div class="ttdoc">Adds the additional vector vec_name to this system. </div><div class="ttdef"><b>Definition:</b> <a href="system_8C_source.html#l00750">system.C:750</a></div></div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a0cf14c8b81127d014c49c45d88dfaf46"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">libMesh::TimeSolver::_system</a></div><div class="ttdeci">sys_type &amp; _system</div><div class="ttdoc">A reference to the system we are solving. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00312">time_solver.h:312</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d"><div class="ttname"><a href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d">libMesh::GHOSTED</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__parallel__type_8h_source.html#l00037">enum_parallel_type.h:37</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a049099726264e06b88164b37ef939cb6"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a049099726264e06b88164b37ef939cb6">libMesh::TimeSolver::init_adjoints</a></div><div class="ttdeci">virtual void init_adjoints()</div><div class="ttdoc">Initialize any adjoint related data structures, based on the number of qois. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8C_source.html#l00083">time_solver.C:83</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5427a0c0cf6d022c9c3ce9e71fa3d8f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::UnsteadySolver::init_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The data initialization function. </p>
<p>This method is used to initialize internal data structures after the underlying <a class="el" href="classlibMesh_1_1System.html" title="Manages consistently variables, degrees of freedom, and coefficient vectors. ">System</a> has been initialized </p>

<p>重载 <a class="el" href="classlibMesh_1_1TimeSolver.html#aa50b735bd4455aea59acd9b0e7b4f464">libMesh::TimeSolver</a> .</p>

<p>被 <a class="el" href="classlibMesh_1_1SecondOrderUnsteadySolver.html#a38dc7024f880dda72fe83605744c0dd7">libMesh::SecondOrderUnsteadySolver</a> 重载.</p>

<p>在文件 <a class="el" href="unsteady__solver_8C_source.html">unsteady_solver.C</a> 第 <a class="el" href="unsteady__solver_8C_source.html#l00089">89</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00312">libMesh::TimeSolver::_system</a>, <a class="el" href="system_8h_source.html#l02293">libMesh::System::get_dof_map()</a>, <a class="el" href="dof__map_8h_source.html#l00511">libMesh::DofMap::get_send_list()</a>, <a class="el" href="enum__parallel__type_8h_source.html#l00037">libMesh::GHOSTED</a>, <a class="el" href="time__solver_8C_source.html#l00097">libMesh::TimeSolver::init_data()</a>, <a class="el" href="system_8C_source.html#l00112">libMesh::System::n_dofs()</a>, <a class="el" href="system_8C_source.html#l00149">libMesh::System::n_local_dofs()</a>, <a class="el" href="unsteady__solver_8h_source.html#l00178">libMesh::UnsteadySolver::old_local_nonlinear_solution</a> , 以及 <a class="el" href="enum__parallel__type_8h_source.html#l00035">libMesh::SERIAL</a>.</p>

<p>参考自 <a class="el" href="second__order__unsteady__solver_8C_source.html#l00042">libMesh::SecondOrderUnsteadySolver::init_data()</a>.</p>
<div class="fragment"><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;{</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <a class="code" href="classlibMesh_1_1TimeSolver.html#aa50b735bd4455aea59acd9b0e7b4f464">TimeSolver::init_data</a>();</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_GHOSTED</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="preprocessor"></span>  <a class="code" href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">old_local_nonlinear_solution</a>-&gt;init (<a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a57de7c4f37f7ca24fbf185d3d07054cd">n_dofs</a>(), <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a069a96e414fd05d292e3bb3a1a475602">n_local_dofs</a>(),</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                                      <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a3b392c8791f781092d6326e51856f553">get_dof_map</a>().<a class="code" href="classlibMesh_1_1DofMap.html#a31c127241d3271719ede3d0a6902e9e4">get_send_list</a>(), <span class="keyword">false</span>,</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                                      <a class="code" href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d">GHOSTED</a>);</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="preprocessor"></span>  <a class="code" href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">old_local_nonlinear_solution</a>-&gt;init (<a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a57de7c4f37f7ca24fbf185d3d07054cd">n_dofs</a>(), <span class="keyword">false</span>, <a class="code" href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa538bc63becff09f368e6f930e423391f">SERIAL</a>);</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="preprocessor"></span>}</div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_aa50b735bd4455aea59acd9b0e7b4f464"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#aa50b735bd4455aea59acd9b0e7b4f464">libMesh::TimeSolver::init_data</a></div><div class="ttdeci">virtual void init_data()</div><div class="ttdoc">The data initialization function. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8C_source.html#l00097">time_solver.C:97</a></div></div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a0cf14c8b81127d014c49c45d88dfaf46"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">libMesh::TimeSolver::_system</a></div><div class="ttdeci">sys_type &amp; _system</div><div class="ttdoc">A reference to the system we are solving. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00312">time_solver.h:312</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a2f87e215292aa3e352afd4f8f14c3d7fa538bc63becff09f368e6f930e423391f"><div class="ttname"><a href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa538bc63becff09f368e6f930e423391f">libMesh::SERIAL</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__parallel__type_8h_source.html#l00035">enum_parallel_type.h:35</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a3b392c8791f781092d6326e51856f553"><div class="ttname"><a href="classlibMesh_1_1System.html#a3b392c8791f781092d6326e51856f553">libMesh::System::get_dof_map</a></div><div class="ttdeci">const DofMap &amp; get_dof_map() const </div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l02293">system.h:2293</a></div></div>
<div class="ttc" id="classlibMesh_1_1UnsteadySolver_html_aaa84acc193756038a9a9361d687f877e"><div class="ttname"><a href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">libMesh::UnsteadySolver::old_local_nonlinear_solution</a></div><div class="ttdeci">std::shared_ptr&lt; NumericVector&lt; Number &gt; &gt; old_local_nonlinear_solution</div><div class="ttdoc">Serial vector of _system.get_vector(&amp;quot;_old_nonlinear_solution&amp;quot;) This is a shared_ptr so that it can be...</div><div class="ttdef"><b>Definition:</b> <a href="unsteady__solver_8h_source.html#l00178">unsteady_solver.h:178</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d"><div class="ttname"><a href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d">libMesh::GHOSTED</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__parallel__type_8h_source.html#l00037">enum_parallel_type.h:37</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a069a96e414fd05d292e3bb3a1a475602"><div class="ttname"><a href="classlibMesh_1_1System.html#a069a96e414fd05d292e3bb3a1a475602">libMesh::System::n_local_dofs</a></div><div class="ttdeci">dof_id_type n_local_dofs() const </div><div class="ttdef"><b>Definition:</b> <a href="system_8C_source.html#l00149">system.C:149</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a57de7c4f37f7ca24fbf185d3d07054cd"><div class="ttname"><a href="classlibMesh_1_1System.html#a57de7c4f37f7ca24fbf185d3d07054cd">libMesh::System::n_dofs</a></div><div class="ttdeci">dof_id_type n_dofs() const </div><div class="ttdef"><b>Definition:</b> <a href="system_8C_source.html#l00112">system.C:112</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofMap_html_a31c127241d3271719ede3d0a6902e9e4"><div class="ttname"><a href="classlibMesh_1_1DofMap.html#a31c127241d3271719ede3d0a6902e9e4">libMesh::DofMap::get_send_list</a></div><div class="ttdeci">const std::vector&lt; dof_id_type &gt; &amp; get_send_list() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__map_8h_source.html#l00511">dof_map.h:511</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a57cb688f5178159af6aec8e52e39cd62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::AdaptiveTimeSolver::integrate_adjoint_refinement_error_estimate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method to compute the adjoint refinement error estimate at the current timestep. </p>
<p>int_{tstep_start}^{tstep_end} R(u^h,z) dt The user provides an initialized ARefEE object. Fills in an <a class="el" href="classlibMesh_1_1ErrorVector.html" title="The ErrorVector is a specialization of the StatisticsVector for error data computed on a finite eleme...">ErrorVector</a> that contains the weighted sum of errors from all the QoIs and can be used to guide AMR. CURRENTLY ONLY SUPPORTED for Backward Euler. </p>

<p>实现了 <a class="el" href="classlibMesh_1_1FirstOrderUnsteadySolver.html#a0c2560c59d706e5333744663826d0733">libMesh::FirstOrderUnsteadySolver</a>.</p>

<p>在 <a class="el" href="classlibMesh_1_1TwostepTimeSolver.html#a600234119a0881819539598a25b5f21b">libMesh::TwostepTimeSolver</a> 内被实现.</p>

</div>
</div>
<a class="anchor" id="a50282a676145e736e62ba87202e570a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::AdaptiveTimeSolver::integrate_adjoint_sensitivity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> &amp;&#160;</td>
          <td class="paramname"><em>qois</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1ParameterVector.html">ParameterVector</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1SensitivityData.html">SensitivityData</a> &amp;&#160;</td>
          <td class="paramname"><em>sensitivities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method to integrate the adjoint sensitivity w.r.t a given parameter vector. </p>
<p>int_{tstep_start}^{tstep_end} dQ/dp dt = int_{tstep_start}^{tstep_end} ( /  p) - (  R (u,z) /  p ) dt The trapezoidal rule is used to numerically integrate the timestep. </p>

<p>重载 <a class="el" href="classlibMesh_1_1UnsteadySolver.html#a951adaa45962962572e177ca5c3de90c">libMesh::UnsteadySolver</a> .</p>

<p>在 <a class="el" href="classlibMesh_1_1TwostepTimeSolver.html#aeabb83bf456d3c290f4c3b40ae8287c8">libMesh::TwostepTimeSolver</a> 内被实现.</p>

</div>
</div>
<a class="anchor" id="a29d86173ce93b7ab991a1dfbc5efe73c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::AdaptiveTimeSolver::integrate_qoi_timestep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method to integrate the system::QoI functionals. </p>

<p>实现了 <a class="el" href="classlibMesh_1_1FirstOrderUnsteadySolver.html#aa129e5986847289851d3e5ee005ba93f">libMesh::FirstOrderUnsteadySolver</a>.</p>

<p>在 <a class="el" href="classlibMesh_1_1TwostepTimeSolver.html#ad71b51a16111fdec4daa886bbf227d9d">libMesh::TwostepTimeSolver</a> 内被实现.</p>

</div>
</div>
<a class="anchor" id="abd4fe54b2f4feb0a49829a0f15652211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::TimeSolver::is_adjoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for querying whether we need to do a primal or adjoint solve. </p>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00277">277</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00340">libMesh::TimeSolver::_is_adjoint</a>.</p>

<p>参考自 <a class="el" href="fem__system_8C_source.html#l01346">libMesh::FEMSystem::build_context()</a>.</p>
<div class="fragment"><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  { <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1TimeSolver.html#a7291f74ec282f2911f457bf9ff7a786e">_is_adjoint</a>; }</div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a7291f74ec282f2911f457bf9ff7a786e"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a7291f74ec282f2911f457bf9ff7a786e">libMesh::TimeSolver::_is_adjoint</a></div><div class="ttdeci">bool _is_adjoint</div><div class="ttdoc">This boolean tells the TimeSolver whether we are solving a primal or adjoint problem. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00340">time_solver.h:340</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3e9edb1f593be85de005e80fdc273f44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool libMesh::UnsteadySolver::is_steady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is not a steady-state solver. </p>

<p>实现了 <a class="el" href="classlibMesh_1_1TimeSolver.html#a58a7309d684a6e1ed6daf1737a6125b6">libMesh::TimeSolver</a>.</p>

<p>在文件 <a class="el" href="unsteady__solver_8h_source.html">unsteady_solver.h</a> 第 <a class="el" href="unsteady__solver_8h_source.html#l00194">194</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9e3c0328f3b600cc93c90b1dbc397674"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::AdaptiveTimeSolver::last_completed_timestep_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns system.deltat if fixed timestep solver is used, the complete timestep size (sum of all substeps) if the adaptive time solver is used. </p>
<p>Returns the change in system.time, deltat, for the last timestep which was successfully completed. This only returns the outermost step size in the case of nested time solvers. If no time step has yet been successfully completed, then returns system.deltat. </p>

<p>重载 <a class="el" href="classlibMesh_1_1TimeSolver.html#aaaf702646866401f1ce4adab61560d6a">libMesh::TimeSolver</a> .</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00091">91</a> 行定义.</p>

<p>参考 <a class="el" href="adaptive__time__solver_8h_source.html#l00205">completed_timestep_size</a>.</p>
<div class="fragment"><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a3688a87be263c45e7db268869a54e1e4">completed_timestep_size</a>; };</div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a3688a87be263c45e7db268869a54e1e4"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a3688a87be263c45e7db268869a54e1e4">libMesh::AdaptiveTimeSolver::completed_timestep_size</a></div><div class="ttdeci">Real completed_timestep_size</div><div class="ttdoc">The adaptive time solver&amp;#39;s have two notions of deltat. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00205">adaptive_time_solver.h:205</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3cd477c84431a2a3e932f3df911c7fe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1LinearSolver.html">LinearSolver</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; &gt; &amp; libMesh::AdaptiveTimeSolver::linear_solver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An implicit linear solver to use for adjoint and sensitivity problems. </p>

<p>重载 <a class="el" href="classlibMesh_1_1TimeSolver.html#a8228573ff2f6b74b5d2e1a920cae15b8">libMesh::TimeSolver</a> .</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00218">218</a> 行定义.</p>

<p>参考 <a class="el" href="adaptive__time__solver_8h_source.html#l00130">core_time_solver</a>.</p>
<div class="fragment"><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;{</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;linear_solver();</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a50e74641afc6e2870c9e1ce412f8c44f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int libMesh::ReferenceCounter::n_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the number of outstanding (created, but not yet destroyed) objects. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00085">85</a> 行定义.</p>

<p>参考 <a class="el" href="reference__counter_8h_source.html#l00132">libMesh::ReferenceCounter::_n_objects</a>.</p>

<p>参考自 <a class="el" href="libmesh_8C_source.html#l00668">libMesh::LibMeshInit::~LibMeshInit()</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  { <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1ReferenceCounter.html#ad2c30f0f71dcd00f00faa8e46aa3e043">_n_objects</a>; }</div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_ad2c30f0f71dcd00f00faa8e46aa3e043"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#ad2c30f0f71dcd00f00faa8e46aa3e043">libMesh::ReferenceCounter::_n_objects</a></div><div class="ttdeci">static Threads::atomic&lt; unsigned int &gt; _n_objects</div><div class="ttdoc">The number of objects. </div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00132">reference_counter.h:132</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abdf71c8e982a9dda1a65e2a0b09831a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::AdaptiveTimeSolver::nonlocal_residual </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is passed on to the core_time_solver. </p>

<p>实现了 <a class="el" href="classlibMesh_1_1TimeSolver.html#ac87cad8b666f2eff12966d7769ae6950">libMesh::TimeSolver</a>.</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00201">201</a> 行定义.</p>

<p>参考 <a class="el" href="adaptive__time__solver_8h_source.html#l00130">core_time_solver</a> , 以及 <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>.</p>
<div class="fragment"><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;{</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(<a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>.get());</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;nonlocal_residual(request_jacobian, context);</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa3a15d929fc0179d7a2e88928ad719ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> libMesh::UnsteadySolver::old_nonlinear_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>&#160;</td>
          <td class="paramname"><em>global_dof_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>返回</dt><dd>The old nonlinear solution for the specified global DOF. </dd></dl>

<p>在文件 <a class="el" href="unsteady__solver_8C_source.html">unsteady_solver.C</a> 第 <a class="el" href="unsteady__solver_8C_source.html#l00337">337</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00312">libMesh::TimeSolver::_system</a>, <a class="el" href="system_8h_source.html#l02293">libMesh::System::get_dof_map()</a>, <a class="el" href="dof__map_8h_source.html#l00659">libMesh::DofMap::n_dofs()</a> , 以及 <a class="el" href="unsteady__solver_8h_source.html#l00178">libMesh::UnsteadySolver::old_local_nonlinear_solution</a>.</p>

<p>参考自 <a class="el" href="euler__solver_8C_source.html#l00102">libMesh::EulerSolver::_general_residual()</a>, <a class="el" href="euler2__solver_8C_source.html#l00103">libMesh::Euler2Solver::_general_residual()</a> , 以及 <a class="el" href="newmark__solver_8C_source.html#l00203">libMesh::NewmarkSolver::_general_residual()</a>.</p>
<div class="fragment"><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;{</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;  libmesh_assert_less (global_dof_number, <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a3b392c8791f781092d6326e51856f553">get_dof_map</a>().<a class="code" href="classlibMesh_1_1DofMap.html#a77f8d984574b1bf8886057799e9b0134">n_dofs</a>());</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;  libmesh_assert_less (global_dof_number, <a class="code" href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">old_local_nonlinear_solution</a>-&gt;size());</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;  <span class="keywordflow">return</span> (*<a class="code" href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">old_local_nonlinear_solution</a>)(global_dof_number);</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1DofMap_html_a77f8d984574b1bf8886057799e9b0134"><div class="ttname"><a href="classlibMesh_1_1DofMap.html#a77f8d984574b1bf8886057799e9b0134">libMesh::DofMap::n_dofs</a></div><div class="ttdeci">dof_id_type n_dofs() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__map_8h_source.html#l00659">dof_map.h:659</a></div></div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a0cf14c8b81127d014c49c45d88dfaf46"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">libMesh::TimeSolver::_system</a></div><div class="ttdeci">sys_type &amp; _system</div><div class="ttdoc">A reference to the system we are solving. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00312">time_solver.h:312</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a3b392c8791f781092d6326e51856f553"><div class="ttname"><a href="classlibMesh_1_1System.html#a3b392c8791f781092d6326e51856f553">libMesh::System::get_dof_map</a></div><div class="ttdeci">const DofMap &amp; get_dof_map() const </div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l02293">system.h:2293</a></div></div>
<div class="ttc" id="classlibMesh_1_1UnsteadySolver_html_aaa84acc193756038a9a9361d687f877e"><div class="ttname"><a href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">libMesh::UnsteadySolver::old_local_nonlinear_solution</a></div><div class="ttdeci">std::shared_ptr&lt; NumericVector&lt; Number &gt; &gt; old_local_nonlinear_solution</div><div class="ttdoc">Serial vector of _system.get_vector(&amp;quot;_old_nonlinear_solution&amp;quot;) This is a shared_ptr so that it can be...</div><div class="ttdef"><b>Definition:</b> <a href="unsteady__solver_8h_source.html#l00178">unsteady_solver.h:178</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0e53509b111f7bee8137ca33642b11f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::FirstOrderUnsteadySolver::prepare_accel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If there are second order variables in the system, then we also prepare the accel for those variables so the user can treat them as such. </p>

<p>在文件 <a class="el" href="first__order__unsteady__solver_8C_source.html">first_order_unsteady_solver.C</a> 第 <a class="el" href="first__order__unsteady__solver_8C_source.html#l00025">25</a> 行定义.</p>

<p>参考 <a class="el" href="diff__context_8h_source.html#l00462">libMesh::DiffContext::elem_solution_accel_derivative</a>, <a class="el" href="diff__context_8h_source.html#l00162">libMesh::DiffContext::get_elem_solution_accel()</a>, <a class="el" href="diff__context_8h_source.html#l00132">libMesh::DiffContext::get_elem_solution_rate()</a> , 以及 <a class="el" href="diff__context_8h_source.html#l00407">libMesh::DiffContext::get_elem_solution_rate_derivative()</a>.</p>

<p>参考自 <a class="el" href="euler__solver_8C_source.html#l00102">libMesh::EulerSolver::_general_residual()</a> , 以及 <a class="el" href="euler2__solver_8C_source.html#l00103">libMesh::Euler2Solver::_general_residual()</a>.</p>
<div class="fragment"><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;{</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  context.get_elem_solution_accel() = context.get_elem_solution_rate();</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  context.elem_solution_accel_derivative = context.get_elem_solution_rate_derivative();</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a13ce734a14ffd1dbb6496dab702da8e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ReferenceCounter::print_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em> = <code><a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the reference information, by default to <code><a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></code>. </p>

<p>在文件 <a class="el" href="reference__counter_8C_source.html">reference_counter.C</a> 第 <a class="el" href="reference__counter_8C_source.html#l00081">81</a> 行定义.</p>

<p>参考 <a class="el" href="reference__counter_8h_source.html#l00143">libMesh::ReferenceCounter::_enable_print_counter</a> , 以及 <a class="el" href="reference__counter_8C_source.html#l00047">libMesh::ReferenceCounter::get_info()</a>.</p>

<p>参考自 <a class="el" href="libmesh_8C_source.html#l00668">libMesh::LibMeshInit::~LibMeshInit()</a>.</p>
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;{</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">_enable_print_counter</a>)</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    out_stream &lt;&lt; <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a103b37125ae9eaaadf6f7854df17faa2">ReferenceCounter::get_info</a>();</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a103b37125ae9eaaadf6f7854df17faa2"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a103b37125ae9eaaadf6f7854df17faa2">libMesh::ReferenceCounter::get_info</a></div><div class="ttdeci">static std::string get_info()</div><div class="ttdoc">Gets a string containing the reference information. </div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8C_source.html#l00047">reference_counter.C:47</a></div></div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a8f75e8a4a280f2c41636f2ae1307a311"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">libMesh::ReferenceCounter::_enable_print_counter</a></div><div class="ttdeci">static bool _enable_print_counter</div><div class="ttdoc">Flag to control whether reference count information is printed when print_info is called...</div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00143">reference_counter.h:143</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a056c5a74107f6609bd2c96a040c9ddd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::AdaptiveTimeSolver::reinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The reinitialization function. </p>
<p>This method is used to resize internal data vectors after a mesh change. </p>

<p>重载 <a class="el" href="classlibMesh_1_1UnsteadySolver.html#ab41ad1ba8609b5561f8196c6c00fb7cb">libMesh::UnsteadySolver</a> .</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00079">79</a> 行定义.</p>

<p>参考 <a class="el" href="adaptive__time__solver_8h_source.html#l00130">core_time_solver</a> , 以及 <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>.</p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;{</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(<a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>.get());</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="comment">// We override this because our core_time_solver is the one that</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <span class="comment">// needs to handle new vectors, diff_solver-&gt;reinit(), etc</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;reinit();</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae55437fc1f7a75daec617e64c4f2e87e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::AdaptiveTimeSolver::retrieve_timestep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method retrieves all the stored solutions at the current system.time. </p>

<p>重载 <a class="el" href="classlibMesh_1_1UnsteadySolver.html#a96856f826dc75a13aa5fa7ea340f12ea">libMesh::UnsteadySolver</a> .</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00165">165</a> 行定义.</p>

<p>参考 <a class="el" href="adaptive__time__solver_8h_source.html#l00130">core_time_solver</a>.</p>
<div class="fragment"><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;{</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  <span class="comment">// Ask the core time solver to retrieve all the stored vectors</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  <span class="comment">// at the current time</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;retrieve_timestep();</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afd07c68ca275025276a9a0fcc921262d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::UnsteadySolver::set_first_adjoint_step </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first_adjoint_step_setting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A setter for the first_adjoint_step boolean. </p>
<p>Needed for nested time solvers. </p>

<p>在文件 <a class="el" href="unsteady__solver_8h_source.html">unsteady_solver.h</a> 第 <a class="el" href="unsteady__solver_8h_source.html#l00199">199</a> 行定义.</p>

<p>参考 <a class="el" href="unsteady__solver_8h_source.html#l00226">libMesh::UnsteadySolver::first_adjoint_step</a>.</p>
<div class="fragment"><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  {</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <a class="code" href="classlibMesh_1_1UnsteadySolver.html#a437131696784e0e31a35315e3387c7b5">first_adjoint_step</a> = first_adjoint_step_setting;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1UnsteadySolver_html_a437131696784e0e31a35315e3387c7b5"><div class="ttname"><a href="classlibMesh_1_1UnsteadySolver.html#a437131696784e0e31a35315e3387c7b5">libMesh::UnsteadySolver::first_adjoint_step</a></div><div class="ttdeci">bool first_adjoint_step</div><div class="ttdoc">A bool that will be true the first time adjoint_advance_timestep() is called, (when the primal soluti...</div><div class="ttdef"><b>Definition:</b> <a href="unsteady__solver_8h_source.html#l00226">unsteady_solver.h:226</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6d14b4501a87b26e726976656d435f47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::UnsteadySolver::set_first_solve </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first_solve_setting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="unsteady__solver_8h_source.html">unsteady_solver.h</a> 第 <a class="el" href="unsteady__solver_8h_source.html#l00209">209</a> 行定义.</p>

<p>参考 <a class="el" href="unsteady__solver_8h_source.html#l00220">libMesh::UnsteadySolver::first_solve</a>.</p>
<div class="fragment"><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;  {</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <a class="code" href="classlibMesh_1_1UnsteadySolver.html#ad5be0a1a2852028cc39b995b0d07bef6">first_solve</a> = first_solve_setting;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1UnsteadySolver_html_ad5be0a1a2852028cc39b995b0d07bef6"><div class="ttname"><a href="classlibMesh_1_1UnsteadySolver.html#ad5be0a1a2852028cc39b995b0d07bef6">libMesh::UnsteadySolver::first_solve</a></div><div class="ttdeci">bool first_solve</div><div class="ttdoc">A bool that will be true the first time solve() is called, and false thereafter. </div><div class="ttdef"><b>Definition:</b> <a href="unsteady__solver_8h_source.html#l00220">unsteady_solver.h:220</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0c67591fc3ee089d9a673c11d5fe7c30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::TimeSolver::set_is_adjoint </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_is_adjoint_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for setting whether we need to do a primal or adjoint solve. </p>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00284">284</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00340">libMesh::TimeSolver::_is_adjoint</a>.</p>

<p>参考自 <a class="el" href="diff__system_8C_source.html#l00150">libMesh::DifferentiableSystem::adjoint_solve()</a>, <a class="el" href="fem__system_8C_source.html#l01127">libMesh::FEMSystem::postprocess()</a> , 以及 <a class="el" href="diff__system_8C_source.html#l00138">libMesh::DifferentiableSystem::solve()</a>.</p>
<div class="fragment"><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  { <a class="code" href="classlibMesh_1_1TimeSolver.html#a7291f74ec282f2911f457bf9ff7a786e">_is_adjoint</a> = _is_adjoint_value; }</div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a7291f74ec282f2911f457bf9ff7a786e"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a7291f74ec282f2911f457bf9ff7a786e">libMesh::TimeSolver::_is_adjoint</a></div><div class="ttdeci">bool _is_adjoint</div><div class="ttdoc">This boolean tells the TimeSolver whether we are solving a primal or adjoint problem. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00340">time_solver.h:340</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3dd9a20cf257999196a258c936fb79aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::TimeSolver::set_solution_history </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1SolutionHistory.html">SolutionHistory</a> &amp;&#160;</td>
          <td class="paramname"><em>_solution_history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A setter function users will employ if they need to do something other than save no solution history. </p>

<p>在文件 <a class="el" href="time__solver_8C_source.html">time_solver.C</a> 第 <a class="el" href="time__solver_8C_source.html#l00119">119</a> 行定义.</p>

<p>参考 <a class="el" href="classlibMesh_1_1SolutionHistory.html#a56c2b2b68df7379081d634855286389f">libMesh::SolutionHistory::clone()</a> , 以及 <a class="el" href="time__solver_8h_source.html#l00319">libMesh::TimeSolver::solution_history</a>.</p>

<p>参考自 <a class="el" href="adaptive__time__solver_8C_source.html#l00054">init()</a>.</p>
<div class="fragment"><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;{</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <a class="code" href="classlibMesh_1_1TimeSolver.html#ad7e23d6b0c8a4844fef98915a28c52d0">solution_history</a> = _solution_history.clone();</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_ad7e23d6b0c8a4844fef98915a28c52d0"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#ad7e23d6b0c8a4844fef98915a28c52d0">libMesh::TimeSolver::solution_history</a></div><div class="ttdeci">std::unique_ptr&lt; SolutionHistory &gt; solution_history</div><div class="ttdoc">A std::unique_ptr to a SolutionHistory object. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00319">time_solver.h:319</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6fc68e6b09cf4f44dfbb163e364c5f81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::AdaptiveTimeSolver::side_residual </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DiffContext.html">DiffContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is passed on to the core_time_solver. </p>

<p>实现了 <a class="el" href="classlibMesh_1_1TimeSolver.html#afe6b041195b7c116b534ff31b60b2214">libMesh::TimeSolver</a>.</p>

<p>在文件 <a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a> 第 <a class="el" href="adaptive__time__solver_8C_source.html#l00191">191</a> 行定义.</p>

<p>参考 <a class="el" href="adaptive__time__solver_8h_source.html#l00130">core_time_solver</a> , 以及 <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>.</p>
<div class="fragment"><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;{</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(<a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>.get());</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">core_time_solver</a>-&gt;side_residual(request_jacobian, context);</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1AdaptiveTimeSolver_html_a6cdd1f46101a1c62ee0fcabb4baeac8b"><div class="ttname"><a href="classlibMesh_1_1AdaptiveTimeSolver.html#a6cdd1f46101a1c62ee0fcabb4baeac8b">libMesh::AdaptiveTimeSolver::core_time_solver</a></div><div class="ttdeci">std::unique_ptr&lt; UnsteadySolver &gt; core_time_solver</div><div class="ttdoc">This object is used to take timesteps. </div><div class="ttdef"><b>Definition:</b> <a href="adaptive__time__solver_8h_source.html#l00130">adaptive_time_solver.h:130</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a115b029ab169245296d22487b3d83c46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::AdaptiveTimeSolver::solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method solves for the solution at the next timestep. </p>
<p>Usually we will only need to solve one (non)linear system per timestep, but more complex subclasses may override this. </p>

<p>重载 <a class="el" href="classlibMesh_1_1UnsteadySolver.html#aad83b8429f49f336a0cbc1e044c7ab83">libMesh::UnsteadySolver</a> .</p>

<p>在 <a class="el" href="classlibMesh_1_1TwostepTimeSolver.html#a57a65695fc3a431c21312b0ae9f0ef2f">libMesh::TwostepTimeSolver</a> 内被实现.</p>

</div>
</div>
<a class="anchor" id="a72073432986fac3e0f54a1d312955e34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1TimeSolver.html#a4e7363e989661b62466ed602c1189f5a">sys_type</a>&amp; libMesh::TimeSolver::system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>返回</dt><dd>A constant reference to the system we are solving. </dd></dl>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00210">210</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00312">libMesh::TimeSolver::_system</a>.</p>

<p>参考自 <a class="el" href="time__solver_8C_source.html#l00133">libMesh::TimeSolver::adjoint_solve()</a>, <a class="el" href="time__solver_8C_source.html#l00054">libMesh::TimeSolver::reinit()</a> , 以及 <a class="el" href="time__solver_8C_source.html#l00111">libMesh::TimeSolver::solve()</a>.</p>
<div class="fragment"><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>; }</div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a0cf14c8b81127d014c49c45d88dfaf46"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">libMesh::TimeSolver::_system</a></div><div class="ttdeci">sys_type &amp; _system</div><div class="ttdoc">A reference to the system we are solving. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00312">time_solver.h:312</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac973fc3e98afd2e50a536fe9b5501d58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1TimeSolver.html#a4e7363e989661b62466ed602c1189f5a">sys_type</a>&amp; libMesh::TimeSolver::system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>返回</dt><dd>A writable reference to the system we are solving. </dd></dl>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00215">215</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00312">libMesh::TimeSolver::_system</a>.</p>
<div class="fragment"><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>; }</div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a0cf14c8b81127d014c49c45d88dfaf46"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">libMesh::TimeSolver::_system</a></div><div class="ttdeci">sys_type &amp; _system</div><div class="ttdoc">A reference to the system we are solving. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00312">time_solver.h:312</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae89b1912967ede85ed664eb254dd8382"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int libMesh::FirstOrderUnsteadySolver::time_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>返回</dt><dd>The maximum order of time derivatives for which the <a class="el" href="classlibMesh_1_1UnsteadySolver.html" title="This is a generic class that defines a solver to handle time integration of DifferentiableSystems. ">UnsteadySolver</a> subclass is capable of handling.</dd></dl>
<p>For example, <a class="el" href="classlibMesh_1_1EulerSolver.html" title="This class defines a theta-method Euler (defaulting to Backward Euler with theta = 1...">EulerSolver</a> will have <code><a class="el" href="classlibMesh_1_1FirstOrderUnsteadySolver.html#ae89b1912967ede85ed664eb254dd8382">time_order()</a></code> = 1 and <a class="el" href="classlibMesh_1_1NewmarkSolver.html" title="This class defines a Newmark time integrator for second order (in time) DifferentiableSystems. ">NewmarkSolver</a> will have <code><a class="el" href="classlibMesh_1_1FirstOrderUnsteadySolver.html#ae89b1912967ede85ed664eb254dd8382">time_order()</a></code> = 2. </p>

<p>实现了 <a class="el" href="classlibMesh_1_1UnsteadySolver.html#ac3e793c6b251d78e591fa6c0a9eabc98">libMesh::UnsteadySolver</a>.</p>

<p>在文件 <a class="el" href="first__order__unsteady__solver_8h_source.html">first_order_unsteady_solver.h</a> 第 <a class="el" href="first__order__unsteady__solver_8h_source.html#l00090">90</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  { <span class="keywordflow">return</span> 1; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3fbec9f5e45a2b2f3c8e3fdcb1e2abd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::UnsteadySolver::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="unsteady__solver_8C_source.html">unsteady_solver.C</a> 第 <a class="el" href="unsteady__solver_8C_source.html#l00361">361</a> 行定义.</p>

<p>参考 <a class="el" href="time__solver_8h_source.html#l00312">libMesh::TimeSolver::_system</a>, <a class="el" href="system_8h_source.html#l02293">libMesh::System::get_dof_map()</a>, <a class="el" href="dof__map_8h_source.html#l00511">libMesh::DofMap::get_send_list()</a>, <a class="el" href="system_8C_source.html#l00917">libMesh::System::get_vector()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a7348b5b027adf716016354847e0df0b6">libMesh::NumericVector&lt; T &gt;::localize()</a> , 以及 <a class="el" href="unsteady__solver_8h_source.html#l00178">libMesh::UnsteadySolver::old_local_nonlinear_solution</a>.</p>
<div class="fragment"><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;{</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;  <span class="comment">// Dont forget to localize the old_nonlinear_solution !</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a2398b253d3fd1ec124777c4cbb6ba6c0">get_vector</a>(<span class="stringliteral">&quot;_old_nonlinear_solution&quot;</span>).<a class="code" href="classlibMesh_1_1NumericVector.html#a7348b5b027adf716016354847e0df0b6">localize</a></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    (*<a class="code" href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">old_local_nonlinear_solution</a>,</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;     <a class="code" href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">_system</a>.<a class="code" href="classlibMesh_1_1System.html#a3b392c8791f781092d6326e51856f553">get_dof_map</a>().<a class="code" href="classlibMesh_1_1DofMap.html#a31c127241d3271719ede3d0a6902e9e4">get_send_list</a>());</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1TimeSolver_html_a0cf14c8b81127d014c49c45d88dfaf46"><div class="ttname"><a href="classlibMesh_1_1TimeSolver.html#a0cf14c8b81127d014c49c45d88dfaf46">libMesh::TimeSolver::_system</a></div><div class="ttdeci">sys_type &amp; _system</div><div class="ttdoc">A reference to the system we are solving. </div><div class="ttdef"><b>Definition:</b> <a href="time__solver_8h_source.html#l00312">time_solver.h:312</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a3b392c8791f781092d6326e51856f553"><div class="ttname"><a href="classlibMesh_1_1System.html#a3b392c8791f781092d6326e51856f553">libMesh::System::get_dof_map</a></div><div class="ttdeci">const DofMap &amp; get_dof_map() const </div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l02293">system.h:2293</a></div></div>
<div class="ttc" id="classlibMesh_1_1UnsteadySolver_html_aaa84acc193756038a9a9361d687f877e"><div class="ttname"><a href="classlibMesh_1_1UnsteadySolver.html#aaa84acc193756038a9a9361d687f877e">libMesh::UnsteadySolver::old_local_nonlinear_solution</a></div><div class="ttdeci">std::shared_ptr&lt; NumericVector&lt; Number &gt; &gt; old_local_nonlinear_solution</div><div class="ttdoc">Serial vector of _system.get_vector(&amp;quot;_old_nonlinear_solution&amp;quot;) This is a shared_ptr so that it can be...</div><div class="ttdef"><b>Definition:</b> <a href="unsteady__solver_8h_source.html#l00178">unsteady_solver.h:178</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a2398b253d3fd1ec124777c4cbb6ba6c0"><div class="ttname"><a href="classlibMesh_1_1System.html#a2398b253d3fd1ec124777c4cbb6ba6c0">libMesh::System::get_vector</a></div><div class="ttdeci">const NumericVector&lt; Number &gt; &amp; get_vector(std::string_view vec_name) const </div><div class="ttdef"><b>Definition:</b> <a href="system_8C_source.html#l00917">system.C:917</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofMap_html_a31c127241d3271719ede3d0a6902e9e4"><div class="ttname"><a href="classlibMesh_1_1DofMap.html#a31c127241d3271719ede3d0a6902e9e4">libMesh::DofMap::get_send_list</a></div><div class="ttdeci">const std::vector&lt; dof_id_type &gt; &amp; get_send_list() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__map_8h_source.html#l00511">dof_map.h:511</a></div></div>
<div class="ttc" id="classlibMesh_1_1NumericVector_html_a7348b5b027adf716016354847e0df0b6"><div class="ttname"><a href="classlibMesh_1_1NumericVector.html#a7348b5b027adf716016354847e0df0b6">libMesh::NumericVector::localize</a></div><div class="ttdeci">virtual void localize(std::vector&lt; T &gt; &amp;v_local) const =0</div><div class="ttdoc">创建全局向量的副本并存储在本地向量 v_local 中。 </div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a class="anchor" id="a7c913252d05560f8bc7c75a63547c4c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#adb5daadc989c1fe71ec8d173adf0ed1e">ReferenceCounter::Counts</a> libMesh::ReferenceCounter::_counts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actually holds the data. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00124">124</a> 行定义.</p>

<p>参考自 <a class="el" href="reference__counter_8C_source.html#l00047">libMesh::ReferenceCounter::get_info()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cec9fe947573d455870bef253903946"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1DiffSolver.html">DiffSolver</a>&gt; libMesh::TimeSolver::_diff_solver</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An implicit linear or nonlinear solver to use at each timestep. </p>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00302">302</a> 行定义.</p>

<p>参考自 <a class="el" href="newmark__solver_8C_source.html#l00107">libMesh::NewmarkSolver::compute_initial_accel()</a>, <a class="el" href="time__solver_8h_source.html#l00220">libMesh::TimeSolver::diff_solver()</a> , 以及 <a class="el" href="unsteady__solver_8C_source.html#l00127">libMesh::UnsteadySolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f75e8a4a280f2c41636f2ae1307a311"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::ReferenceCounter::_enable_print_counter = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag to control whether reference count information is printed when print_info is called. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00143">143</a> 行定义.</p>

<p>参考自 <a class="el" href="reference__counter_8C_source.html#l00100">libMesh::ReferenceCounter::disable_print_counter_info()</a>, <a class="el" href="reference__counter_8C_source.html#l00094">libMesh::ReferenceCounter::enable_print_counter_info()</a> , 以及 <a class="el" href="reference__counter_8C_source.html#l00081">libMesh::ReferenceCounter::print_info()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e03ec65a4db32fa56daec851c5d73ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1LinearSolver.html">LinearSolver</a>&lt;<a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a>&gt; &gt; libMesh::TimeSolver::_linear_solver</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An implicit linear solver to use for adjoint problems. </p>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00307">307</a> 行定义.</p>

<p>参考自 <a class="el" href="time__solver_8h_source.html#l00225">libMesh::TimeSolver::linear_solver()</a> , 以及 <a class="el" href="time__solver_8C_source.html#l00054">libMesh::TimeSolver::reinit()</a>.</p>

</div>
</div>
<a class="anchor" id="abedbd3a4ce19686187449a8a0557b74b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1Threads_1_1spin__mutex.html">Threads::spin_mutex</a> libMesh::ReferenceCounter::_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutual exclusion object to enable thread-safe reference counting. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00137">137</a> 行定义.</p>

</div>
</div>
<a class="anchor" id="ad2c30f0f71dcd00f00faa8e46aa3e043"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1Threads_1_1atomic.html">Threads::atomic</a>&lt; unsigned int &gt; libMesh::ReferenceCounter::_n_objects</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of objects. </p>
<p>Print the reference count information when the number returns to 0. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00132">132</a> 行定义.</p>

<p>参考自 <a class="el" href="reference__counter_8h_source.html#l00085">libMesh::ReferenceCounter::n_objects()</a>, <a class="el" href="reference__counter_8h_source.html#l00150">libMesh::ReferenceCounter::ReferenceCounter()</a> , 以及 <a class="el" href="reference__counter_8h_source.html#l00171">libMesh::ReferenceCounter::~ReferenceCounter()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cf14c8b81127d014c49c45d88dfaf46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1TimeSolver.html#a4e7363e989661b62466ed602c1189f5a">sys_type</a>&amp; libMesh::TimeSolver::_system</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A reference to the system we are solving. </p>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00312">312</a> 行定义.</p>

<p>参考自 <a class="el" href="euler__solver_8C_source.html#l00102">libMesh::EulerSolver::_general_residual()</a>, <a class="el" href="euler2__solver_8C_source.html#l00103">libMesh::Euler2Solver::_general_residual()</a>, <a class="el" href="steady__solver_8C_source.html#l00068">libMesh::SteadySolver::_general_residual()</a>, <a class="el" href="newmark__solver_8C_source.html#l00203">libMesh::NewmarkSolver::_general_residual()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00126">adjoint_advance_timestep()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00239">libMesh::UnsteadySolver::adjoint_advance_timestep()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00298">libMesh::TwostepTimeSolver::adjoint_solve()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00228">libMesh::UnsteadySolver::adjoint_solve()</a>, <a class="el" href="time__solver_8C_source.html#l00133">libMesh::TimeSolver::adjoint_solve()</a>, <a class="el" href="newmark__solver_8C_source.html#l00044">libMesh::NewmarkSolver::advance_timestep()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00089">advance_timestep()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00192">libMesh::UnsteadySolver::advance_timestep()</a>, <a class="el" href="newmark__solver_8C_source.html#l00107">libMesh::NewmarkSolver::compute_initial_accel()</a>, <a class="el" href="first__order__unsteady__solver_8C_source.html#l00032">libMesh::FirstOrderUnsteadySolver::compute_second_order_eqns()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00348">libMesh::UnsteadySolver::du()</a>, <a class="el" href="euler__solver_8C_source.html#l00053">libMesh::EulerSolver::element_residual()</a>, <a class="el" href="euler2__solver_8C_source.html#l00054">libMesh::Euler2Solver::element_residual()</a>, <a class="el" href="eigen__time__solver_8C_source.html#l00123">libMesh::EigenTimeSolver::element_residual()</a>, <a class="el" href="second__order__unsteady__solver_8C_source.html#l00034">libMesh::SecondOrderUnsteadySolver::init()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00060">libMesh::UnsteadySolver::init()</a>, <a class="el" href="time__solver_8C_source.html#l00072">libMesh::TimeSolver::init()</a>, <a class="el" href="eigen__time__solver_8C_source.html#l00055">libMesh::EigenTimeSolver::init()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00068">libMesh::UnsteadySolver::init_adjoints()</a>, <a class="el" href="time__solver_8C_source.html#l00083">libMesh::TimeSolver::init_adjoints()</a>, <a class="el" href="second__order__unsteady__solver_8C_source.html#l00042">libMesh::SecondOrderUnsteadySolver::init_data()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00089">libMesh::UnsteadySolver::init_data()</a>, <a class="el" href="time__solver_8C_source.html#l00097">libMesh::TimeSolver::init_data()</a>, <a class="el" href="euler2__solver_8C_source.html#l00322">libMesh::Euler2Solver::integrate_adjoint_refinement_error_estimate()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00400">libMesh::TwostepTimeSolver::integrate_adjoint_refinement_error_estimate()</a>, <a class="el" href="euler__solver_8C_source.html#l00254">libMesh::EulerSolver::integrate_adjoint_refinement_error_estimate()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00377">libMesh::TwostepTimeSolver::integrate_adjoint_sensitivity()</a>, <a class="el" href="steady__solver_8C_source.html#l00103">libMesh::SteadySolver::integrate_adjoint_sensitivity()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00280">libMesh::UnsteadySolver::integrate_adjoint_sensitivity()</a>, <a class="el" href="euler2__solver_8C_source.html#l00264">libMesh::Euler2Solver::integrate_qoi_timestep()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00341">libMesh::TwostepTimeSolver::integrate_qoi_timestep()</a>, <a class="el" href="euler__solver_8C_source.html#l00196">libMesh::EulerSolver::integrate_qoi_timestep()</a>, <a class="el" href="steady__solver_8C_source.html#l00096">libMesh::SteadySolver::integrate_qoi_timestep()</a>, <a class="el" href="euler__solver_8C_source.html#l00085">libMesh::EulerSolver::nonlocal_residual()</a>, <a class="el" href="euler2__solver_8C_source.html#l00086">libMesh::Euler2Solver::nonlocal_residual()</a>, <a class="el" href="eigen__time__solver_8C_source.html#l00217">libMesh::EigenTimeSolver::nonlocal_residual()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00337">libMesh::UnsteadySolver::old_nonlinear_solution()</a>, <a class="el" href="second__order__unsteady__solver_8C_source.html#l00116">libMesh::SecondOrderUnsteadySolver::old_solution_accel()</a>, <a class="el" href="second__order__unsteady__solver_8C_source.html#l00107">libMesh::SecondOrderUnsteadySolver::old_solution_rate()</a>, <a class="el" href="newmark__solver_8C_source.html#l00133">libMesh::NewmarkSolver::project_initial_accel()</a>, <a class="el" href="second__order__unsteady__solver_8C_source.html#l00098">libMesh::SecondOrderUnsteadySolver::project_initial_rate()</a>, <a class="el" href="second__order__unsteady__solver_8C_source.html#l00060">libMesh::SecondOrderUnsteadySolver::reinit()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00104">libMesh::UnsteadySolver::reinit()</a>, <a class="el" href="time__solver_8C_source.html#l00054">libMesh::TimeSolver::reinit()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00269">libMesh::UnsteadySolver::retrieve_timestep()</a>, <a class="el" href="eigen__time__solver_8C_source.html#l00170">libMesh::EigenTimeSolver::side_residual()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00127">libMesh::UnsteadySolver::solve()</a>, <a class="el" href="eigen__time__solver_8C_source.html#l00067">libMesh::EigenTimeSolver::solve()</a>, <a class="el" href="time__solver_8h_source.html#l00210">libMesh::TimeSolver::system()</a> , 以及 <a class="el" href="unsteady__solver_8C_source.html#l00361">libMesh::UnsteadySolver::update()</a>.</p>

</div>
</div>
<a class="anchor" id="a3688a87be263c45e7db268869a54e1e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::AdaptiveTimeSolver::completed_timestep_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The adaptive time solver's have two notions of deltat. </p>
<p>The deltat the solver ended up using for the completed timestep. And the deltat the solver determined would be workable for the coming timestep. The latter gets set as system.deltat. We need a variable to save the deltat used for the completed timestep. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00205">205</a> 行定义.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00298">libMesh::TwostepTimeSolver::adjoint_solve()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00089">advance_timestep()</a>, <a class="el" href="adaptive__time__solver_8h_source.html#l00091">last_completed_timestep_size()</a> , 以及 <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a59a933b429ce060d4c14002db6245136"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> libMesh::AdaptiveTimeSolver::component_norm</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error calculations are done in this norm, DISCRETE_L2 by default. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00135">135</a> 行定义.</p>

<p>参考自 <a class="el" href="adaptive__time__solver_8C_source.html#l00225">calculate_norm()</a>.</p>

</div>
</div>
<a class="anchor" id="ad3e331379cc4db63ccc8f2cc59551dde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; libMesh::AdaptiveTimeSolver::component_scale</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If component_norms is non-empty, each variable's contribution to the error of a system will also be scaled by component_scale[var], unless component_scale is empty in which case all variables will be weighted equally. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00143">143</a> 行定义.</p>

</div>
</div>
<a class="anchor" id="a6cdd1f46101a1c62ee0fcabb4baeac8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1UnsteadySolver.html">UnsteadySolver</a>&gt; libMesh::AdaptiveTimeSolver::core_time_solver</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This object is used to take timesteps. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00130">130</a> 行定义.</p>

<p>参考自 <a class="el" href="adaptive__time__solver_8C_source.html#l00126">adjoint_advance_timestep()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00298">libMesh::TwostepTimeSolver::adjoint_solve()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00089">advance_timestep()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00211">diff_solver()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00181">element_residual()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00172">error_order()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00054">init()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00400">libMesh::TwostepTimeSolver::integrate_adjoint_refinement_error_estimate()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00377">libMesh::TwostepTimeSolver::integrate_adjoint_sensitivity()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00341">libMesh::TwostepTimeSolver::integrate_qoi_timestep()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00218">linear_solver()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00201">nonlocal_residual()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00079">reinit()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00165">retrieve_timestep()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00191">side_residual()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a> , 以及 <a class="el" href="twostep__time__solver_8C_source.html#l00040">libMesh::TwostepTimeSolver::TwostepTimeSolver()</a>.</p>

</div>
</div>
<a class="anchor" id="a437131696784e0e31a35315e3387c7b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::UnsteadySolver::first_adjoint_step</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A bool that will be true the first time <a class="el" href="classlibMesh_1_1UnsteadySolver.html#a18254c1c7119b509057383f084c906f2" title="This method advances the adjoint solution to the previous timestep, after an adjoint_solve() has been...">adjoint_advance_timestep()</a> is called, (when the primal solution is to be used to set adjoint boundary conditions) and false thereafter. </p>

<p>在文件 <a class="el" href="unsteady__solver_8h_source.html">unsteady_solver.h</a> 第 <a class="el" href="unsteady__solver_8h_source.html#l00226">226</a> 行定义.</p>

<p>参考自 <a class="el" href="adaptive__time__solver_8C_source.html#l00126">adjoint_advance_timestep()</a> , 以及 <a class="el" href="unsteady__solver_8h_source.html#l00199">libMesh::UnsteadySolver::set_first_adjoint_step()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5be0a1a2852028cc39b995b0d07bef6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::UnsteadySolver::first_solve</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A bool that will be true the first time <a class="el" href="classlibMesh_1_1UnsteadySolver.html#aad83b8429f49f336a0cbc1e044c7ab83" title="This method solves for the solution at the next timestep. ">solve()</a> is called, and false thereafter. </p>

<p>在文件 <a class="el" href="unsteady__solver_8h_source.html">unsteady_solver.h</a> 第 <a class="el" href="unsteady__solver_8h_source.html#l00220">220</a> 行定义.</p>

<p>参考自 <a class="el" href="newmark__solver_8C_source.html#l00044">libMesh::NewmarkSolver::advance_timestep()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00089">advance_timestep()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00192">libMesh::UnsteadySolver::advance_timestep()</a>, <a class="el" href="unsteady__solver_8h_source.html#l00209">libMesh::UnsteadySolver::set_first_solve()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a> , 以及 <a class="el" href="unsteady__solver_8C_source.html#l00127">libMesh::UnsteadySolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="accf5c408d7a99cb7d27a819404b85ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::AdaptiveTimeSolver::global_tolerance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This flag, which is true by default, grows (shrinks) the timestep based on the expected global accuracy of the timestepping scheme. </p>
<p>Global in this sense means the cumulative final-time accuracy of the scheme. For example, the backward Euler scheme's truncation error is locally of order 2, so that after N timesteps of size deltat, the result is first-order accurate. If you set this to false, you can grow (shrink) your timestep based on the local accuracy rather than the global accuracy of the core <a class="el" href="classlibMesh_1_1TimeSolver.html" title="This is a generic class that defines a solver to handle time integration of DifferentiableSystems. ">TimeSolver</a>.</p>
<dl class="section note"><dt>注解</dt><dd>By setting this value to false you may fail to achieve the predicted convergence in time of the underlying method, however it may be possible to get more fine-grained control over step sizes as well. </dd></dl>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00222">222</a> 行定义.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a80b025ebd4bdaaf60b3f2bcef91408a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::TimeSolver::last_deltat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The deltat for the last completed timestep before the current one. </p>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00332">332</a> 行定义.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00298">libMesh::TwostepTimeSolver::adjoint_solve()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00228">libMesh::UnsteadySolver::adjoint_solve()</a>, <a class="el" href="time__solver_8C_source.html#l00160">libMesh::TimeSolver::last_completed_timestep_size()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a> , 以及 <a class="el" href="unsteady__solver_8C_source.html#l00127">libMesh::UnsteadySolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="af7d9abb032bfe813f79db0c44d3cf40e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::UnsteadySolver::last_step_deltat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We will need to move the system.time around to ensure that residuals are built with the right deltat and the right time. </p>

<p>在文件 <a class="el" href="unsteady__solver_8h_source.html">unsteady_solver.h</a> 第 <a class="el" href="unsteady__solver_8h_source.html#l00237">237</a> 行定义.</p>

<p>参考自 <a class="el" href="euler2__solver_8C_source.html#l00322">libMesh::Euler2Solver::integrate_adjoint_refinement_error_estimate()</a> , 以及 <a class="el" href="euler__solver_8C_source.html#l00254">libMesh::EulerSolver::integrate_adjoint_refinement_error_estimate()</a>.</p>

</div>
</div>
<a class="anchor" id="a93b378583a8e5d6da9d1408a49b8a0a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::AdaptiveTimeSolver::max_deltat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not allow the adaptive time solver to select deltat &gt; max_deltat. </p>
<p>If you use the default max_deltat=0.0, then deltat is unlimited. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00183">183</a> 行定义.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="ada68f2f70960a70215aa8978105d9df2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::AdaptiveTimeSolver::max_growth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not allow the adaptive time solver to select a new deltat greater than max_growth times the old deltat. </p>
<p>If you use the default max_growth=0.0, then the deltat growth is unlimited. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00197">197</a> 行定义.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ef4f9c102adce5c8ef9cacab1b8cd7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::AdaptiveTimeSolver::min_deltat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not allow the adaptive time solver to select deltat &lt; min_deltat. </p>
<p>The default value is 0.0. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00189">189</a> 行定义.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c6c4c3cc9a4f677605bf74593a27509"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::UnsteadySolver::next_step_deltat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="unsteady__solver_8h_source.html">unsteady_solver.h</a> 第 <a class="el" href="unsteady__solver_8h_source.html#l00238">238</a> 行定义.</p>

<p>参考自 <a class="el" href="euler2__solver_8C_source.html#l00322">libMesh::Euler2Solver::integrate_adjoint_refinement_error_estimate()</a> , 以及 <a class="el" href="euler__solver_8C_source.html#l00254">libMesh::EulerSolver::integrate_adjoint_refinement_error_estimate()</a>.</p>

</div>
</div>
<a class="anchor" id="a001031a19a5f3ed4df851dc7b2ddbe1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt;<a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a>&gt; &gt; &gt; libMesh::UnsteadySolver::old_adjoints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A vector of pointers to vectors holding the adjoint solution at the last time step. </p>

<p>在文件 <a class="el" href="unsteady__solver_8h_source.html">unsteady_solver.h</a> 第 <a class="el" href="unsteady__solver_8h_source.html#l00231">231</a> 行定义.</p>

<p>参考自 <a class="el" href="euler2__solver_8C_source.html#l00322">libMesh::Euler2Solver::integrate_adjoint_refinement_error_estimate()</a>, <a class="el" href="euler__solver_8C_source.html#l00254">libMesh::EulerSolver::integrate_adjoint_refinement_error_estimate()</a> , 以及 <a class="el" href="unsteady__solver_8C_source.html#l00037">libMesh::UnsteadySolver::UnsteadySolver()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa84acc193756038a9a9361d687f877e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt;<a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a>&gt; &gt; libMesh::UnsteadySolver::old_local_nonlinear_solution</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serial vector of _system.get_vector("_old_nonlinear_solution") This is a shared_ptr so that it can be shared between different derived class instances, as in e.g. </p>
<p><a class="el" href="classlibMesh_1_1AdaptiveTimeSolver.html" title="This class wraps another UnsteadySolver derived class, and compares the results of timestepping with ...">AdaptiveTimeSolver</a>. </p>

<p>在文件 <a class="el" href="unsteady__solver_8h_source.html">unsteady_solver.h</a> 第 <a class="el" href="unsteady__solver_8h_source.html#l00178">178</a> 行定义.</p>

<p>参考自 <a class="el" href="adaptive__time__solver_8C_source.html#l00126">adjoint_advance_timestep()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00239">libMesh::UnsteadySolver::adjoint_advance_timestep()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00089">advance_timestep()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00192">libMesh::UnsteadySolver::advance_timestep()</a>, <a class="el" href="adaptive__time__solver_8C_source.html#l00054">init()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00089">libMesh::UnsteadySolver::init_data()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00337">libMesh::UnsteadySolver::old_nonlinear_solution()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00104">libMesh::UnsteadySolver::reinit()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00269">libMesh::UnsteadySolver::retrieve_timestep()</a> , 以及 <a class="el" href="unsteady__solver_8C_source.html#l00361">libMesh::UnsteadySolver::update()</a>.</p>

</div>
</div>
<a class="anchor" id="af0dff23f37925276a226b06b6f78c136"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::TimeSolver::quiet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print extra debugging information if quiet == false. </p>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00230">230</a> 行定义.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00127">libMesh::UnsteadySolver::solve()</a> , 以及 <a class="el" href="eigen__time__solver_8C_source.html#l00067">libMesh::EigenTimeSolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b77957719eae28de2e753d9a99d825e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libMesh::TimeSolver::reduce_deltat_on_diffsolver_failure</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This value (which defaults to zero) is the number of times the <a class="el" href="classlibMesh_1_1TimeSolver.html" title="This is a generic class that defines a solver to handle time integration of DifferentiableSystems. ">TimeSolver</a> is allowed to halve deltat and let the <a class="el" href="classlibMesh_1_1DiffSolver.html" title="This is a generic class that defines a solver to handle ImplicitSystem classes, including NonlinearIm...">DiffSolver</a> repeat the latest failed solve with a reduced timestep. </p>
<dl class="section note"><dt>注解</dt><dd>This has no effect for SteadySolvers. </dd>
<dd>
You must set at least one of the <a class="el" href="classlibMesh_1_1DiffSolver.html" title="This is a generic class that defines a solver to handle ImplicitSystem classes, including NonlinearIm...">DiffSolver</a> flags "continue_after_max_iterations" or "continue_after_backtrack_failure" to allow the <a class="el" href="classlibMesh_1_1TimeSolver.html" title="This is a generic class that defines a solver to handle time integration of DifferentiableSystems. ">TimeSolver</a> to retry the solve. </dd></dl>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00259">259</a> 行定义.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a> , 以及 <a class="el" href="unsteady__solver_8C_source.html#l00127">libMesh::UnsteadySolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7e23d6b0c8a4844fef98915a28c52d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1SolutionHistory.html">SolutionHistory</a>&gt; libMesh::TimeSolver::solution_history</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A std::unique_ptr to a <a class="el" href="classlibMesh_1_1SolutionHistory.html" title="A SolutionHistory class that enables the storage and retrieval of timesteps and (in the future) adapt...">SolutionHistory</a> object. </p>
<p>Default is <a class="el" href="classlibMesh_1_1NoSolutionHistory.html" title="&#39;Save nothing&#39; subclass of Solution History, this is the default. ">NoSolutionHistory</a>, which the user can override by declaring a different kind of <a class="el" href="classlibMesh_1_1SolutionHistory.html" title="A SolutionHistory class that enables the storage and retrieval of timesteps and (in the future) adapt...">SolutionHistory</a> in the application </p>

<p>在文件 <a class="el" href="time__solver_8h_source.html">time_solver.h</a> 第 <a class="el" href="time__solver_8h_source.html#l00319">319</a> 行定义.</p>

<p>参考自 <a class="el" href="unsteady__solver_8C_source.html#l00239">libMesh::UnsteadySolver::adjoint_advance_timestep()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00192">libMesh::UnsteadySolver::advance_timestep()</a>, <a class="el" href="time__solver_8C_source.html#l00124">libMesh::TimeSolver::get_solution_history()</a>, <a class="el" href="unsteady__solver_8C_source.html#l00269">libMesh::UnsteadySolver::retrieve_timestep()</a> , 以及 <a class="el" href="time__solver_8C_source.html#l00119">libMesh::TimeSolver::set_solution_history()</a>.</p>

</div>
</div>
<a class="anchor" id="aca9e4ce98150b7452299c990c6d13741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::AdaptiveTimeSolver::target_tolerance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This tolerance is the target relative error between an exact time integration and a single time step output, scaled by deltat. </p>
<p>integrator, scaled by deltat. If the estimated error exceeds or undershoots the target error tolerance, future timesteps will be run with deltat shrunk or grown to compensate.</p>
<p>The default value is 1.0e-2; obviously users should select their own tolerance.</p>
<p>If a <em>negative</em> target_tolerance is specified, then its absolute value is used to scale the estimated error from the first simulation time step, and this becomes the target tolerance of all future time steps. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00160">160</a> 行定义.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d15b5d216cbb6657055125da543c388"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> libMesh::AdaptiveTimeSolver::upper_tolerance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This tolerance is the maximum relative error between an exact time integration and a single time step output, scaled by deltat. </p>
<p>If this error tolerance is exceeded by the estimated error of the current time step, that time step will be repeated with a smaller deltat.</p>
<p>If you use the default upper_tolerance=0.0, then the current time step will not be repeated regardless of estimated error.</p>
<p>If a <em>negative</em> upper_tolerance is specified, then its absolute value is used to scale the estimated error from the first simulation time step, and this becomes the upper tolerance of all future time steps. </p>

<p>在文件 <a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a> 第 <a class="el" href="adaptive__time__solver_8h_source.html#l00177">177</a> 行定义.</p>

<p>参考自 <a class="el" href="twostep__time__solver_8C_source.html#l00054">libMesh::TwostepTimeSolver::solve()</a>.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>/home/lwz/libmesh/include/solvers/<a class="el" href="adaptive__time__solver_8h_source.html">adaptive_time_solver.h</a></li>
<li>/home/lwz/libmesh/src/solvers/<a class="el" href="adaptive__time__solver_8C_source.html">adaptive_time_solver.C</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2023年 十二月 20日 星期三 12:09:41 , 为 libmesh解析使用  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
