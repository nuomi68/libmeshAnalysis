<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libmesh解析: libMesh::LaplaceMeshSmoother类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libmesh解析
   </div>
   <div id="projectbrief">本工作只是尝试解析原libmesh的代码,供学习使用</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li class="current"><a href="annotated.html"><span>类</span></a></li>
      <li><a href="files.html"><span>文件</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>类列表</span></a></li>
      <li><a href="classes.html"><span>类索引</span></a></li>
      <li><a href="inherits.html"><span>类继承关系</span></a></li>
      <li><a href="functions.html"><span>类成员</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>全部</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>类</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>命名空间</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>文件</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>函数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>变量</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>类型定义</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>枚举</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>枚举值</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>友元</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>页</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html">LaplaceMeshSmoother</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pro-attribs">Protected 属性</a> &#124;
<a href="#pri-methods">Private 成员函数</a> &#124;
<a href="#pri-attribs">Private 属性</a> &#124;
<a href="classlibMesh_1_1LaplaceMeshSmoother-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::LaplaceMeshSmoother类 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class defines the data structures necessary for Laplace smoothing.  
 <a href="classlibMesh_1_1LaplaceMeshSmoother.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="mesh__smoother__laplace_8h_source.html">mesh_smoother_laplace.h</a>&gt;</code></p>
<div class="dynheader">
类 libMesh::LaplaceMeshSmoother 继承关系图:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a97ab924d65f154ce8b7fb79c4b48d3d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html#a97ab924d65f154ce8b7fb79c4b48d3d2">LaplaceMeshSmoother</a> (<a class="el" href="classlibMesh_1_1UnstructuredMesh.html">UnstructuredMesh</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:a97ab924d65f154ce8b7fb79c4b48d3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a97ab924d65f154ce8b7fb79c4b48d3d2">更多...</a><br/></td></tr>
<tr class="separator:a97ab924d65f154ce8b7fb79c4b48d3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81750497049153629e183400679fdf1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html#ad81750497049153629e183400679fdf1">~LaplaceMeshSmoother</a> ()=default</td></tr>
<tr class="memdesc:ad81750497049153629e183400679fdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ad81750497049153629e183400679fdf1">更多...</a><br/></td></tr>
<tr class="separator:ad81750497049153629e183400679fdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d15e48aeb03f4997c93ec4cef64276"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html#a76d15e48aeb03f4997c93ec4cef64276">smooth</a> () override</td></tr>
<tr class="memdesc:a76d15e48aeb03f4997c93ec4cef64276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redefinition of the smooth function from the base class.  <a href="#a76d15e48aeb03f4997c93ec4cef64276">更多...</a><br/></td></tr>
<tr class="separator:a76d15e48aeb03f4997c93ec4cef64276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5f1e8b782c38b3524b3b1f0e268e0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html#a1d5f1e8b782c38b3524b3b1f0e268e0a">smooth</a> (unsigned int n_iterations)</td></tr>
<tr class="memdesc:a1d5f1e8b782c38b3524b3b1f0e268e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual smoothing function, gets called whenever the user specifies an actual number of smoothing iterations.  <a href="#a1d5f1e8b782c38b3524b3b1f0e268e0a">更多...</a><br/></td></tr>
<tr class="separator:a1d5f1e8b782c38b3524b3b1f0e268e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623528543d038460e488e77bab010d33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html#a623528543d038460e488e77bab010d33">init</a> ()</td></tr>
<tr class="memdesc:a623528543d038460e488e77bab010d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for the Laplace smoothing routine is basically identical to building an "L-graph" which is expensive.  <a href="#a623528543d038460e488e77bab010d33">更多...</a><br/></td></tr>
<tr class="separator:a623528543d038460e488e77bab010d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc102c72ff54b8a39f141e518d15000f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html#acc102c72ff54b8a39f141e518d15000f">print_graph</a> (std::ostream &amp;out_stream=<a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a>) const </td></tr>
<tr class="memdesc:acc102c72ff54b8a39f141e518d15000f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mainly for debugging, this function will print out the connectivity graph which has been created.  <a href="#acc102c72ff54b8a39f141e518d15000f">更多...</a><br/></td></tr>
<tr class="separator:acc102c72ff54b8a39f141e518d15000f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected 属性</h2></td></tr>
<tr class="memitem:a23c08282a0f3088def89cd9c1c17fc4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1UnstructuredMesh.html">UnstructuredMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a></td></tr>
<tr class="separator:a23c08282a0f3088def89cd9c1c17fc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private 成员函数</h2></td></tr>
<tr class="memitem:aa7504c1cc6970866ffa24d4c9b203238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html#aa7504c1cc6970866ffa24d4c9b203238">allgather_graph</a> ()</td></tr>
<tr class="memdesc:aa7504c1cc6970866ffa24d4c9b203238"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allgather's the (local) graph after it is computed on each processor by the <a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html#a623528543d038460e488e77bab010d33" title="Initialization for the Laplace smoothing routine is basically identical to building an &quot;L-graph&quot; whic...">init()</a> function.  <a href="#aa7504c1cc6970866ffa24d4c9b203238">更多...</a><br/></td></tr>
<tr class="separator:aa7504c1cc6970866ffa24d4c9b203238"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private 属性</h2></td></tr>
<tr class="memitem:a607905beabcc58f01ff253b7873b2697"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html#a607905beabcc58f01ff253b7873b2697">_initialized</a></td></tr>
<tr class="memdesc:a607905beabcc58f01ff253b7873b2697"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the L-graph has been created, false otherwise.  <a href="#a607905beabcc58f01ff253b7873b2697">更多...</a><br/></td></tr>
<tr class="separator:a607905beabcc58f01ff253b7873b2697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114dd3fdcecda853eddf78f9956c1a3f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a></td></tr>
<tr class="memdesc:a114dd3fdcecda853eddf78f9956c1a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for holding the L-graph.  <a href="#a114dd3fdcecda853eddf78f9956c1a3f">更多...</a><br/></td></tr>
<tr class="separator:a114dd3fdcecda853eddf78f9956c1a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>This class defines the data structures necessary for Laplace smoothing. </p>
<dl class="section note"><dt>注解</dt><dd>This is a simple averaging smoother, which does <em>not</em> guarantee that points will be smoothed to valid locations, e.g. locations inside the boundary! This aspect could use work.</dd></dl>
<dl class="section author"><dt>作者</dt><dd>John W. Peterson </dd></dl>
<dl class="section date"><dt>日期</dt><dd>2002-2007 </dd></dl>

<p>在文件 <a class="el" href="mesh__smoother__laplace_8h_source.html">mesh_smoother_laplace.h</a> 第 <a class="el" href="mesh__smoother__laplace_8h_source.html#l00044">44</a> 行定义.</p>
</div><h2 class="groupheader">构造及析构函数说明</h2>
<a class="anchor" id="a97ab924d65f154ce8b7fb79c4b48d3d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::LaplaceMeshSmoother::LaplaceMeshSmoother </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1UnstructuredMesh.html">UnstructuredMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Sets the constant mesh reference in the protected data section of the class. </p>

<p>在文件 <a class="el" href="mesh__smoother__laplace_8C_source.html">mesh_smoother_laplace.C</a> 第 <a class="el" href="mesh__smoother__laplace_8C_source.html#l00037">37</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  : <a class="code" href="classlibMesh_1_1MeshSmoother.html#a5fb7ab286514c6eaef30f39db52cb50a">MeshSmoother</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>),</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a607905beabcc58f01ff253b7873b2697">_initialized</a>(<span class="keyword">false</span>)</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;{</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1LaplaceMeshSmoother_html_a607905beabcc58f01ff253b7873b2697"><div class="ttname"><a href="classlibMesh_1_1LaplaceMeshSmoother.html#a607905beabcc58f01ff253b7873b2697">libMesh::LaplaceMeshSmoother::_initialized</a></div><div class="ttdeci">bool _initialized</div><div class="ttdoc">True if the L-graph has been created, false otherwise. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother__laplace_8h_source.html#l00099">mesh_smoother_laplace.h:99</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshSmoother_html_a5fb7ab286514c6eaef30f39db52cb50a"><div class="ttname"><a href="classlibMesh_1_1MeshSmoother.html#a5fb7ab286514c6eaef30f39db52cb50a">libMesh::MeshSmoother::MeshSmoother</a></div><div class="ttdeci">MeshSmoother(UnstructuredMesh &amp;mesh)</div><div class="ttdoc">Constructor. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother_8h_source.html#l00046">mesh_smoother.h:46</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad81750497049153629e183400679fdf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual libMesh::LaplaceMeshSmoother::~LaplaceMeshSmoother </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a class="anchor" id="aa7504c1cc6970866ffa24d4c9b203238"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::LaplaceMeshSmoother::allgather_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function allgather's the (local) graph after it is computed on each processor by the <a class="el" href="classlibMesh_1_1LaplaceMeshSmoother.html#a623528543d038460e488e77bab010d33" title="Initialization for the Laplace smoothing routine is basically identical to building an &quot;L-graph&quot; whic...">init()</a> function. </p>

<p>在文件 <a class="el" href="mesh__smoother__laplace_8C_source.html">mesh_smoother_laplace.C</a> 第 <a class="el" href="mesh__smoother__laplace_8C_source.html#l00289">289</a> 行定义.</p>

<p>参考 <a class="el" href="mesh__smoother__laplace_8h_source.html#l00104">_graph</a>, <a class="el" href="mesh__smoother_8h_source.html#l00061">libMesh::MeshSmoother::_mesh</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">libMesh::MeshBase::max_node_id()</a> , 以及 <a class="el" href="parallel__object_8h_source.html#l00103">libMesh::ParallelObject::n_processors()</a>.</p>

<p>参考自 <a class="el" href="mesh__smoother__laplace_8C_source.html#l00159">init()</a>.</p>
<div class="fragment"><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;{</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  <span class="comment">// The graph data structure is not well-suited for parallel communication,</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  <span class="comment">// so copy the graph into a single vector defined by:</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  <span class="comment">// NA A_0 A_1 ... A_{NA} | NB B_0 B_1 ... B_{NB} | NC C_0 C_1 ... C_{NC}</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;  <span class="comment">// where:</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  <span class="comment">// * NA is the number of graph connections for node A</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  <span class="comment">// * A_0, A_1, etc. are the IDs connected to node A</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;  std::vector&lt;dof_id_type&gt; flat_graph;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  <span class="comment">// Reserve at least enough space for each node to have zero entries</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  flat_graph.reserve(<a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>.size());</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; id_vec : <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>)</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    {</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;      <span class="comment">// First push back the number of entries for this node</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;      flat_graph.push_back (cast_int&lt;dof_id_type&gt;(id_vec.size()));</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;      <span class="comment">// Then push back all the IDs</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; dof : id_vec)</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        flat_graph.push_back(dof);</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    }</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  <span class="comment">// // A copy of the flat graph (for printing only, delete me later)</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  <span class="comment">// std::vector&lt;unsigned&gt; copy_of_flat_graph(flat_graph);</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  <span class="comment">// Use the allgather routine to combine all the flat graphs on all processors</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>().allgather(flat_graph);</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  <span class="comment">// Now reconstruct _graph from the allgathered flat_graph.</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  <span class="comment">// // (Delete me later, the copy is just for printing purposes.)</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;  <span class="comment">// std::vector&lt;std::vector&lt;unsigned &gt;&gt; copy_of_graph(_graph);</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;  <span class="comment">// Make sure the old graph is cleared out</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;  _graph.clear();</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> max_node_id = <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">max_node_id</a>();</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  _graph.resize(max_node_id);</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  <span class="comment">// Our current position in the allgather&#39;d flat_graph</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  std::size_t cursor=0;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;  <span class="comment">// There are max_node_id * n_processors entries to read in total</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> n_procs = <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">n_processors</a>();</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> p = 0; p != n_procs; ++p)</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> node_ctr : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(max_node_id))</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;      {</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <span class="comment">// Read the number of entries for this node, move cursor</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        std::size_t n_entries = flat_graph[cursor++];</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="comment">// Reserve space for that many more entries, then push back</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        _graph[node_ctr].reserve(_graph[node_ctr].size() + n_entries);</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        <span class="comment">// Read all graph connections for this node, move the cursor each time</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        <span class="comment">// Note: there might be zero entries but that&#39;s fine</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="keywordflow">for</span> (std::size_t i=0; i&lt;n_entries; ++i)</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;          _graph[node_ctr].push_back(flat_graph[cursor++]);</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;      }</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;  <span class="comment">// // Print local graph to uniquely named file (debugging)</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  <span class="comment">// {</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;  <span class="comment">//   // Generate unique filename for this processor</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;  <span class="comment">//   std::ostringstream oss;</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;  <span class="comment">//   oss &lt;&lt; &quot;graph_filename_&quot; &lt;&lt; _mesh.processor_id() &lt;&lt; &quot;.txt&quot;;</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  <span class="comment">//   std::ofstream graph_stream(oss.str().c_str());</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;  <span class="comment">//   // Print the local non-flat graph</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  <span class="comment">//   std::swap(_graph, copy_of_graph);</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  <span class="comment">//   print_graph(graph_stream);</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  <span class="comment">//   // Print the (local) flat graph for verification</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  <span class="comment">//   for (const auto &amp; dof : copy_of_flat_graph)</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <span class="comment">//     graph_stream &lt;&lt; dof &lt;&lt; &quot; &quot;;</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  <span class="comment">//   graph_stream &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  <span class="comment">//   // Print the allgather&#39;d grap for verification</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;  <span class="comment">//   for (const auto &amp; dof : flat_graph)</span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;  <span class="comment">//     graph_stream &lt;&lt; dof &lt;&lt; &quot; &quot;;</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  <span class="comment">//   graph_stream &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  <span class="comment">//   // Print the global non-flat graph</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  <span class="comment">//   std::swap(_graph, copy_of_graph);</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  <span class="comment">//   print_graph(graph_stream);</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <span class="comment">// }</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;} <span class="comment">// allgather_graph()</span></div>
<div class="ttc" id="classlibMesh_1_1LaplaceMeshSmoother_html_a114dd3fdcecda853eddf78f9956c1a3f"><div class="ttname"><a href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">libMesh::LaplaceMeshSmoother::_graph</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; dof_id_type &gt; &gt; _graph</div><div class="ttdoc">Data structure for holding the L-graph. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother__laplace_8h_source.html#l00104">mesh_smoother_laplace.h:104</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a50719f74165b613ab929afd29b6d5f4a"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">libMesh::ParallelObject::n_processors</a></div><div class="ttdeci">processor_id_type n_processors() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00103">parallel_object.h:103</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshSmoother_html_a23c08282a0f3088def89cd9c1c17fc4a"><div class="ttname"><a href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">libMesh::MeshSmoother::_mesh</a></div><div class="ttdeci">UnstructuredMesh &amp; _mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother_8h_source.html#l00061">mesh_smoother.h:61</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af18245d4f872c36a41fc74086bda3e80"><div class="ttname"><a href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00104">id_types.h:104</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a613704304440df6ceafa622096befe68"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">libMesh::MeshBase::max_node_id</a></div><div class="ttdeci">virtual dof_id_type max_node_id() const =0</div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a623528543d038460e488e77bab010d33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::LaplaceMeshSmoother::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization for the Laplace smoothing routine is basically identical to building an "L-graph" which is expensive. </p>
<p>It's provided separately from the constructor since you may or may not want to build the L-graph on construction. </p>

<p>在文件 <a class="el" href="mesh__smoother__laplace_8C_source.html">mesh_smoother_laplace.C</a> 第 <a class="el" href="mesh__smoother__laplace_8C_source.html#l00159">159</a> 行定义.</p>

<p>参考 <a class="el" href="mesh__smoother__laplace_8h_source.html#l00104">_graph</a>, <a class="el" href="mesh__smoother__laplace_8h_source.html#l00099">_initialized</a>, <a class="el" href="mesh__smoother_8h_source.html#l00061">libMesh::MeshSmoother::_mesh</a>, <a class="el" href="mesh__smoother__laplace_8C_source.html#l00289">allgather_graph()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">libMesh::MeshBase::max_node_id()</a>, <a class="el" href="mesh__base_8C_source.html#l00322">libMesh::MeshBase::mesh_dimension()</a>, <a class="el" href="elem_8h_source.html#l02275">libMesh::Elem::node_id()</a>, <a class="el" href="parallel__object_8h_source.html#l00114">libMesh::ParallelObject::processor_id()</a> , 以及 <a class="el" href="elem_8h_source.html#l02486">libMesh::Elem::side_index_range()</a>.</p>

<p>参考自 <a class="el" href="mesh__smoother__laplace_8C_source.html#l00046">smooth()</a>.</p>
<div class="fragment"><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;{</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  <span class="comment">// For avoiding extraneous element side construction</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  ElemSideBuilder side_builder;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  <span class="keywordflow">switch</span> (<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a1bc787d29f4c496f107aed988be4b9bf">mesh_dimension</a>())</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;      <span class="comment">// TODO:[BSK] Fix this to work for refined meshes...  I think</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;      <span class="comment">// the implementation was done quickly for Damien, who did not have</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;      <span class="comment">// refined grids.  Fix it here and in the original Mesh member.</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keywordflow">case</span> 2: <span class="comment">// Stolen directly from build_L_graph in mesh_base.C</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;      {</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        <span class="comment">// Initialize space in the graph.  It is indexed by node id.</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="comment">// Each node may be connected to an arbitrary number of other</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="comment">// nodes via edges.</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>.resize(<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">max_node_id</a>());</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        <span class="keyword">auto</span> elem_to_graph =</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;          [<span class="keyword">this</span>, &amp;side_builder](<span class="keyword">const</span> Elem &amp; elem) {</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">auto</span> s : elem.side_index_range())</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            {</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;              <span class="comment">// Only operate on sides which are on the</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;              <span class="comment">// boundary or for which the current element&#39;s</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;              <span class="comment">// id is greater than its neighbor&#39;s.</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;              <span class="comment">// Sides get only built once.</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;              <span class="keywordflow">if</span> ((elem.neighbor_ptr(s) == <span class="keyword">nullptr</span>) ||</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                  (elem.id() &gt; elem.neighbor_ptr(s)-&gt;id()))</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                {</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                  <span class="keyword">const</span> Elem &amp; side = side_builder(elem, s);</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                  <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>[side.node_id(0)].push_back(side.node_id(1));</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                  <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>[side.node_id(1)].push_back(side.node_id(0));</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                }</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            }</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        };</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.active_local_element_ptr_range())</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;          elem_to_graph(*elem);</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">processor_id</a>())</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.active_unpartitioned_element_ptr_range())</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            elem_to_graph(*elem);</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a607905beabcc58f01ff253b7873b2697">_initialized</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      } <span class="comment">// case 2</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keywordflow">case</span> 3: <span class="comment">// Stolen blatantly from build_L_graph in mesh_base.C</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        <span class="comment">// Extra builder for the face elements</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        ElemSideBuilder face_builder;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        <span class="comment">// Initialize space in the graph.</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>.resize(<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">max_node_id</a>());</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <span class="keyword">auto</span> elem_to_graph =</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;          [<span class="keyword">this</span>, &amp;side_builder, &amp;face_builder](<span class="keyword">const</span> Elem &amp; elem) {</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">auto</span> f : elem.side_index_range()) <span class="comment">// Loop over faces</span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            <span class="keywordflow">if</span> ((elem.neighbor_ptr(f) == <span class="keyword">nullptr</span>) ||</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                (elem.id() &gt; elem.neighbor_ptr(f)-&gt;id()))</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;              {</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                <span class="keyword">const</span> Elem &amp; face = face_builder(elem, f);</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> s : face.side_index_range()) <span class="comment">// Loop over face&#39;s edges</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                  {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                    <span class="keyword">const</span> Elem &amp; side = side_builder(face, s);</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                    <span class="comment">// At this point, we just insert the node numbers</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                    <span class="comment">// again.  At the end we&#39;ll call sort and unique</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                    <span class="comment">// to make sure there are no duplicates</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                    <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>[side.node_id(0)].push_back(side.node_id(1));</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                    <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>[side.node_id(1)].push_back(side.node_id(0));</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                  }</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;              }</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        };</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.active_local_element_ptr_range())</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;          elem_to_graph(*elem);</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">processor_id</a>())</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.active_unpartitioned_element_ptr_range())</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            elem_to_graph(*elem);</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a607905beabcc58f01ff253b7873b2697">_initialized</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;      } <span class="comment">// case 3</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      libmesh_error_msg(<span class="stringliteral">&quot;At this time it is not possible to smooth a dimension &quot;</span> &lt;&lt; <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a1bc787d29f4c496f107aed988be4b9bf">mesh_dimension</a>() &lt;&lt; <span class="stringliteral">&quot;mesh.  Aborting...&quot;</span>);</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    }</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  <span class="comment">// Done building graph from local and/or unpartitioned elements.</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <span class="comment">// Let&#39;s now allgather the graph so that it is available on all</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  <span class="comment">// processors for the actual smoothing operation.</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#aa7504c1cc6970866ffa24d4c9b203238">allgather_graph</a>();</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  <span class="comment">// In 3D, it&#39;s possible for &gt; 2 processor partitions to meet</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  <span class="comment">// at a single edge, while in 2D only 2 processor partitions</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  <span class="comment">// share an edge.  Therefore the allgather&#39;d graph in 3D may</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  <span class="comment">// now have duplicate entries and we need to remove them so</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  <span class="comment">// they don&#39;t foul up the averaging algorithm employed by the</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  <span class="comment">// Laplace smoother.</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; id_vec : <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>)</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    {</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;      <span class="comment">// The std::unique algorithm removes duplicate *consecutive* elements from a range,</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;      <span class="comment">// so it only makes sense to call it on a sorted range...</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;      std::sort(id_vec.begin(), id_vec.end());</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;      id_vec.erase(std::unique(id_vec.begin(), id_vec.end()), id_vec.end());</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    }</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;} <span class="comment">// init()</span></div>
<div class="ttc" id="classlibMesh_1_1LaplaceMeshSmoother_html_a114dd3fdcecda853eddf78f9956c1a3f"><div class="ttname"><a href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">libMesh::LaplaceMeshSmoother::_graph</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; dof_id_type &gt; &gt; _graph</div><div class="ttdoc">Data structure for holding the L-graph. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother__laplace_8h_source.html#l00104">mesh_smoother_laplace.h:104</a></div></div>
<div class="ttc" id="classlibMesh_1_1LaplaceMeshSmoother_html_a607905beabcc58f01ff253b7873b2697"><div class="ttname"><a href="classlibMesh_1_1LaplaceMeshSmoother.html#a607905beabcc58f01ff253b7873b2697">libMesh::LaplaceMeshSmoother::_initialized</a></div><div class="ttdeci">bool _initialized</div><div class="ttdoc">True if the L-graph has been created, false otherwise. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother__laplace_8h_source.html#l00099">mesh_smoother_laplace.h:99</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshSmoother_html_a23c08282a0f3088def89cd9c1c17fc4a"><div class="ttname"><a href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">libMesh::MeshSmoother::_mesh</a></div><div class="ttdeci">UnstructuredMesh &amp; _mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother_8h_source.html#l00061">mesh_smoother.h:61</a></div></div>
<div class="ttc" id="classlibMesh_1_1LaplaceMeshSmoother_html_aa7504c1cc6970866ffa24d4c9b203238"><div class="ttname"><a href="classlibMesh_1_1LaplaceMeshSmoother.html#aa7504c1cc6970866ffa24d4c9b203238">libMesh::LaplaceMeshSmoother::allgather_graph</a></div><div class="ttdeci">void allgather_graph()</div><div class="ttdoc">This function allgather&amp;#39;s the (local) graph after it is computed on each processor by the init() func...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother__laplace_8C_source.html#l00289">mesh_smoother_laplace.C:289</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a1bc787d29f4c496f107aed988be4b9bf"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a1bc787d29f4c496f107aed988be4b9bf">libMesh::MeshBase::mesh_dimension</a></div><div class="ttdeci">unsigned int mesh_dimension() const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8C_source.html#l00322">mesh_base.C:322</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a613704304440df6ceafa622096befe68"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">libMesh::MeshBase::max_node_id</a></div><div class="ttdeci">virtual dof_id_type max_node_id() const =0</div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_ae1e7d1a1118f63d9889a761c27433bbc"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">libMesh::ParallelObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00114">parallel_object.h:114</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acc102c72ff54b8a39f141e518d15000f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::LaplaceMeshSmoother::print_graph </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em> = <code><a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mainly for debugging, this function will print out the connectivity graph which has been created. </p>

<p>在文件 <a class="el" href="mesh__smoother__laplace_8C_source.html">mesh_smoother_laplace.C</a> 第 <a class="el" href="mesh__smoother__laplace_8C_source.html#l00275">275</a> 行定义.</p>

<p>参考 <a class="el" href="mesh__smoother__laplace_8h_source.html#l00104">_graph</a> , 以及 <a class="el" href="int__range_8h_source.html#l00111">libMesh::index_range()</a>.</p>
<div class="fragment"><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;{</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : <a class="code" href="namespacelibMesh.html#a26e38c0dc87c05a5e8df7e26bfed543b">index_range</a>(<a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>))</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    {</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;      out_stream &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;      std::copy(<a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>[i].begin(),</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>[i].end(),</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                std::ostream_iterator&lt;unsigned&gt;(out_stream, <span class="stringliteral">&quot; &quot;</span>));</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;      out_stream &lt;&lt; std::endl;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    }</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1LaplaceMeshSmoother_html_a114dd3fdcecda853eddf78f9956c1a3f"><div class="ttname"><a href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">libMesh::LaplaceMeshSmoother::_graph</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; dof_id_type &gt; &gt; _graph</div><div class="ttdoc">Data structure for holding the L-graph. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother__laplace_8h_source.html#l00104">mesh_smoother_laplace.h:104</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26e38c0dc87c05a5e8df7e26bfed543b"><div class="ttname"><a href="namespacelibMesh.html#a26e38c0dc87c05a5e8df7e26bfed543b">libMesh::index_range</a></div><div class="ttdeci">auto index_range(const T &amp;sizable)</div><div class="ttdoc">Helper function that returns an IntRange&amp;lt;std::size_t&amp;gt; representing all the indices of the passed-in v...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00111">int_range.h:111</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a76d15e48aeb03f4997c93ec4cef64276"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::LaplaceMeshSmoother::smooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redefinition of the smooth function from the base class. </p>
<p>All this does is call the smooth function in this class which takes an int, using a default value of 1. </p>

<p>实现了 <a class="el" href="classlibMesh_1_1MeshSmoother.html#ac40efe20a344e22f9de4afb258e8b721">libMesh::MeshSmoother</a>.</p>

<p>在文件 <a class="el" href="mesh__smoother__laplace_8h_source.html">mesh_smoother_laplace.h</a> 第 <a class="el" href="mesh__smoother__laplace_8h_source.html#l00065">65</a> 行定义.</p>

<p>参考 <a class="el" href="mesh__smoother__laplace_8h_source.html#l00065">smooth()</a>.</p>

<p>参考自 <a class="el" href="mesh__smoother__laplace_8h_source.html#l00065">smooth()</a>, <a class="el" href="mesh__triangle__interface_8C_source.html#l00058">libMesh::TriangleInterface::triangulate()</a> , 以及 <a class="el" href="poly2tri__triangulator_8C_source.html#l00368">libMesh::Poly2TriTriangulator::triangulate()</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;{ this-&gt;<a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a76d15e48aeb03f4997c93ec4cef64276">smooth</a>(1); }</div>
<div class="ttc" id="classlibMesh_1_1LaplaceMeshSmoother_html_a76d15e48aeb03f4997c93ec4cef64276"><div class="ttname"><a href="classlibMesh_1_1LaplaceMeshSmoother.html#a76d15e48aeb03f4997c93ec4cef64276">libMesh::LaplaceMeshSmoother::smooth</a></div><div class="ttdeci">virtual void smooth() override</div><div class="ttdoc">Redefinition of the smooth function from the base class. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother__laplace_8h_source.html#l00065">mesh_smoother_laplace.h:65</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1d5f1e8b782c38b3524b3b1f0e268e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::LaplaceMeshSmoother::smooth </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_iterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actual smoothing function, gets called whenever the user specifies an actual number of smoothing iterations. </p>

<p>在文件 <a class="el" href="mesh__smoother__laplace_8C_source.html">mesh_smoother_laplace.C</a> 第 <a class="el" href="mesh__smoother__laplace_8C_source.html#l00046">46</a> 行定义.</p>

<p>参考 <a class="el" href="mesh__smoother__laplace_8h_source.html#l00104">_graph</a>, <a class="el" href="mesh__smoother__laplace_8h_source.html#l00099">_initialized</a>, <a class="el" href="mesh__smoother_8h_source.html#l00061">libMesh::MeshSmoother::_mesh</a>, <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l00536">libMesh::MeshTools::find_block_boundary_nodes()</a>, <a class="el" href="mesh__tools_8C_source.html#l00516">libMesh::MeshTools::find_boundary_nodes()</a>, <a class="el" href="mesh__smoother__laplace_8C_source.html#l00159">init()</a>, <a class="el" href="dof__object_8h_source.html#l00488">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">libMesh::MeshBase::max_node_id()</a>, <a class="el" href="mesh__base_8h_source.html#l00571">libMesh::MeshBase::node_ref()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a00e863731129afaba604816c2db55aed">libMesh::MeshBase::point()</a>, <a class="el" href="libmesh__common_8h_source.html#l00143">libMesh::Real</a> , 以及 <a class="el" href="parallel__ghost__sync_8h_source.html#l00357">libMesh::Parallel::sync_dofobject_data_by_id()</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;{</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a607905beabcc58f01ff253b7873b2697">_initialized</a>)</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    this-&gt;<a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a623528543d038460e488e77bab010d33">init</a>();</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="comment">// Don&#39;t smooth the nodes on the boundary...</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  <span class="comment">// this would change the mesh geometry which</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <span class="comment">// is probably not something we want!</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  <span class="keyword">auto</span> on_boundary = <a class="code" href="namespacelibMesh_1_1MeshTools.html#adc51a523820ddc6f28c86b9b9960de72">MeshTools::find_boundary_nodes</a>(<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="comment">// Also: don&#39;t smooth block boundary nodes</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="keyword">auto</span> on_block_boundary = <a class="code" href="namespacelibMesh_1_1MeshTools.html#ac4148ded591e8ed8efe2e7ec918e30ff">MeshTools::find_block_boundary_nodes</a>(<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="comment">// Merge them</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  on_boundary.insert(on_block_boundary.begin(), on_block_boundary.end());</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="comment">// We can only update the nodes after all new positions were</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  <span class="comment">// determined. We store the new positions here</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  std::vector&lt;Point&gt; new_positions;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n=0; n&lt;n_iterations; n++)</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    {</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;      new_positions.resize(<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">max_node_id</a>());</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;      <span class="keyword">auto</span> calculate_new_position = [<span class="keyword">this</span>, &amp;on_boundary, &amp;new_positions](<span class="keyword">const</span> Node * node) {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="comment">// leave the boundary intact</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <span class="comment">// Only relocate the nodes which are vertices of an element</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="comment">// All other entries of _graph (the secondary nodes) are empty</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <span class="keywordflow">if</span> (!on_boundary.count(node-&gt;id()) &amp;&amp; (<a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>[node-&gt;id()].size() &gt; 0))</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;          {</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            Point avg_position(0.,0.,0.);</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; connected_id : <a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>[node-&gt;id()])</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;              {</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                <span class="comment">// Will these nodal positions always be available</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                <span class="comment">// or will they refer to remote nodes?  This will</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                <span class="comment">// fail an assertion in the latter case, which</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                <span class="comment">// shouldn&#39;t occur if DistributedMesh is working</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                <span class="comment">// correctly.</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                <span class="keyword">const</span> Point &amp; connected_node = <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a00e863731129afaba604816c2db55aed">point</a>(connected_id);</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                avg_position.add( connected_node );</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;              } <span class="comment">// end for (j)</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            <span class="comment">// Compute the average, store in the new_positions vector</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;            new_positions[node-&gt;id()] = avg_position / <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a><span class="keyword">&gt;</span>(<a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>[node-&gt;id()].size());</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;          } <span class="comment">// end if</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;      };</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      <span class="comment">// calculate new node positions (local and unpartitioned nodes only)</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.local_node_ptr_range())</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        calculate_new_position(node);</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.pid_nodes_begin(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>),</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                                  <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.pid_nodes_end(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>)))</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        calculate_new_position(node);</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;      <span class="comment">// now update the node positions (local and unpartitioned nodes only)</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.local_node_ptr_range())</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="keywordflow">if</span> (!on_boundary.count(node-&gt;id()) &amp;&amp; (<a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>[node-&gt;id()].size() &gt; 0))</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;          *node = new_positions[node-&gt;id()];</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.pid_nodes_begin(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>),</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                                  <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.pid_nodes_end(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>)))</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        <span class="keywordflow">if</span> (!on_boundary.count(node-&gt;id()) &amp;&amp; (<a class="code" href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">_graph</a>[node-&gt;id()].size() &gt; 0))</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;          *node = new_positions[node-&gt;id()];</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;      <span class="comment">// Now the nodes which are ghosts on this processor may have been moved on</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;      <span class="comment">// the processors which own them.  So we need to synchronize with our neighbors</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;      <span class="comment">// and get the most up-to-date positions for the ghosts.</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;      SyncNodalPositions sync_object(<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>);</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;      <a class="code" href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">Parallel::sync_dofobject_data_by_id</a></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        (<a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>(), <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.nodes_begin(), <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.nodes_end(), sync_object);</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    } <span class="comment">// end for n_iterations</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  <span class="comment">// finally adjust the second order nodes (those located between vertices)</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  <span class="comment">// these nodes will be located between their adjacent nodes</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="comment">// do this element-wise</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.active_element_ptr_range())</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;      <span class="comment">// get the second order nodes (son)</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;      <span class="comment">// their element indices start at n_vertices and go to n_nodes</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> son_begin = elem-&gt;n_vertices();</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> son_end   = elem-&gt;n_nodes();</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;      <span class="comment">// loop over all second order nodes (son)</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> son=son_begin; son&lt;son_end; son++)</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        {</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;          <span class="comment">// Don&#39;t smooth second-order nodes which are on the boundary</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;          <span class="keywordflow">if</span> (!on_boundary.count(elem-&gt;node_id(son)))</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            {</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_adjacent_vertices =</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                elem-&gt;n_second_order_adjacent_vertices(son);</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;              <span class="comment">// calculate the new position which is the average of the</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;              <span class="comment">// position of the adjacent vertices</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;              Point avg_position(0,0,0);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;n_adjacent_vertices; v++)</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                avg_position +=</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                  <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a00e863731129afaba604816c2db55aed">point</a>( elem-&gt;node_id( elem-&gt;second_order_adjacent_vertex(son,v) ) );</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;              <a class="code" href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">node_ref</a>(elem-&gt;node_id(son)) = avg_position / n_adjacent_vertices;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            }</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        }</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    }</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1LaplaceMeshSmoother_html_a114dd3fdcecda853eddf78f9956c1a3f"><div class="ttname"><a href="classlibMesh_1_1LaplaceMeshSmoother.html#a114dd3fdcecda853eddf78f9956c1a3f">libMesh::LaplaceMeshSmoother::_graph</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; dof_id_type &gt; &gt; _graph</div><div class="ttdoc">Data structure for holding the L-graph. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother__laplace_8h_source.html#l00104">mesh_smoother_laplace.h:104</a></div></div>
<div class="ttc" id="classlibMesh_1_1LaplaceMeshSmoother_html_a607905beabcc58f01ff253b7873b2697"><div class="ttname"><a href="classlibMesh_1_1LaplaceMeshSmoother.html#a607905beabcc58f01ff253b7873b2697">libMesh::LaplaceMeshSmoother::_initialized</a></div><div class="ttdeci">bool _initialized</div><div class="ttdoc">True if the L-graph has been created, false otherwise. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother__laplace_8h_source.html#l00099">mesh_smoother_laplace.h:99</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_af6e7cea860ccee9625012f9fcb0ae13b"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">libMesh::MeshBase::node_ref</a></div><div class="ttdeci">virtual const Node &amp; node_ref(const dof_id_type i) const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00571">mesh_base.h:571</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ac4148ded591e8ed8efe2e7ec918e30ff"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ac4148ded591e8ed8efe2e7ec918e30ff">libMesh::MeshTools::find_block_boundary_nodes</a></div><div class="ttdeci">std::unordered_set&lt; dof_id_type &gt; find_block_boundary_nodes(const MeshBase &amp;mesh)</div><div class="ttdoc">Returns a std::set containing Node IDs for all of the block boundary nodes. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00536">mesh_tools.C:536</a></div></div>
<div class="ttc" id="classlibMesh_1_1LaplaceMeshSmoother_html_a623528543d038460e488e77bab010d33"><div class="ttname"><a href="classlibMesh_1_1LaplaceMeshSmoother.html#a623528543d038460e488e77bab010d33">libMesh::LaplaceMeshSmoother::init</a></div><div class="ttdeci">void init()</div><div class="ttdoc">Initialization for the Laplace smoothing routine is basically identical to building an &amp;quot;L-graph&amp;quot; whic...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother__laplace_8C_source.html#l00159">mesh_smoother_laplace.C:159</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshSmoother_html_a23c08282a0f3088def89cd9c1c17fc4a"><div class="ttname"><a href="classlibMesh_1_1MeshSmoother.html#a23c08282a0f3088def89cd9c1c17fc4a">libMesh::MeshSmoother::_mesh</a></div><div class="ttdeci">UnstructuredMesh &amp; _mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoother_8h_source.html#l00061">mesh_smoother.h:61</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_adc51a523820ddc6f28c86b9b9960de72"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#adc51a523820ddc6f28c86b9b9960de72">libMesh::MeshTools::find_boundary_nodes</a></div><div class="ttdeci">std::unordered_set&lt; dof_id_type &gt; find_boundary_nodes(const MeshBase &amp;mesh)</div><div class="ttdoc">Calling this function on a 2D mesh will convert all the elements to triangles. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00516">mesh_tools.C:516</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdoc">An invalid processor_id to distinguish DoFs that have not been assigned to a processor. </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00488">dof_object.h:488</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a6775c045a6c8e84299b5467df9fc81ae"><div class="ttname"><a href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; IndexType &gt; as_range(const std::pair&lt; IndexType, IndexType &gt; &amp;p)</div><div class="ttdoc">Helper function that allows us to treat a homogenous pair as a range. </div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_ac7d4f06bb34625465942e6b8d10f135e"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">libMesh::Parallel::sync_dofobject_data_by_id</a></div><div class="ttdeci">void sync_dofobject_data_by_id(const Communicator &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</div><div class="ttdoc">Request data about a range of ghost dofobjects uniquely identified by their id. </div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00357">parallel_ghost_sync.h:357</a></div></div>
<div class="ttc" id="namespacelibMesh_html_aef28359fb4851abec08fc99cfbac118d"><div class="ttname"><a href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">libMesh::Real</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE Real</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00143">libmesh_common.h:143</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a00e863731129afaba604816c2db55aed"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a00e863731129afaba604816c2db55aed">libMesh::MeshBase::point</a></div><div class="ttdeci">virtual const Point &amp; point(const dof_id_type i) const =0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a613704304440df6ceafa622096befe68"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">libMesh::MeshBase::max_node_id</a></div><div class="ttdeci">virtual dof_id_type max_node_id() const =0</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a class="anchor" id="a114dd3fdcecda853eddf78f9956c1a3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>&gt; &gt; libMesh::LaplaceMeshSmoother::_graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data structure for holding the L-graph. </p>

<p>在文件 <a class="el" href="mesh__smoother__laplace_8h_source.html">mesh_smoother_laplace.h</a> 第 <a class="el" href="mesh__smoother__laplace_8h_source.html#l00104">104</a> 行定义.</p>

<p>参考自 <a class="el" href="mesh__smoother__laplace_8C_source.html#l00289">allgather_graph()</a>, <a class="el" href="mesh__smoother__laplace_8C_source.html#l00159">init()</a>, <a class="el" href="mesh__smoother__laplace_8C_source.html#l00275">print_graph()</a> , 以及 <a class="el" href="mesh__smoother__laplace_8C_source.html#l00046">smooth()</a>.</p>

</div>
</div>
<a class="anchor" id="a607905beabcc58f01ff253b7873b2697"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::LaplaceMeshSmoother::_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the L-graph has been created, false otherwise. </p>

<p>在文件 <a class="el" href="mesh__smoother__laplace_8h_source.html">mesh_smoother_laplace.h</a> 第 <a class="el" href="mesh__smoother__laplace_8h_source.html#l00099">99</a> 行定义.</p>

<p>参考自 <a class="el" href="mesh__smoother__laplace_8C_source.html#l00159">init()</a> , 以及 <a class="el" href="mesh__smoother__laplace_8C_source.html#l00046">smooth()</a>.</p>

</div>
</div>
<a class="anchor" id="a23c08282a0f3088def89cd9c1c17fc4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1UnstructuredMesh.html">UnstructuredMesh</a>&amp; libMesh::MeshSmoother::_mesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="mesh__smoother_8h_source.html">mesh_smoother.h</a> 第 <a class="el" href="mesh__smoother_8h_source.html#l00061">61</a> 行定义.</p>

<p>参考自 <a class="el" href="mesh__smoother__vsmoother_8C_source.html#l00531">libMesh::VariationalMeshSmoother::adjust_adapt_data()</a>, <a class="el" href="mesh__smoother__laplace_8C_source.html#l00289">allgather_graph()</a>, <a class="el" href="mesh__smoother__laplace_8C_source.html#l00159">init()</a>, <a class="el" href="mesh__smoother__vsmoother_8C_source.html#l03994">libMesh::VariationalMeshSmoother::metr_data_gen()</a>, <a class="el" href="mesh__smoother__vsmoother_8C_source.html#l00269">libMesh::VariationalMeshSmoother::readgr()</a>, <a class="el" href="mesh__smoother__laplace_8C_source.html#l00046">smooth()</a>, <a class="el" href="mesh__smoother__vsmoother_8C_source.html#l00126">libMesh::VariationalMeshSmoother::smooth()</a> , 以及 <a class="el" href="mesh__smoother__vsmoother_8C_source.html#l00223">libMesh::VariationalMeshSmoother::writegr()</a>.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>/home/lwz/libmesh/include/mesh/<a class="el" href="mesh__smoother__laplace_8h_source.html">mesh_smoother_laplace.h</a></li>
<li>/home/lwz/libmesh/src/mesh/<a class="el" href="mesh__smoother__laplace_8C_source.html">mesh_smoother_laplace.C</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2023年 十二月 20日 星期三 12:09:34 , 为 libmesh解析使用  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
