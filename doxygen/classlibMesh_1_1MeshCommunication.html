<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libmesh解析: libMesh::MeshCommunication类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libmesh解析
   </div>
   <div id="projectbrief">本工作只是尝试解析原libmesh的代码,供学习使用</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li class="current"><a href="annotated.html"><span>类</span></a></li>
      <li><a href="files.html"><span>文件</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>类列表</span></a></li>
      <li><a href="classes.html"><span>类索引</span></a></li>
      <li><a href="inherits.html"><span>类继承关系</span></a></li>
      <li><a href="functions.html"><span>类成员</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>全部</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>类</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>命名空间</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>文件</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>函数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>变量</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>类型定义</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>枚举</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>枚举值</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>友元</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>页</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1MeshCommunication.html">MeshCommunication</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="classlibMesh_1_1MeshCommunication-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::MeshCommunication类 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the <code><a class="el" href="classlibMesh_1_1MeshCommunication.html" title="This is the MeshCommunication class. ">MeshCommunication</a></code> class.  
 <a href="classlibMesh_1_1MeshCommunication.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="mesh__communication_8h_source.html">mesh_communication.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:af8e32501572c9e39d8d11114bbeca427"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#af8e32501572c9e39d8d11114bbeca427">MeshCommunication</a> ()=default</td></tr>
<tr class="memdesc:af8e32501572c9e39d8d11114bbeca427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#af8e32501572c9e39d8d11114bbeca427">更多...</a><br/></td></tr>
<tr class="separator:af8e32501572c9e39d8d11114bbeca427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2a38783ee81d78d70430ea6c74aaef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a2b2a38783ee81d78d70430ea6c74aaef">~MeshCommunication</a> ()=default</td></tr>
<tr class="memdesc:a2b2a38783ee81d78d70430ea6c74aaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a2b2a38783ee81d78d70430ea6c74aaef">更多...</a><br/></td></tr>
<tr class="separator:a2b2a38783ee81d78d70430ea6c74aaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f46dad6159d846d8e6c90a9cfe3cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a227f46dad6159d846d8e6c90a9cfe3cb">clear</a> ()</td></tr>
<tr class="memdesc:a227f46dad6159d846d8e6c90a9cfe3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all data structures and resets to a pristine state.  <a href="#a227f46dad6159d846d8e6c90a9cfe3cb">更多...</a><br/></td></tr>
<tr class="separator:a227f46dad6159d846d8e6c90a9cfe3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d0275f5567a8253e3b10fa0d39a623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#ab9d0275f5567a8253e3b10fa0d39a623">broadcast</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;) const </td></tr>
<tr class="memdesc:ab9d0275f5567a8253e3b10fa0d39a623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all the processors that may contain elements that neighbor my elements.  <a href="#ab9d0275f5567a8253e3b10fa0d39a623">更多...</a><br/></td></tr>
<tr class="separator:ab9d0275f5567a8253e3b10fa0d39a623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc09ecb045289c5b370cf2e16427ae1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#afc09ecb045289c5b370cf2e16427ae1f">redistribute</a> (<a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, bool newly_coarsened_only=false) const </td></tr>
<tr class="memdesc:afc09ecb045289c5b370cf2e16427ae1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes a parallel distributed mesh and redistributes the elements.  <a href="#afc09ecb045289c5b370cf2e16427ae1f">更多...</a><br/></td></tr>
<tr class="separator:afc09ecb045289c5b370cf2e16427ae1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cb46d7416585880081c5e64504da1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a48cb46d7416585880081c5e64504da1c">gather_neighboring_elements</a> (<a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;) const </td></tr>
<tr class="separator:a48cb46d7416585880081c5e64504da1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d6e28995b84fba9cbcb72064d07637"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#aa1d6e28995b84fba9cbcb72064d07637">send_coarse_ghosts</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;) const </td></tr>
<tr class="memdesc:aa1d6e28995b84fba9cbcb72064d07637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examine a just-coarsened mesh, and for any newly-coarsened elements, send the associated ghosted elements to the processor which needs them.  <a href="#aa1d6e28995b84fba9cbcb72064d07637">更多...</a><br/></td></tr>
<tr class="separator:aa1d6e28995b84fba9cbcb72064d07637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb61dcc1aa8a3bda4fc67b2862cd2872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#abb61dcc1aa8a3bda4fc67b2862cd2872">gather</a> (const <a class="el" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> root_id, <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;) const </td></tr>
<tr class="memdesc:abb61dcc1aa8a3bda4fc67b2862cd2872"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes an input <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="The DistributedMesh class is derived from the MeshBase class, and is intended to provide identical fu...">DistributedMesh</a></code> which may be distributed among all the processors.  <a href="#abb61dcc1aa8a3bda4fc67b2862cd2872">更多...</a><br/></td></tr>
<tr class="separator:abb61dcc1aa8a3bda4fc67b2862cd2872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf56ac51df8bef4aa4a9dc89adc34fe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#acf56ac51df8bef4aa4a9dc89adc34fe7">allgather</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>) const </td></tr>
<tr class="memdesc:acf56ac51df8bef4aa4a9dc89adc34fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes an input <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="The DistributedMesh class is derived from the MeshBase class, and is intended to provide identical fu...">DistributedMesh</a></code> which may be distributed among all the processors.  <a href="#acf56ac51df8bef4aa4a9dc89adc34fe7">更多...</a><br/></td></tr>
<tr class="separator:acf56ac51df8bef4aa4a9dc89adc34fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580104162e0ee80f5f8fab535c4c32fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a580104162e0ee80f5f8fab535c4c32fb">delete_remote_elements</a> (<a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;, const std::set&lt; <a class="el" href="classlibMesh_1_1Elem.html">Elem</a> * &gt; &amp;) const </td></tr>
<tr class="memdesc:a580104162e0ee80f5f8fab535c4c32fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes an input <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="The DistributedMesh class is derived from the MeshBase class, and is intended to provide identical fu...">DistributedMesh</a></code> which may be distributed among all the processors.  <a href="#a580104162e0ee80f5f8fab535c4c32fb">更多...</a><br/></td></tr>
<tr class="separator:a580104162e0ee80f5f8fab535c4c32fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07c8ba8aee328c186d853666dca4aa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#ac07c8ba8aee328c186d853666dca4aa0">assign_global_indices</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;) const </td></tr>
<tr class="memdesc:ac07c8ba8aee328c186d853666dca4aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method assigns globally unique, partition-agnostic indices to the nodes and elements in the mesh.  <a href="#ac07c8ba8aee328c186d853666dca4aa0">更多...</a><br/></td></tr>
<tr class="separator:ac07c8ba8aee328c186d853666dca4aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ea7ecf5b4741e026b46f09204c121f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a19ea7ecf5b4741e026b46f09204c121f">check_for_duplicate_global_indices</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;) const </td></tr>
<tr class="memdesc:a19ea7ecf5b4741e026b46f09204c121f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an error if we have any index clashes in the numbering used by assign_global_indices.  <a href="#a19ea7ecf5b4741e026b46f09204c121f">更多...</a><br/></td></tr>
<tr class="separator:a19ea7ecf5b4741e026b46f09204c121f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1899390ba017ecd73db2856a3b68e5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:afb1899390ba017ecd73db2856a3b68e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#afb1899390ba017ecd73db2856a3b68e5">find_local_indices</a> (const <a class="el" href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a> &amp;, const ForwardIterator &amp;, const ForwardIterator &amp;, std::unordered_map&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>, <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &amp;) const </td></tr>
<tr class="memdesc:afb1899390ba017ecd73db2856a3b68e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method determines a locally unique, contiguous index for each object in the input range.  <a href="#afb1899390ba017ecd73db2856a3b68e5">更多...</a><br/></td></tr>
<tr class="separator:afb1899390ba017ecd73db2856a3b68e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdd0e5938cd28818a10628cf2c716cd"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:aabdd0e5938cd28818a10628cf2c716cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#aabdd0e5938cd28818a10628cf2c716cd">find_global_indices</a> (const Parallel::Communicator &amp;communicator, const <a class="el" href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a> &amp;, const ForwardIterator &amp;, const ForwardIterator &amp;, std::vector&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &amp;) const </td></tr>
<tr class="memdesc:aabdd0e5938cd28818a10628cf2c716cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method determines a globally unique, partition-agnostic index for each object in the input range.  <a href="#aabdd0e5938cd28818a10628cf2c716cd">更多...</a><br/></td></tr>
<tr class="separator:aabdd0e5938cd28818a10628cf2c716cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737da6ee13b781ac7aef37851a99af58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a737da6ee13b781ac7aef37851a99af58">make_elems_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="memdesc:a737da6ee13b781ac7aef37851a99af58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy ids of ghost elements from their local processors.  <a href="#a737da6ee13b781ac7aef37851a99af58">更多...</a><br/></td></tr>
<tr class="separator:a737da6ee13b781ac7aef37851a99af58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb166973b14e95ae36c14a39105907a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a9eb166973b14e95ae36c14a39105907a">make_p_levels_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="memdesc:a9eb166973b14e95ae36c14a39105907a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy p levels of ghost elements from their local processors.  <a href="#a9eb166973b14e95ae36c14a39105907a">更多...</a><br/></td></tr>
<tr class="separator:a9eb166973b14e95ae36c14a39105907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0eae4e562c489db701776c3970e772b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#ab0eae4e562c489db701776c3970e772b">make_node_ids_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="memdesc:ab0eae4e562c489db701776c3970e772b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming all ids on local nodes are globally unique, and assuming all processor ids are parallel consistent, this function makes all other ids parallel consistent.  <a href="#ab0eae4e562c489db701776c3970e772b">更多...</a><br/></td></tr>
<tr class="separator:ab0eae4e562c489db701776c3970e772b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e83bbe1c114c9de7be87927f7db9e85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a0e83bbe1c114c9de7be87927f7db9e85">make_node_unique_ids_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="memdesc:a0e83bbe1c114c9de7be87927f7db9e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming all unique_ids on local nodes are globally unique, and assuming all processor ids are parallel consistent, this function makes all ghost unique_ids parallel consistent.  <a href="#a0e83bbe1c114c9de7be87927f7db9e85">更多...</a><br/></td></tr>
<tr class="separator:a0e83bbe1c114c9de7be87927f7db9e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8082eb45c1053cbe83e6d1702633ca4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a8082eb45c1053cbe83e6d1702633ca4b">make_node_bcids_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="memdesc:a8082eb45c1053cbe83e6d1702633ca4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming all processor ids are parallel consistent, this function makes all ghost boundary ids on nodes parallel consistent.  <a href="#a8082eb45c1053cbe83e6d1702633ca4b">更多...</a><br/></td></tr>
<tr class="separator:a8082eb45c1053cbe83e6d1702633ca4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67880939a7d98e9cb3e7a6425a4d7ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#ab67880939a7d98e9cb3e7a6425a4d7ec">make_node_proc_ids_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="memdesc:ab67880939a7d98e9cb3e7a6425a4d7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming all processor ids on nodes touching local elements are parallel consistent, this function makes all other processor ids parallel consistent as well.  <a href="#ab67880939a7d98e9cb3e7a6425a4d7ec">更多...</a><br/></td></tr>
<tr class="separator:ab67880939a7d98e9cb3e7a6425a4d7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09a612b52ccb019c89165d3bfce5773"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#ae09a612b52ccb019c89165d3bfce5773">make_new_node_proc_ids_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="memdesc:ae09a612b52ccb019c89165d3bfce5773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming all processor ids on nodes touching local elements are parallel consistent, this function makes processor ids on new nodes on other processors parallel consistent as well.  <a href="#ae09a612b52ccb019c89165d3bfce5773">更多...</a><br/></td></tr>
<tr class="separator:ae09a612b52ccb019c89165d3bfce5773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76dd6bc5f023e8836591ca42a9caa94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#ac76dd6bc5f023e8836591ca42a9caa94">make_nodes_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="memdesc:ac76dd6bc5f023e8836591ca42a9caa94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy processor_ids and ids on ghost nodes from their local processors.  <a href="#ac76dd6bc5f023e8836591ca42a9caa94">更多...</a><br/></td></tr>
<tr class="separator:ac76dd6bc5f023e8836591ca42a9caa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa47da82381f82ded5e3f0bedb0dbd5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#afa47da82381f82ded5e3f0bedb0dbd5b">make_new_nodes_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="memdesc:afa47da82381f82ded5e3f0bedb0dbd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy processor_ids and ids on new nodes from their local processors.  <a href="#afa47da82381f82ded5e3f0bedb0dbd5b">更多...</a><br/></td></tr>
<tr class="separator:afa47da82381f82ded5e3f0bedb0dbd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>This is the <code><a class="el" href="classlibMesh_1_1MeshCommunication.html" title="This is the MeshCommunication class. ">MeshCommunication</a></code> class. </p>
<p>It handles all the details of communicating mesh information from one processor to another. All parallelization of the <code><a class="el" href="classlibMesh_1_1Mesh.html" title="The Mesh class is a thin wrapper, around the ReplicatedMesh class by default. ">Mesh</a></code> data structures is done via this class.</p>
<dl class="section author"><dt>作者</dt><dd>Benjamin S. Kirk </dd></dl>
<dl class="section date"><dt>日期</dt><dd>2003 </dd></dl>

<p>在文件 <a class="el" href="mesh__communication_8h_source.html">mesh_communication.h</a> 第 <a class="el" href="mesh__communication_8h_source.html#l00050">50</a> 行定义.</p>
</div><h2 class="groupheader">构造及析构函数说明</h2>
<a class="anchor" id="af8e32501572c9e39d8d11114bbeca427"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::MeshCommunication::MeshCommunication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a2b2a38783ee81d78d70430ea6c74aaef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::MeshCommunication::~MeshCommunication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a class="anchor" id="acf56ac51df8bef4aa4a9dc89adc34fe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::allgather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method takes an input <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="The DistributedMesh class is derived from the MeshBase class, and is intended to provide identical fu...">DistributedMesh</a></code> which may be distributed among all the processors. </p>
<p>Each processor then sends its local nodes and elements to the other processors. The end result is that a previously distributed <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="The DistributedMesh class is derived from the MeshBase class, and is intended to provide identical fu...">DistributedMesh</a></code> will be serialized on each processor. Since this method is collective it must be called by all processors. </p>

<p>在文件 <a class="el" href="mesh__communication_8h_source.html">mesh_communication.h</a> 第 <a class="el" href="mesh__communication_8h_source.html#l00135">135</a> 行定义.</p>

<p>参考 <a class="el" href="mesh__communication_8C_source.html#l01153">gather()</a> , 以及 <a class="el" href="dof__object_8h_source.html#l00488">libMesh::DofObject::invalid_processor_id</a>.</p>

<p>参考自 <a class="el" href="nemesis__io_8C_source.html#l00198">libMesh::Nemesis_IO::read()</a>.</p>
<div class="fragment"><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  { <a class="code" href="classlibMesh_1_1MeshCommunication.html#abb61dcc1aa8a3bda4fc67b2862cd2872">MeshCommunication::gather</a>(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>); }</div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_abb61dcc1aa8a3bda4fc67b2862cd2872"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#abb61dcc1aa8a3bda4fc67b2862cd2872">libMesh::MeshCommunication::gather</a></div><div class="ttdeci">void gather(const processor_id_type root_id, MeshBase &amp;) const </div><div class="ttdoc">This method takes an input DistributedMesh which may be distributed among all the processors...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01153">mesh_communication.C:1153</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdoc">An invalid processor_id to distinguish DoFs that have not been assigned to a processor. </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00488">dof_object.h:488</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac07c8ba8aee328c186d853666dca4aa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::assign_global_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method assigns globally unique, partition-agnostic indices to the nodes and elements in the mesh. </p>
<p>The approach is to compute the <a class="el" href="namespaceHilbert.html">Hilbert</a> space-filling curve key and use its value to assign an index in [0,N_global). Since the <a class="el" href="namespaceHilbert.html">Hilbert</a> key is unique for each spatial location, two objects occupying the same location will be assigned the same global id. Thus, this method can also be useful for identifying duplicate nodes which may occur during parallel refinement. </p>

<p>在文件 <a class="el" href="mesh__communication__global__indices_8C_source.html">mesh_communication_global_indices.C</a> 第 <a class="el" href="mesh__communication__global__indices_8C_source.html#l00204">204</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__sort_8C_source.html#l00264">libMesh::Parallel::Sort&lt; KeyType, IdxType &gt;::bin()</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l00583">libMesh::MeshTools::create_nodal_bounding_box()</a>, <a class="el" href="mesh__generation_8C_source.html#l00078">libMesh::MeshTools::Generation::Private::idx()</a>, <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>, <a class="el" href="mesh__tools_8C_source.html#l01490">libMesh::MeshTools::libmesh_assert_equal_connectivity()</a>, <a class="el" href="mesh__tools_8C_source.html#l01474">libMesh::MeshTools::libmesh_assert_equal_points()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a190e556d3be87f5ccd8d4fc98d1779d3">libMesh::MeshBase::n_elem()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5b76b109bc6bd087c981774897aa6167">libMesh::MeshBase::n_nodes()</a>, <a class="el" href="threads__none_8h_source.html#l00073">libMesh::Threads::parallel_for()</a> , 以及 <a class="el" href="parallel__sort_8C_source.html#l00064">libMesh::Parallel::Sort&lt; KeyType, IdxType &gt;::sort()</a>.</p>

<p>参考自 <a class="el" href="mesh__tools_8C_source.html#l02379">libMesh::MeshTools::Private::globally_renumber_nodes_and_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;{</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;assign_global_indices()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  <span class="comment">// This method determines partition-agnostic global indices</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;  <span class="comment">// for nodes and elements.</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  <span class="comment">// Algorithm:</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  <span class="comment">// (1) compute the Hilbert key for each local node/element</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  <span class="comment">// (2) perform a parallel sort of the Hilbert key</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  <span class="comment">// (3) get the min/max value on each processor</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  <span class="comment">// (4) determine the position in the global ranking for</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  <span class="comment">//     each local object</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  <span class="keyword">const</span> Parallel::Communicator &amp; communicator (mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="preprocessor"></span>  <span class="comment">// This is going to be a mess if geometry is out of sync</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#ae5fce194403991f405f2b78b267251ac">MeshTools::libmesh_assert_equal_points</a>(mesh);</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#a0112fef358e38b3c86584b2d7b0d19b1">MeshTools::libmesh_assert_equal_connectivity</a>(mesh);</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  <span class="comment">// Global bounding box.  We choose the nodal bounding box for</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  <span class="comment">// backwards compatibility; the element bounding box may be looser</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  <span class="comment">// on curved elements.</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  <span class="keyword">const</span> <a class="code" href="classlibMesh_1_1BoundingBox.html">BoundingBox</a> bbox =</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <a class="code" href="namespacelibMesh_1_1MeshTools.html#a9cc1d9577393d91d5df11f4034e1264b">MeshTools::create_nodal_bounding_box</a> (mesh);</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  <span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Point.html">Point</a> bboxinv = invert_bbox(bbox);</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;  <span class="comment">// (1) compute Hilbert keys</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  std::vector&lt;Parallel::DofObjectKey&gt;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    node_keys, elem_keys;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  {</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="comment">// Nodes first</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    {</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;      <a class="code" href="classlibMesh_1_1StoredRange.html">ConstNodeRange</a> nr (mesh.local_nodes_begin(),</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                         mesh.local_nodes_end());</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;      node_keys.resize (nr.size());</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;      <a class="code" href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">Threads::parallel_for</a> (nr, ComputeHilbertKeys (bbox, bboxinv, node_keys));</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      <span class="comment">// // It&#39;s O(N^2) to check that these keys don&#39;t duplicate before the</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      <span class="comment">// // sort...</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;      <span class="comment">//</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      <span class="comment">// MeshBase::const_node_iterator nodei = mesh.local_nodes_begin();</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;      <span class="comment">// for (std::size_t i = 0; i != node_keys.size(); ++i, ++nodei)</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;      <span class="comment">//   {</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      <span class="comment">//     MeshBase::const_node_iterator nodej = mesh.local_nodes_begin();</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;      <span class="comment">//     for (std::size_t j = 0; j != i; ++j, ++nodej)</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;      <span class="comment">//       {</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;      <span class="comment">//         if (node_keys[i] == node_keys[j])</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;      <span class="comment">//           {</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;      <span class="comment">//             CFixBitVec icoords[3], jcoords[3];</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;      <span class="comment">//             get_hilbert_coords(**nodej, bbox, bboxinv, jcoords);</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;      <span class="comment">//             libMesh::err &lt;&lt; &quot;node &quot; &lt;&lt; (*nodej)-&gt;id() &lt;&lt; &quot;, &quot; &lt;&lt; static_cast&lt;Point &amp;&gt;(**nodej) &lt;&lt; &quot; has HilbertIndices &quot; &lt;&lt; node_keys[j] &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;      <span class="comment">//             get_hilbert_coords(**nodei, bbox, bboxinv, icoords);</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;      <span class="comment">//             libMesh::err &lt;&lt; &quot;node &quot; &lt;&lt; (*nodei)-&gt;id() &lt;&lt; &quot;, &quot; &lt;&lt; static_cast&lt;Point &amp;&gt;(**nodei) &lt;&lt; &quot; has HilbertIndices &quot; &lt;&lt; node_keys[i] &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;      <span class="comment">//             libmesh_error_msg(&quot;Error: nodes with duplicate Hilbert keys!&quot;);</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;      <span class="comment">//           }</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;      <span class="comment">//       }</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;      <span class="comment">//   }</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    }</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    <span class="comment">// Elements next</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    {</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;      <a class="code" href="classlibMesh_1_1StoredRange.html">ConstElemRange</a> er (mesh.local_elements_begin(),</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                         mesh.local_elements_end());</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;      elem_keys.resize (er.size());</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;      <a class="code" href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">Threads::parallel_for</a> (er, ComputeHilbertKeys (bbox, bboxinv, elem_keys));</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;      <span class="comment">// // For elements, the keys can be (and in the case of TRI, are</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;      <span class="comment">// // expected to be) duplicates, but only if the elements are at</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;      <span class="comment">// // different levels</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;      <span class="comment">// MeshBase::const_element_iterator elemi = mesh.local_elements_begin();</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;      <span class="comment">// for (std::size_t i = 0; i != elem_keys.size(); ++i, ++elemi)</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;      <span class="comment">//   {</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;      <span class="comment">//     MeshBase::const_element_iterator elemj = mesh.local_elements_begin();</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;      <span class="comment">//     for (std::size_t j = 0; j != i; ++j, ++elemj)</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;      <span class="comment">//       {</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;      <span class="comment">//         if ((elem_keys[i] == elem_keys[j]) &amp;&amp;</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;      <span class="comment">//             ((*elemi)-&gt;level() == (*elemj)-&gt;level()))</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;      <span class="comment">//           {</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;      <span class="comment">//             libMesh::err &lt;&lt; &quot;level &quot; &lt;&lt; (*elemj)-&gt;level()</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;      <span class="comment">//                          &lt;&lt; &quot; elem\n&quot; &lt;&lt; (**elemj)</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;      <span class="comment">//                          &lt;&lt; &quot; vertex average &quot; &lt;&lt; (*elemj)-&gt;vertex_average()</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;      <span class="comment">//                          &lt;&lt; &quot; has HilbertIndices &quot; &lt;&lt; elem_keys[j]</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;      <span class="comment">//                          &lt;&lt; &quot; or &quot; &lt;&lt; get_dofobject_key((**elemj), bbox, bboxinv)</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;      <span class="comment">//                          &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;      <span class="comment">//             libMesh::err &lt;&lt; &quot;level &quot; &lt;&lt; (*elemi)-&gt;level()</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;      <span class="comment">//                          &lt;&lt; &quot; elem\n&quot; &lt;&lt; (**elemi)</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;      <span class="comment">//                          &lt;&lt; &quot; vertex average &quot; &lt;&lt; (*elemi)-&gt;vertex_average()</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;      <span class="comment">//                          &lt;&lt; &quot; has HilbertIndices &quot; &lt;&lt; elem_keys[i]</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      <span class="comment">//                          &lt;&lt; &quot; or &quot; &lt;&lt; get_dofobject_key((**elemi), bbox, bboxinv)</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      <span class="comment">//                          &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;      <span class="comment">//             libmesh_error_msg(&quot;Error: level &quot; &lt;&lt; (*elemi)-&gt;level() &lt;&lt; &quot; elements with duplicate Hilbert keys!&quot;);</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;      <span class="comment">//           }</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      <span class="comment">//       }</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;      <span class="comment">//  }</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    }</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  } <span class="comment">// done computing Hilbert keys</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  <span class="comment">// (2) parallel sort the Hilbert keys</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  <a class="code" href="classlibMesh_1_1Parallel_1_1Sort.html">Parallel::Sort&lt;Parallel::DofObjectKey&gt;</a> node_sorter (communicator,</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                                                      node_keys);</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  node_sorter.sort(); <span class="comment">/* done with node_keys */</span> <span class="comment">//node_keys.clear();</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; my_node_bin =</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    node_sorter.bin();</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  <a class="code" href="classlibMesh_1_1Parallel_1_1Sort.html">Parallel::Sort&lt;Parallel::DofObjectKey&gt;</a> elem_sorter (communicator,</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                                                      elem_keys);</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  elem_sorter.sort(); <span class="comment">/* done with elem_keys */</span> <span class="comment">//elem_keys.clear();</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; my_elem_bin =</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    elem_sorter.bin();</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  <span class="comment">// (3) get the max value on each processor</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  std::vector&lt;Parallel::DofObjectKey&gt;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    node_upper_bounds(communicator.size()),</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    elem_upper_bounds(communicator.size());</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  { <span class="comment">// limit scope of temporaries</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    std::vector&lt;Parallel::DofObjectKey&gt; recvbuf(2*communicator.size());</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    std::vector&lt;unsigned short int&gt; <span class="comment">/* do not use a vector of bools here since it is not always so! */</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;      empty_nodes (communicator.size()),</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;      empty_elem  (communicator.size());</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    std::vector&lt;Parallel::DofObjectKey&gt; my_max(2);</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    communicator.allgather (static_cast&lt;unsigned short int&gt;(my_node_bin.empty()), empty_nodes);</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    communicator.allgather (static_cast&lt;unsigned short int&gt;(my_elem_bin.empty()),  empty_elem);</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keywordflow">if</span> (!my_node_bin.empty()) my_max[0] = my_node_bin.back();</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="keywordflow">if</span> (!my_elem_bin.empty()) my_max[1] = my_elem_bin.back();</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    communicator.allgather (my_max, <span class="comment">/* identical_buffer_sizes = */</span> <span class="keyword">true</span>);</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="comment">// Be careful here.  The *_upper_bounds will be used to find the processor</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <span class="comment">// a given object belongs to.  So, if a processor contains no objects (possible!)</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="comment">// then copy the bound from the lower processor id.</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(communicator.size()))</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;      {</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        node_upper_bounds[p] = my_max[2*p+0];</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        elem_upper_bounds[p] = my_max[2*p+1];</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        <span class="keywordflow">if</span> (p &gt; 0) <span class="comment">// default hilbert index value is the OK upper bound for processor 0.</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;          {</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            <span class="keywordflow">if</span> (empty_nodes[p]) node_upper_bounds[p] = node_upper_bounds[p-1];</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;            <span class="keywordflow">if</span> (empty_elem[p])  elem_upper_bounds[p] = elem_upper_bounds[p-1];</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;          }</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;      }</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  }</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  <span class="comment">// (4) determine the position in the global ranking for</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;  <span class="comment">//     each local object</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  {</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="comment">//----------------------------------------------</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="comment">// Nodes first -- all nodes, not just local ones</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    {</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;      <span class="comment">// Request sets to send to each processor</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;      std::map&lt;processor_id_type, std::vector&lt;Parallel::DofObjectKey&gt;&gt;</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        requested_ids;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;      <span class="comment">// Results to gather from each processor - kept in a map so we</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;      <span class="comment">// do only one loop over nodes after all receives are done.</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;      std::map&lt;dof_id_type, std::vector&lt;dof_id_type&gt;&gt;</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        filled_request;</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;      <span class="comment">// build up list of requests</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; node : mesh.node_ptr_range())</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        {</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;          <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(node);</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi =</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;            get_dofobject_key (*node, bbox, bboxinv);</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> pid =</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            cast_int&lt;processor_id_type&gt;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            (std::distance (node_upper_bounds.begin(),</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;                            std::lower_bound(node_upper_bounds.begin(),</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                                             node_upper_bounds.end(),</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                                             hi)));</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;          libmesh_assert_less (pid, communicator.size());</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;          requested_ids[pid].push_back(hi);</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        }</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;      <span class="comment">// The number of objects in my_node_bin on each processor</span></div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;      std::vector&lt;dof_id_type&gt; node_bin_sizes(communicator.size());</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;      communicator.allgather (static_cast&lt;dof_id_type&gt;(my_node_bin.size()), node_bin_sizes);</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      <span class="comment">// The offset of my first global index</span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;      <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> my_offset = 0;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> pid : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(communicator.rank()))</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        my_offset += node_bin_sizes[pid];</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;      <span class="keyword">auto</span> gather_functor =</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        [</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="preprocessor"></span>         &amp; node_upper_bounds,</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;         &amp; communicator,</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="preprocessor"></span>         &amp; my_node_bin,</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;         my_offset</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        ]</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        (<a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a>,</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;         <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; keys,</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;         std::vector&lt;dof_id_type&gt; &amp; global_ids)</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;          <span class="comment">// Fill the requests</span></div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;          <span class="keyword">const</span> std::size_t keys_size = keys.size();</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;          global_ids.reserve(keys_size);</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;          <span class="keywordflow">for</span> (std::size_t <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>=0; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a> != keys_size; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>++)</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;            {</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> &amp; hi = keys[<a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>];</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;              libmesh_assert_less_equal (hi, node_upper_bounds[communicator.rank()]);</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;              <span class="comment">// find the requested index in my node bin</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;              std::vector&lt;Parallel::DofObjectKey&gt;::const_iterator pos =</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;                std::lower_bound (my_node_bin.begin(), my_node_bin.end(), hi);</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;              <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (pos != my_node_bin.end());</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;              libmesh_assert_equal_to (*pos, hi);</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;              <span class="comment">// Finally, assign the global index based off the position of the index</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;              <span class="comment">// in my array, properly offset.</span></div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;              global_ids.push_back(cast_int&lt;dof_id_type&gt;(std::distance(my_node_bin.begin(), pos) + my_offset));</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            }</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        };</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;      <span class="keyword">auto</span> action_functor =</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        [&amp;filled_request]</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        (processor_id_type pid,</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;         <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp;,</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;         <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; global_ids)</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        {</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;          filled_request[pid] = global_ids;</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        };</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;      <span class="comment">// Trade requests with other processors</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> * ex = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;      Parallel::pull_parallel_vector_data</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        (communicator, requested_ids, gather_functor, action_functor, ex);</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;      <span class="comment">// We now have all the filled requests, so we can loop through our</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;      <span class="comment">// nodes once and assign the global index to each one.</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;      {</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;        std::map&lt;dof_id_type, std::vector&lt;dof_id_type&gt;::const_iterator&gt;</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;          next_obj_on_proc;</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; p : filled_request)</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;          next_obj_on_proc[p.first] = p.second.begin();</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : mesh.node_ptr_range())</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;          {</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;            <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(node);</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi =</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;              get_dofobject_key (*node, bbox, bboxinv);</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;            <span class="keyword">const</span> processor_id_type pid =</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;              cast_int&lt;processor_id_type&gt;</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;              (std::distance (node_upper_bounds.begin(),</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                              std::lower_bound(node_upper_bounds.begin(),</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;                                               node_upper_bounds.end(),</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                                               hi)));</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;            libmesh_assert_less (pid, communicator.size());</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;            <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (next_obj_on_proc[pid] != filled_request[pid].end());</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> global_index = *next_obj_on_proc[pid];</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;            libmesh_assert_less (global_index, mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a5b76b109bc6bd087c981774897aa6167">n_nodes</a>());</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;            node-&gt;set_id() = global_index;</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;            ++next_obj_on_proc[pid];</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;          }</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;      }</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    }</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="comment">//---------------------------------------------------</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    <span class="comment">// elements next -- all elements, not just local ones</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    {</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;      <span class="comment">// Request sets to send to each processor</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;      std::map&lt;processor_id_type, std::vector&lt;Parallel::DofObjectKey&gt;&gt;</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        requested_ids;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;      <span class="comment">// Results to gather from each processor - kept in a map so we</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;      <span class="comment">// do only one loop over elements after all receives are done.</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;      std::map&lt;dof_id_type, std::vector&lt;dof_id_type&gt;&gt;</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        filled_request;</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : mesh.element_ptr_range())</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        {</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;          <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(elem);</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi =</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            get_dofobject_key (*elem, bbox, bboxinv);</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;          <span class="keyword">const</span> processor_id_type pid =</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;            cast_int&lt;processor_id_type&gt;</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;            (std::distance (elem_upper_bounds.begin(),</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                            std::lower_bound(elem_upper_bounds.begin(),</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                                             elem_upper_bounds.end(),</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                                             hi)));</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;          libmesh_assert_less (pid, communicator.size());</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;          requested_ids[pid].push_back(hi);</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        }</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;      <span class="comment">// The number of objects in my_elem_bin on each processor</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;      std::vector&lt;dof_id_type&gt; elem_bin_sizes(communicator.size());</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;      communicator.allgather (static_cast&lt;dof_id_type&gt;(my_elem_bin.size()), elem_bin_sizes);</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;      <span class="comment">// The offset of my first global index</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;      <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> my_offset = 0;</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> pid : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(communicator.rank()))</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        my_offset += elem_bin_sizes[pid];</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;      <span class="keyword">auto</span> gather_functor =</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        [</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="preprocessor"></span>         &amp; elem_upper_bounds,</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;         &amp; communicator,</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="preprocessor"></span>         &amp; my_elem_bin,</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;         my_offset</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;        ]</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;        (<a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a>,</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;         <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; keys,</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;         std::vector&lt;dof_id_type&gt; &amp; global_ids)</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        {</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;          <span class="comment">// Fill the requests</span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;          <span class="keyword">const</span> std::size_t keys_size = keys.size();</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;          global_ids.reserve(keys_size);</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;          <span class="keywordflow">for</span> (std::size_t <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>=0; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a> != keys_size; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>++)</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;            {</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> &amp; hi = keys[<a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>];</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;              libmesh_assert_less_equal (hi, elem_upper_bounds[communicator.rank()]);</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;              <span class="comment">// find the requested index in my elem bin</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;              std::vector&lt;Parallel::DofObjectKey&gt;::const_iterator pos =</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                std::lower_bound (my_elem_bin.begin(), my_elem_bin.end(), hi);</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;              <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (pos != my_elem_bin.end());</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;              libmesh_assert_equal_to (*pos, hi);</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;              <span class="comment">// Finally, assign the global index based off the position of the index</span></div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;              <span class="comment">// in my array, properly offset.</span></div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;              global_ids.push_back (cast_int&lt;dof_id_type&gt;(std::distance(my_elem_bin.begin(), pos) + my_offset));</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;            }</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        };</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;      <span class="keyword">auto</span> action_functor =</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;        [&amp;filled_request]</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        (processor_id_type pid,</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;         <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp;,</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;         <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; global_ids)</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        {</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;          filled_request[pid] = global_ids;</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        };</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;      <span class="comment">// Trade requests with other processors</span></div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> * ex = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;      Parallel::pull_parallel_vector_data</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        (communicator, requested_ids, gather_functor, action_functor, ex);</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;      <span class="comment">// We now have all the filled requests, so we can loop through our</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;      <span class="comment">// elements once and assign the global index to each one.</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;      {</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        std::vector&lt;std::vector&lt;dof_id_type&gt;::const_iterator&gt;</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;          next_obj_on_proc; next_obj_on_proc.reserve(communicator.size());</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> pid : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(communicator.size()))</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;          next_obj_on_proc.push_back(filled_request[pid].begin());</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : mesh.element_ptr_range())</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;          {</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;            <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(elem);</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi =</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;              get_dofobject_key (*elem, bbox, bboxinv);</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;            <span class="keyword">const</span> processor_id_type pid =</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;              cast_int&lt;processor_id_type&gt;</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;              (std::distance (elem_upper_bounds.begin(),</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                              std::lower_bound(elem_upper_bounds.begin(),</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                                               elem_upper_bounds.end(),</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                                               hi)));</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;            libmesh_assert_less (pid, communicator.size());</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;            <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (next_obj_on_proc[pid] != filled_request[pid].end());</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> global_index = *next_obj_on_proc[pid];</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;            libmesh_assert_less (global_index, mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a190e556d3be87f5ccd8d4fc98d1779d3">n_elem</a>());</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;            elem-&gt;set_id() = global_index;</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;            ++next_obj_on_proc[pid];</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;          }</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;      }</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    }</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;  }</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ae5fce194403991f405f2b78b267251ac"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ae5fce194403991f405f2b78b267251ac">libMesh::MeshTools::libmesh_assert_equal_points</a></div><div class="ttdeci">void libmesh_assert_equal_points(const MeshBase &amp;mesh)</div><div class="ttdoc">A function for testing that node locations match across processors. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l01474">mesh_tools.C:1474</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Threads_html_a97dcd01ff677ad850c3c9f6d8380dba2"><div class="ttname"><a href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">libMesh::Threads::parallel_for</a></div><div class="ttdeci">void parallel_for(const Range &amp;range, const Body &amp;body)</div><div class="ttdoc">Execute the provided function object in parallel on the specified range. </div><div class="ttdef"><b>Definition:</b> <a href="threads__none_8h_source.html#l00073">threads_none.h:73</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_aefbe7c94fa1895557e56fdc001710b16"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">libMesh::Parallel::DofObjectKey</a></div><div class="ttdeci">std::pair&lt; Hilbert::HilbertIndices, unique_id_type &gt; DofObjectKey</div><div class="ttdef"><b>Definition:</b> <a href="parallel__hilbert_8h_source.html#l00080">parallel_hilbert.h:80</a></div></div>
<div class="ttc" id="classlibMesh_1_1StoredRange_html"><div class="ttname"><a href="classlibMesh_1_1StoredRange.html">libMesh::StoredRange</a></div><div class="ttdoc">The StoredRange class defines a contiguous, divisible set of objects. </div><div class="ttdef"><b>Definition:</b> <a href="stored__range_8h_source.html#l00054">stored_range.h:54</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af18245d4f872c36a41fc74086bda3e80"><div class="ttname"><a href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00104">id_types.h:104</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1BoundingBox_html"><div class="ttname"><a href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a></div><div class="ttdoc">Defines a Cartesian bounding box by the two corner extremum. </div><div class="ttdef"><b>Definition:</b> <a href="bounding__box_8h_source.html#l00040">bounding_box.h:40</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a0112fef358e38b3c86584b2d7b0d19b1"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a0112fef358e38b3c86584b2d7b0d19b1">libMesh::MeshTools::libmesh_assert_equal_connectivity</a></div><div class="ttdeci">void libmesh_assert_equal_connectivity(const MeshBase &amp;mesh)</div><div class="ttdoc">A function for testing that element nodal connectivities match across processors. ...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l01490">mesh_tools.C:1490</a></div></div>
<div class="ttc" id="classlibMesh_1_1Parallel_1_1Sort_html"><div class="ttname"><a href="classlibMesh_1_1Parallel_1_1Sort.html">libMesh::Parallel::Sort</a></div><div class="ttdoc">The parallel sorting method is templated on the type of data which is to be sorted. </div><div class="ttdef"><b>Definition:</b> <a href="parallel__sort_8h_source.html#l00055">parallel_sort.h:55</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a9cc1d9577393d91d5df11f4034e1264b"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a9cc1d9577393d91d5df11f4034e1264b">libMesh::MeshTools::create_nodal_bounding_box</a></div><div class="ttdeci">libMesh::BoundingBox create_nodal_bounding_box(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00583">mesh_tools.C:583</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a190e556d3be87f5ccd8d4fc98d1779d3"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a190e556d3be87f5ccd8d4fc98d1779d3">libMesh::MeshBase::n_elem</a></div><div class="ttdeci">virtual dof_id_type n_elem() const =0</div></div>
<div class="ttc" id="classlibMesh_1_1Point_html"><div class="ttname"><a href="classlibMesh_1_1Point.html">libMesh::Point</a></div><div class="ttdoc">A Point defines a location in LIBMESH_DIM dimensional Real space. </div><div class="ttdef"><b>Definition:</b> <a href="point_8h_source.html#l00039">point.h:39</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a5b76b109bc6bd087c981774897aa6167"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a5b76b109bc6bd087c981774897aa6167">libMesh::MeshBase::n_nodes</a></div><div class="ttdeci">virtual dof_id_type n_nodes() const =0</div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private_html_acd3e3226af58784e414a3c242a3ef740"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">libMesh::MeshTools::Generation::Private::idx</a></div><div class="ttdeci">unsigned int idx(const ElemType type, const unsigned int nx, const unsigned int i, const unsigned int j)</div><div class="ttdoc">A useful inline function which replaces the macros used previously. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__generation_8C_source.html#l00078">mesh_generation.C:78</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab9d0275f5567a8253e3b10fa0d39a623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::broadcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all the processors that may contain elements that neighbor my elements. </p>
<p>This list is guaranteed to include all processors that border any of my elements, but may include additional ones as well. This method computes bounding boxes for the elements on each processor and checks for overlaps. This method takes a mesh (which is assumed to reside on processor 0) and broadcasts it to all the other processors. It also broadcasts any boundary information the mesh has associated with it. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01015">1015</a> 行定义.</p>

<p>参考自 <a class="el" href="namebased__io_8C_source.html#l00080">libMesh::NameBasedIO::read()</a> , 以及 <a class="el" href="checkpoint__io_8C_source.html#l00814">libMesh::CheckpointIO::read()</a>.</p>
<div class="fragment"><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;{</div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;  <span class="comment">// no MPI == one processor, no need for this method...</span></div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;  <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a19ea7ecf5b4741e026b46f09204c121f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::check_for_duplicate_global_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throw an error if we have any index clashes in the numbering used by assign_global_indices. </p>

<p>在文件 <a class="el" href="mesh__communication__global__indices_8C_source.html">mesh_communication_global_indices.C</a> 第 <a class="el" href="mesh__communication__global__indices_8C_source.html#l00612">612</a> 行定义.</p>

<p>参考 <a class="el" href="mesh__tools_8C_source.html#l00583">libMesh::MeshTools::create_nodal_bounding_box()</a>, <a class="el" href="libmesh__common_8h_source.html#l00101">libMesh::err</a> , 以及 <a class="el" href="threads__none_8h_source.html#l00073">libMesh::Threads::parallel_for()</a>.</p>
<div class="fragment"><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;{</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;check_for_duplicate_global_indices()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;  <span class="comment">// Global bounding box.  We choose the nodal bounding box for</span></div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;  <span class="comment">// backwards compatibility; the element bounding box may be looser</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;  <span class="comment">// on curved elements.</span></div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;  <span class="keyword">const</span> <a class="code" href="classlibMesh_1_1BoundingBox.html">BoundingBox</a> bbox =</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;    <a class="code" href="namespacelibMesh_1_1MeshTools.html#a9cc1d9577393d91d5df11f4034e1264b">MeshTools::create_nodal_bounding_box</a> (mesh);</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;  <span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Point.html">Point</a> bboxinv = invert_bbox(bbox);</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;  std::vector&lt;Parallel::DofObjectKey&gt;</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;    node_keys, elem_keys;</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;  {</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    <span class="comment">// Nodes first</span></div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    {</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;      <a class="code" href="classlibMesh_1_1StoredRange.html">ConstNodeRange</a> nr (mesh.local_nodes_begin(),</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;                         mesh.local_nodes_end());</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;      node_keys.resize (nr.size());</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;      <a class="code" href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">Threads::parallel_for</a> (nr, ComputeHilbertKeys (bbox, bboxinv, node_keys));</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;      <span class="comment">// It&#39;s O(N^2) to check that these keys don&#39;t duplicate before the</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;      <span class="comment">// sort...</span></div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;      <a class="code" href="structlibMesh_1_1MeshBase_1_1const__node__iterator.html">MeshBase::const_node_iterator</a> nodei = mesh.local_nodes_begin();</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i != node_keys.size(); ++i, ++nodei)</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;        {</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;          <a class="code" href="structlibMesh_1_1MeshBase_1_1const__node__iterator.html">MeshBase::const_node_iterator</a> nodej = mesh.local_nodes_begin();</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;          <span class="keywordflow">for</span> (std::size_t j = 0; j != i; ++j, ++nodej)</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;            {</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;              <span class="keywordflow">if</span> (node_keys[i] == node_keys[j])</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                {</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                  CFixBitVec icoords[3], jcoords[3];</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;                  get_hilbert_coords(**nodej, bbox, bboxinv, jcoords);</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;                  <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt;</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                    <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; (*nodej)-&gt;id() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                    *(<span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Point.html">Point</a> *)(*nodej) &lt;&lt; <span class="stringliteral">&quot; has HilbertIndices &quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;                    node_keys[j] &lt;&lt; std::endl;</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                  get_hilbert_coords(**nodei, bbox, bboxinv, icoords);</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                  <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt;</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;                    <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; (*nodei)-&gt;id() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;                    *(<span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Point.html">Point</a> *)(*nodei) &lt;&lt; <span class="stringliteral">&quot; has HilbertIndices &quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                    node_keys[i] &lt;&lt; std::endl;</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                  libmesh_error_msg(<span class="stringliteral">&quot;Error: nodes with duplicate Hilbert keys!&quot;</span>);</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                }</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;            }</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;        }</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;    }</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;    <span class="comment">// Elements next</span></div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    {</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;      <a class="code" href="classlibMesh_1_1StoredRange.html">ConstElemRange</a> er (mesh.local_elements_begin(),</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;                         mesh.local_elements_end());</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;      elem_keys.resize (er.size());</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;      <a class="code" href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">Threads::parallel_for</a> (er, ComputeHilbertKeys (bbox, bboxinv, elem_keys));</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;      <span class="comment">// For elements, the keys can be (and in the case of TRI, are</span></div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;      <span class="comment">// expected to be) duplicates, but only if the elements are at</span></div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;      <span class="comment">// different levels</span></div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;      <a class="code" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> elemi = mesh.local_elements_begin();</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i != elem_keys.size(); ++i, ++elemi)</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        {</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;          <a class="code" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> elemj = mesh.local_elements_begin();</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;          <span class="keywordflow">for</span> (std::size_t j = 0; j != i; ++j, ++elemj)</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;            {</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;              <span class="keywordflow">if</span> ((elem_keys[i] == elem_keys[j]) &amp;&amp;</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;                  ((*elemi)-&gt;level() == (*elemj)-&gt;level()))</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;                {</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;                  <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt;</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;                    <span class="stringliteral">&quot;level &quot;</span> &lt;&lt; (*elemj)-&gt;level() &lt;&lt; <span class="stringliteral">&quot; elem\n&quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;                    (**elemj) &lt;&lt; <span class="stringliteral">&quot; vertex average &quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;                    (*elemj)-&gt;vertex_average() &lt;&lt; <span class="stringliteral">&quot; has HilbertIndices &quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;                    elem_keys[j] &lt;&lt; <span class="stringliteral">&quot; or &quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;                    get_dofobject_key((**elemj), bbox, bboxinv) &lt;&lt;</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;                    std::endl;</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;                  <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt;</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;                    <span class="stringliteral">&quot;level &quot;</span> &lt;&lt; (*elemi)-&gt;level() &lt;&lt; <span class="stringliteral">&quot; elem\n&quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;                    (**elemi) &lt;&lt; <span class="stringliteral">&quot; vertex average &quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;                    (*elemi)-&gt;vertex_average() &lt;&lt; <span class="stringliteral">&quot; has HilbertIndices &quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;                    elem_keys[i] &lt;&lt; <span class="stringliteral">&quot; or &quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;                    get_dofobject_key((**elemi), bbox, bboxinv) &lt;&lt;</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;                    std::endl;</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;                  libmesh_error_msg(<span class="stringliteral">&quot;Error: level &quot;</span> &lt;&lt; (*elemi)-&gt;level() &lt;&lt; <span class="stringliteral">&quot; elements with duplicate Hilbert keys!&quot;</span>);</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;                }</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;            }</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;        }</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;    }</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;  } <span class="comment">// done checking Hilbert keys</span></div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_1_1Threads_html_a97dcd01ff677ad850c3c9f6d8380dba2"><div class="ttname"><a href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">libMesh::Threads::parallel_for</a></div><div class="ttdeci">void parallel_for(const Range &amp;range, const Body &amp;body)</div><div class="ttdoc">Execute the provided function object in parallel on the specified range. </div><div class="ttdef"><b>Definition:</b> <a href="threads__none_8h_source.html#l00073">threads_none.h:73</a></div></div>
<div class="ttc" id="structlibMesh_1_1MeshBase_1_1const__element__iterator_html"><div class="ttname"><a href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">libMesh::MeshBase::const_element_iterator</a></div><div class="ttdoc">The definition of the const_element_iterator struct. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l02086">mesh_base.h:2086</a></div></div>
<div class="ttc" id="classlibMesh_1_1StoredRange_html"><div class="ttname"><a href="classlibMesh_1_1StoredRange.html">libMesh::StoredRange</a></div><div class="ttdoc">The StoredRange class defines a contiguous, divisible set of objects. </div><div class="ttdef"><b>Definition:</b> <a href="stored__range_8h_source.html#l00054">stored_range.h:54</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a74e5bc8a72d210b3d87b0221b1f69db1"><div class="ttname"><a href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a></div><div class="ttdeci">OStreamProxy err(std::cerr)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00101">libmesh_common.h:101</a></div></div>
<div class="ttc" id="classlibMesh_1_1BoundingBox_html"><div class="ttname"><a href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a></div><div class="ttdoc">Defines a Cartesian bounding box by the two corner extremum. </div><div class="ttdef"><b>Definition:</b> <a href="bounding__box_8h_source.html#l00040">bounding_box.h:40</a></div></div>
<div class="ttc" id="structlibMesh_1_1MeshBase_1_1const__node__iterator_html"><div class="ttname"><a href="structlibMesh_1_1MeshBase_1_1const__node__iterator.html">libMesh::MeshBase::const_node_iterator</a></div><div class="ttdoc">The definition of the const_node_iterator struct. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l02137">mesh_base.h:2137</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a9cc1d9577393d91d5df11f4034e1264b"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a9cc1d9577393d91d5df11f4034e1264b">libMesh::MeshTools::create_nodal_bounding_box</a></div><div class="ttdeci">libMesh::BoundingBox create_nodal_bounding_box(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00583">mesh_tools.C:583</a></div></div>
<div class="ttc" id="classlibMesh_1_1Point_html"><div class="ttname"><a href="classlibMesh_1_1Point.html">libMesh::Point</a></div><div class="ttdoc">A Point defines a location in LIBMESH_DIM dimensional Real space. </div><div class="ttdef"><b>Definition:</b> <a href="point_8h_source.html#l00039">point.h:39</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a227f46dad6159d846d8e6c90a9cfe3cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all data structures and resets to a pristine state. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l00330">330</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;{</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;  <span class="comment">//  _neighboring_processors.clear();</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a580104162e0ee80f5f8fab535c4c32fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::delete_remote_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classlibMesh_1_1Elem.html">Elem</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>extra_ghost_elem_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method takes an input <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="The DistributedMesh class is derived from the MeshBase class, and is intended to provide identical fu...">DistributedMesh</a></code> which may be distributed among all the processors. </p>
<p>Each processor deletes all elements which are neither local elements nor "ghost" elements which touch local elements, and deletes all nodes which are not contained in local or ghost elements. The end result is that a previously serial <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="The DistributedMesh class is derived from the MeshBase class, and is intended to provide identical fu...">DistributedMesh</a></code> will be distributed between processors. Since this method is collective it must be called by all processors.</p>
<p>The std::set is a list of extra elements that you <em>don't</em> want to delete. These will be left on the current processor along with local elements and ghosted neighbors. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01976">1976</a> 行定义.</p>

<p>参考 <a class="el" href="elem_8C_source.html#l01755">libMesh::Elem::active_family_tree()</a>, <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a>, <a class="el" href="mesh__base_8C_source.html#l01591">libMesh::MeshBase::clear_point_locator()</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__communication_8C_source.html#l00172">libMesh::connect_children()</a>, <a class="el" href="mesh__communication_8C_source.html#l00195">libMesh::connect_families()</a>, <a class="el" href="distributed__mesh_8C_source.html#l00711">libMesh::DistributedMesh::delete_elem()</a>, <a class="el" href="distributed__mesh_8C_source.html#l00927">libMesh::DistributedMesh::delete_node()</a>, <a class="el" href="mesh__base_8h_source.html#l01673">libMesh::MeshBase::get_constraint_rows()</a>, <a class="el" href="mesh__base_8h_source.html#l01264">libMesh::MeshBase::ghosting_functors_begin()</a>, <a class="el" href="mesh__base_8h_source.html#l01270">libMesh::MeshBase::ghosting_functors_end()</a>, <a class="el" href="dof__object_8h_source.html#l00823">libMesh::DofObject::id()</a>, <a class="el" href="dof__object_8h_source.html#l00488">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="distributed__mesh_8h_source.html#l00154">libMesh::DistributedMesh::is_serial()</a>, <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>, <a class="el" href="mesh__tools_8C_source.html#l01249">libMesh::MeshTools::libmesh_assert_valid_constraint_rows()</a>, <a class="el" href="mesh__tools_8C_source.html#l01416">libMesh::MeshTools::libmesh_assert_valid_refinement_tree()</a>, <a class="el" href="elem_8C_source.html#l01339">libMesh::Elem::make_links_to_me_remote()</a>, <a class="el" href="distributed__mesh_8h_source.html#l00269">libMesh::DistributedMesh::max_elem_id()</a>, <a class="el" href="distributed__mesh_8h_source.html#l00265">libMesh::DistributedMesh::max_node_id()</a>, <a class="el" href="mesh__tools_8C_source.html#l00801">libMesh::MeshTools::n_levels()</a>, <a class="el" href="distributed__mesh_8C_source.html#l00424">libMesh::DistributedMesh::node_ptr()</a>, <a class="el" href="distributed__mesh_8C_source.html#l00310">libMesh::DistributedMesh::parallel_max_elem_id()</a>, <a class="el" href="distributed__mesh_8C_source.html#l00384">libMesh::DistributedMesh::parallel_max_node_id()</a>, <a class="el" href="parallel__object_8h_source.html#l00114">libMesh::ParallelObject::processor_id()</a>, <a class="el" href="dof__object_8h_source.html#l00898">libMesh::DofObject::processor_id()</a>, <a class="el" href="mesh__communication_8C_source.html#l00140">libMesh::query_ghosting_functors()</a>, <a class="el" href="mesh__communication_8C_source.html#l00313">libMesh::reconnect_nodes()</a> , 以及 <a class="el" href="elem_8h_source.html#l02772">libMesh::Elem::subactive()</a>.</p>
<div class="fragment"><div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;{</div>
<div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;  <span class="comment">// The mesh should know it&#39;s about to be parallelized</span></div>
<div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (!mesh.<a class="code" href="classlibMesh_1_1DistributedMesh.html#a7ac91e48512b794d0d0796272f772cef">is_serial</a>());</div>
<div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;</div>
<div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;  LOG_SCOPE(<span class="stringliteral">&quot;delete_remote_elements()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;</div>
<div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;<span class="preprocessor"></span>  <span class="comment">// We expect maximum ids to be in sync so we can use them to size</span></div>
<div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;  <span class="comment">// vectors</span></div>
<div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>().verify(mesh.<a class="code" href="classlibMesh_1_1DistributedMesh.html#aa5c8614c3742f70fedff8fedaf8757ae">max_node_id</a>()));</div>
<div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>().verify(mesh.<a class="code" href="classlibMesh_1_1DistributedMesh.html#a8c5c21750938c5e7748a5a5b5a60ccb2">max_elem_id</a>()));</div>
<div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> par_max_node_id = mesh.<a class="code" href="classlibMesh_1_1DistributedMesh.html#a07cad642e0767a96bc7f2ca777fb9129">parallel_max_node_id</a>();</div>
<div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> par_max_elem_id = mesh.<a class="code" href="classlibMesh_1_1DistributedMesh.html#afef5ca2eeac818a36787bf500ba19a36">parallel_max_elem_id</a>();</div>
<div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;  libmesh_assert_equal_to (par_max_node_id, mesh.<a class="code" href="classlibMesh_1_1DistributedMesh.html#aa5c8614c3742f70fedff8fedaf8757ae">max_node_id</a>());</div>
<div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;  libmesh_assert_equal_to (par_max_elem_id, mesh.<a class="code" href="classlibMesh_1_1DistributedMesh.html#a8c5c21750938c5e7748a5a5b5a60ccb2">max_elem_id</a>());</div>
<div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;  std::set&lt;const Elem *, CompareElemIdsByLevel&gt; elements_to_keep;</div>
<div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;</div>
<div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;  <span class="comment">// Don&#39;t delete elements that we were explicitly told not to</span></div>
<div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : extra_ghost_elem_ids)</div>
<div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;    {</div>
<div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;      std::vector&lt;const Elem *&gt; active_family;</div>
<div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_AMR</span></div>
<div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;<span class="preprocessor"></span>      <span class="keywordflow">if</span> (!elem-&gt;subactive())</div>
<div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;        elem-&gt;active_family_tree(active_family);</div>
<div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;<span class="preprocessor"></span>        active_family.push_back(elem);</div>
<div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;</div>
<div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; f : active_family)</div>
<div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;        elements_to_keep.insert(f);</div>
<div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;    }</div>
<div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;</div>
<div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;  <span class="comment">// See which elements we still need to keep ghosted, given that</span></div>
<div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;  <span class="comment">// we&#39;re keeping local and unpartitioned elements.</span></div>
<div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;  <a class="code" href="namespacelibMesh.html#a397847170d2f9b1bef560ecd9dc9c20b">query_ghosting_functors</a></div>
<div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;    (mesh, mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">processor_id</a>(),</div>
<div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;     mesh.active_pid_elements_begin(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">processor_id</a>()),</div>
<div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;     mesh.active_pid_elements_end(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">processor_id</a>()),</div>
<div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;     elements_to_keep);</div>
<div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;  <a class="code" href="namespacelibMesh.html#a397847170d2f9b1bef560ecd9dc9c20b">query_ghosting_functors</a></div>
<div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;    (mesh, <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>,</div>
<div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;     mesh.active_pid_elements_begin(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>),</div>
<div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;     mesh.active_pid_elements_end(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>),</div>
<div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;     elements_to_keep);</div>
<div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;</div>
<div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;  <span class="comment">// The inactive elements we need to send should have their</span></div>
<div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;  <span class="comment">// immediate children present.</span></div>
<div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;  <a class="code" href="namespacelibMesh.html#ac1bdc0a8df25c1ddb9116c84db959a6b">connect_children</a>(mesh, mesh.pid_elements_begin(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">processor_id</a>()),</div>
<div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;                   mesh.pid_elements_end(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">processor_id</a>()),</div>
<div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;                   elements_to_keep);</div>
<div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;  <a class="code" href="namespacelibMesh.html#ac1bdc0a8df25c1ddb9116c84db959a6b">connect_children</a>(mesh,</div>
<div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;                   mesh.pid_elements_begin(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>),</div>
<div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;                   mesh.pid_elements_end(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>),</div>
<div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;                   elements_to_keep);</div>
<div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;</div>
<div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;  <span class="comment">// The elements we need should have their ancestors, their</span></div>
<div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;  <span class="comment">// interior_parent links, and their subactive children present too.</span></div>
<div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;  <span class="comment">// If the mesh has any constraint rows, then elements with</span></div>
<div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;  <span class="comment">// constrained nodes need elements with constraining nodes to remain</span></div>
<div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;  <span class="comment">// present.</span></div>
<div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;  <a class="code" href="namespacelibMesh.html#a947a9f109cd8b0617cfb1c28d5525032">connect_families</a>(elements_to_keep, &amp;mesh);</div>
<div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;</div>
<div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;  <span class="comment">// Don&#39;t delete nodes that our semilocal elements need</span></div>
<div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;  <a class="code" href="namespacelibMesh.html#a92dfe93701121a897fc8c48974e1723d">connected_node_set_type</a> connected_nodes;</div>
<div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;  <a class="code" href="namespacelibMesh.html#a21a82eeff03b02b496e253bafac179f8">reconnect_nodes</a>(elements_to_keep, connected_nodes);</div>
<div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;</div>
<div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;  <span class="comment">// Delete all the elements we have no reason to save,</span></div>
<div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;  <span class="comment">// starting with the most refined so that the mesh</span></div>
<div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;  <span class="comment">// is valid at all intermediate steps</span></div>
<div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">n_levels</a> = <a class="code" href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">MeshTools::n_levels</a>(mesh);</div>
<div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;</div>
<div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l = n_levels - 1; l &gt;= 0; --l)</div>
<div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(mesh.level_elements_begin(l),</div>
<div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;                                mesh.level_elements_end(l)))</div>
<div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;      {</div>
<div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;        <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (elem);</div>
<div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;        <span class="comment">// Make sure we don&#39;t leave any invalid pointers</span></div>
<div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">bool</span> keep_me = elements_to_keep.count(elem);</div>
<div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;</div>
<div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;        <span class="keywordflow">if</span> (!keep_me)</div>
<div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;          elem-&gt;make_links_to_me_remote();</div>
<div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;</div>
<div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;        <span class="comment">// delete_elem doesn&#39;t currently invalidate element</span></div>
<div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;        <span class="comment">// iterators... that had better not change</span></div>
<div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;        <span class="keywordflow">if</span> (!keep_me)</div>
<div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;          mesh.<a class="code" href="classlibMesh_1_1DistributedMesh.html#a922f380761a237e606df2cdc29cc12be">delete_elem</a>(elem);</div>
<div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;      }</div>
<div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;</div>
<div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;  <span class="comment">// Delete all the nodes we have no reason to save</span></div>
<div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : mesh.node_ptr_range())</div>
<div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;    {</div>
<div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;      <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(node);</div>
<div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;      <span class="keywordflow">if</span> (!connected_nodes.count(node))</div>
<div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;        mesh.<a class="code" href="classlibMesh_1_1DistributedMesh.html#a9d3e440af1a31ac8d6ef7fa1022e1228">delete_node</a>(node);</div>
<div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;    }</div>
<div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;</div>
<div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;  <span class="comment">// If we had a point locator, it&#39;s invalid now that some of the</span></div>
<div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;  <span class="comment">// elements it pointed to have been deleted.</span></div>
<div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;  mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#acc11230de16adce50cbd3edabe8b778a">clear_point_locator</a>();</div>
<div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;</div>
<div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;  <span class="comment">// Many of our constraint rows may have been for non-local parts of</span></div>
<div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;  <span class="comment">// the mesh, which we don&#39;t need, and which we didn&#39;t specifically</span></div>
<div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;  <span class="comment">// save dependencies for.  The mesh deleted rows for remote nodes</span></div>
<div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;  <span class="comment">// when we deleted those, but let&#39;s delete rows for ghosted nodes.</span></div>
<div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;  <span class="comment">// We can&#39;t do erasure inside a range for</span></div>
<div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a988e7456320f55e731dc8e4bb9373ea3">get_constraint_rows</a>().begin(),</div>
<div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;       end = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a988e7456320f55e731dc8e4bb9373ea3">get_constraint_rows</a>().end();</div>
<div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;       it != end;)</div>
<div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;    {</div>
<div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;      <span class="keyword">auto</span> &amp; row = *it;</div>
<div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;      <span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Node.html">Node</a> * node = row.first;</div>
<div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;      <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(node == mesh.<a class="code" href="classlibMesh_1_1DistributedMesh.html#adaa7a7eda2dc97ef41ebab7e6ed56677">node_ptr</a>(node-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#aeceebf9cd5d53b02df3cd1e9907139e2">id</a>()));</div>
<div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;</div>
<div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;      <span class="keywordflow">if</span> (node-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>() != mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">processor_id</a>())</div>
<div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;        mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a988e7456320f55e731dc8e4bb9373ea3">get_constraint_rows</a>().erase(it++);</div>
<div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;        ++it;</div>
<div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;    }</div>
<div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;</div>
<div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;  <span class="comment">// We now have all remote elements and nodes deleted; our ghosting</span></div>
<div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;  <span class="comment">// functors should be ready to delete any now-redundant cached data</span></div>
<div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;  <span class="comment">// they use too.</span></div>
<div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; gf : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#ad9259eb8d66525051d2ffa8b7aad3101">ghosting_functors_begin</a>(), mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a3d836459ad6c3e023a6d7e4a174f066b">ghosting_functors_end</a>()))</div>
<div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;    gf-&gt;delete_remote_elements();</div>
<div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;</div>
<div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;<span class="preprocessor"></span>  <a class="code" href="namespacelibMesh_1_1MeshTools.html#ad394faa2ff745fcf291cb4c03c20ce73">MeshTools::libmesh_assert_valid_refinement_tree</a>(mesh);</div>
<div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#abca9e4c2c0ab99ae140ccd0212671792">MeshTools::libmesh_assert_valid_constraint_rows</a>(mesh);</div>
<div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;<span class="preprocessor"></span>}</div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a988e7456320f55e731dc8e4bb9373ea3"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a988e7456320f55e731dc8e4bb9373ea3">libMesh::MeshBase::get_constraint_rows</a></div><div class="ttdeci">constraint_rows_type &amp; get_constraint_rows()</div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l01673">mesh_base.h:1673</a></div></div>
<div class="ttc" id="classlibMesh_1_1Node_html"><div class="ttname"><a href="classlibMesh_1_1Node.html">libMesh::Node</a></div><div class="ttdoc">A Node is like a Point, but with more information. </div><div class="ttdef"><b>Definition:</b> <a href="node_8h_source.html#l00052">node.h:52</a></div></div>
<div class="ttc" id="classlibMesh_1_1DistributedMesh_html_aa5c8614c3742f70fedff8fedaf8757ae"><div class="ttname"><a href="classlibMesh_1_1DistributedMesh.html#aa5c8614c3742f70fedff8fedaf8757ae">libMesh::DistributedMesh::max_node_id</a></div><div class="ttdeci">virtual dof_id_type max_node_id() const overridefinal</div><div class="ttdef"><b>Definition:</b> <a href="distributed__mesh_8h_source.html#l00265">distributed_mesh.h:265</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ad394faa2ff745fcf291cb4c03c20ce73"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ad394faa2ff745fcf291cb4c03c20ce73">libMesh::MeshTools::libmesh_assert_valid_refinement_tree</a></div><div class="ttdeci">void libmesh_assert_valid_refinement_tree(const MeshBase &amp;mesh)</div><div class="ttdoc">A function for verifying that elements on this processor have valid descendants and consistent active...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l01416">mesh_tools.C:1416</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_abca9e4c2c0ab99ae140ccd0212671792"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#abca9e4c2c0ab99ae140ccd0212671792">libMesh::MeshTools::libmesh_assert_valid_constraint_rows</a></div><div class="ttdeci">void libmesh_assert_valid_constraint_rows(const MeshBase &amp;mesh)</div><div class="ttdoc">A function for verifying that all mesh constraint rows express relations between nodes and elements t...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l01249">mesh_tools.C:1249</a></div></div>
<div class="ttc" id="classlibMesh_1_1DistributedMesh_html_afef5ca2eeac818a36787bf500ba19a36"><div class="ttname"><a href="classlibMesh_1_1DistributedMesh.html#afef5ca2eeac818a36787bf500ba19a36">libMesh::DistributedMesh::parallel_max_elem_id</a></div><div class="ttdeci">dof_id_type parallel_max_elem_id() const </div><div class="ttdef"><b>Definition:</b> <a href="distributed__mesh_8C_source.html#l00310">distributed_mesh.C:310</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a3d836459ad6c3e023a6d7e4a174f066b"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a3d836459ad6c3e023a6d7e4a174f066b">libMesh::MeshBase::ghosting_functors_end</a></div><div class="ttdeci">std::set&lt; GhostingFunctor * &gt;::const_iterator ghosting_functors_end() const </div><div class="ttdoc">End of range of ghosting functors. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l01270">mesh_base.h:1270</a></div></div>
<div class="ttc" id="classlibMesh_1_1DistributedMesh_html_a07cad642e0767a96bc7f2ca777fb9129"><div class="ttname"><a href="classlibMesh_1_1DistributedMesh.html#a07cad642e0767a96bc7f2ca777fb9129">libMesh::DistributedMesh::parallel_max_node_id</a></div><div class="ttdeci">dof_id_type parallel_max_node_id() const </div><div class="ttdef"><b>Definition:</b> <a href="distributed__mesh_8C_source.html#l00384">distributed_mesh.C:384</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a947a9f109cd8b0617cfb1c28d5525032"><div class="ttname"><a href="namespacelibMesh.html#a947a9f109cd8b0617cfb1c28d5525032">libMesh::connect_families</a></div><div class="ttdeci">void connect_families(std::set&lt; const Elem *, CompareElemIdsByLevel &gt; &amp;connected_elements, const MeshBase *mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l00195">mesh_communication.C:195</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdoc">An invalid processor_id to distinguish DoFs that have not been assigned to a processor. </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00488">dof_object.h:488</a></div></div>
<div class="ttc" id="classlibMesh_1_1DistributedMesh_html_a922f380761a237e606df2cdc29cc12be"><div class="ttname"><a href="classlibMesh_1_1DistributedMesh.html#a922f380761a237e606df2cdc29cc12be">libMesh::DistributedMesh::delete_elem</a></div><div class="ttdeci">virtual void delete_elem(Elem *e) overridefinal</div><div class="ttdoc">Removes element e from the mesh. </div><div class="ttdef"><b>Definition:</b> <a href="distributed__mesh_8C_source.html#l00711">distributed_mesh.C:711</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a6775c045a6c8e84299b5467df9fc81ae"><div class="ttname"><a href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; IndexType &gt; as_range(const std::pair&lt; IndexType, IndexType &gt; &amp;p)</div><div class="ttdoc">Helper function that allows us to treat a homogenous pair as a range. </div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ae15ece869d4ef3d283edb677942e8439"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">libMesh::MeshTools::n_levels</a></div><div class="ttdeci">unsigned int n_levels(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00801">mesh_tools.C:801</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_acc11230de16adce50cbd3edabe8b778a"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#acc11230de16adce50cbd3edabe8b778a">libMesh::MeshBase::clear_point_locator</a></div><div class="ttdeci">void clear_point_locator()</div><div class="ttdoc">Releases the current PointLocator object. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8C_source.html#l01591">mesh_base.C:1591</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1DistributedMesh_html_a7ac91e48512b794d0d0796272f772cef"><div class="ttname"><a href="classlibMesh_1_1DistributedMesh.html#a7ac91e48512b794d0d0796272f772cef">libMesh::DistributedMesh::is_serial</a></div><div class="ttdeci">virtual bool is_serial() const overridefinal</div><div class="ttdef"><b>Definition:</b> <a href="distributed__mesh_8h_source.html#l00154">distributed_mesh.h:154</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a21a82eeff03b02b496e253bafac179f8"><div class="ttname"><a href="namespacelibMesh.html#a21a82eeff03b02b496e253bafac179f8">libMesh::reconnect_nodes</a></div><div class="ttdeci">void reconnect_nodes(const std::set&lt; const Elem *, CompareElemIdsByLevel &gt; &amp;connected_elements, connected_node_set_type &amp;connected_nodes)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l00313">mesh_communication.C:313</a></div></div>
<div class="ttc" id="classlibMesh_1_1DistributedMesh_html_adaa7a7eda2dc97ef41ebab7e6ed56677"><div class="ttname"><a href="classlibMesh_1_1DistributedMesh.html#adaa7a7eda2dc97ef41ebab7e6ed56677">libMesh::DistributedMesh::node_ptr</a></div><div class="ttdeci">virtual const Node * node_ptr(const dof_id_type i) const overridefinal</div><div class="ttdef"><b>Definition:</b> <a href="distributed__mesh_8C_source.html#l00424">distributed_mesh.C:424</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a92dfe93701121a897fc8c48974e1723d"><div class="ttname"><a href="namespacelibMesh.html#a92dfe93701121a897fc8c48974e1723d">libMesh::connected_node_set_type</a></div><div class="ttdeci">std::set&lt; const Node * &gt; connected_node_set_type</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8h_source.html#l00281">mesh_communication.h:281</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a397847170d2f9b1bef560ecd9dc9c20b"><div class="ttname"><a href="namespacelibMesh.html#a397847170d2f9b1bef560ecd9dc9c20b">libMesh::query_ghosting_functors</a></div><div class="ttdeci">void query_ghosting_functors(const MeshBase &amp;mesh, processor_id_type pid, MeshBase::const_element_iterator elem_it, MeshBase::const_element_iterator elem_end, std::set&lt; const Elem *, CompareElemIdsByLevel &gt; &amp;connected_elements)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l00140">mesh_communication.C:140</a></div></div>
<div class="ttc" id="classlibMesh_1_1DistributedMesh_html_a8c5c21750938c5e7748a5a5b5a60ccb2"><div class="ttname"><a href="classlibMesh_1_1DistributedMesh.html#a8c5c21750938c5e7748a5a5b5a60ccb2">libMesh::DistributedMesh::max_elem_id</a></div><div class="ttdeci">virtual dof_id_type max_elem_id() const overridefinal</div><div class="ttdef"><b>Definition:</b> <a href="distributed__mesh_8h_source.html#l00269">distributed_mesh.h:269</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ad9259eb8d66525051d2ffa8b7aad3101"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ad9259eb8d66525051d2ffa8b7aad3101">libMesh::MeshBase::ghosting_functors_begin</a></div><div class="ttdeci">std::set&lt; GhostingFunctor * &gt;::const_iterator ghosting_functors_begin() const </div><div class="ttdoc">Beginning of range of ghosting functors. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l01264">mesh_base.h:1264</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ac1bdc0a8df25c1ddb9116c84db959a6b"><div class="ttname"><a href="namespacelibMesh.html#ac1bdc0a8df25c1ddb9116c84db959a6b">libMesh::connect_children</a></div><div class="ttdeci">void connect_children(const MeshBase &amp;mesh, MeshBase::const_element_iterator elem_it, MeshBase::const_element_iterator elem_end, std::set&lt; const Elem *, CompareElemIdsByLevel &gt; &amp;connected_elements)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l00172">mesh_communication.C:172</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aeceebf9cd5d53b02df3cd1e9907139e2"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aeceebf9cd5d53b02df3cd1e9907139e2">libMesh::DofObject::id</a></div><div class="ttdeci">dof_id_type id() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00823">dof_object.h:823</a></div></div>
<div class="ttc" id="classlibMesh_1_1DistributedMesh_html_a9d3e440af1a31ac8d6ef7fa1022e1228"><div class="ttname"><a href="classlibMesh_1_1DistributedMesh.html#a9d3e440af1a31ac8d6ef7fa1022e1228">libMesh::DistributedMesh::delete_node</a></div><div class="ttdeci">virtual void delete_node(Node *n) overridefinal</div><div class="ttdoc">Removes the Node n from the mesh. </div><div class="ttdef"><b>Definition:</b> <a href="distributed__mesh_8C_source.html#l00927">distributed_mesh.C:927</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_ae1e7d1a1118f63d9889a761c27433bbc"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">libMesh::ParallelObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00114">parallel_object.h:114</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_a0e8748b2c01f78902c9c432ad79cf546"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">libMesh::DofObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00898">dof_object.h:898</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aabdd0e5938cd28818a10628cf2c716cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::find_global_indices </td>
          <td>(</td>
          <td class="paramtype">const Parallel::Communicator &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method determines a globally unique, partition-agnostic index for each object in the input range. </p>

<p>在文件 <a class="el" href="mesh__communication__global__indices_8C_source.html">mesh_communication_global_indices.C</a> 第 <a class="el" href="mesh__communication__global__indices_8C_source.html#l00748">748</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__sort_8C_source.html#l00264">libMesh::Parallel::Sort&lt; KeyType, IdxType &gt;::bin()</a>, <a class="el" href="mesh__generation_8C_source.html#l00078">libMesh::MeshTools::Generation::Private::idx()</a>, <a class="el" href="dof__object_8h_source.html#l00488">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>, <a class="el" href="libmesh__common_8h_source.html#l00516">libMesh::libmesh_ignore()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a>, <a class="el" href="libmesh__common_8h_source.html#l00143">libMesh::Real</a> , 以及 <a class="el" href="parallel__sort_8C_source.html#l00064">libMesh::Parallel::Sort&lt; KeyType, IdxType &gt;::sort()</a>.</p>

<p>参考自 <a class="el" href="parmetis__partitioner_8C_source.html#l00241">libMesh::ParmetisPartitioner::initialize()</a>, <a class="el" href="metis__partitioner_8C_source.html#l00068">libMesh::MetisPartitioner::partition_range()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00351">libMesh::Partitioner::partition_unpartitioned_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;{</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;find_global_indices()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;  <span class="comment">// This method determines partition-agnostic global indices</span></div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;  <span class="comment">// for nodes and elements.</span></div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;  <span class="comment">// Algorithm:</span></div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;  <span class="comment">// (1) compute the Hilbert key for each local node/element</span></div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;  <span class="comment">// (2) perform a parallel sort of the Hilbert key</span></div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;  <span class="comment">// (3) get the min/max value on each processor</span></div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;  <span class="comment">// (4) determine the position in the global ranking for</span></div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;  <span class="comment">//     each local object</span></div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;  index_map.clear();</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;  std::size_t n_objects = std::distance (begin, end);</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;  index_map.reserve(n_objects);</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;  <span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Point.html">Point</a> bboxinv = invert_bbox(bbox);</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;  <span class="comment">// (1) compute Hilbert keys</span></div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;  <span class="comment">// These aren&#39;t trivial to compute, and we will need them again.</span></div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;  <span class="comment">// But the binsort will sort the input vector, trashing the order</span></div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;  <span class="comment">// that we&#39;d like to rely on.  So, two vectors...</span></div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;  std::vector&lt;Parallel::DofObjectKey&gt;</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;    sorted_hilbert_keys,</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;    hilbert_keys;</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;  sorted_hilbert_keys.reserve(n_objects);</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;  hilbert_keys.reserve(n_objects);</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;  {</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    LOG_SCOPE(<span class="stringliteral">&quot;compute_hilbert_indices()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> my_pid = communicator.rank();</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;    <span class="keywordflow">for</span> (ForwardIterator it=begin; it!=end; ++it)</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;      {</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi(get_dofobject_key (**it, bbox, bboxinv));</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;        hilbert_keys.push_back(hi);</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> pid = (*it)-&gt;processor_id();</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;        <span class="keywordflow">if</span> (pid == my_pid)</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;          sorted_hilbert_keys.push_back(hi);</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;        <span class="comment">// someone needs to take care of unpartitioned objects!</span></div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;        <span class="keywordflow">if</span> ((my_pid == 0) &amp;&amp;</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;            (pid == <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>))</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;          sorted_hilbert_keys.push_back(hi);</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;      }</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;  }</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;  <span class="comment">// (2) parallel sort the Hilbert keys</span></div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;  START_LOG (<span class="stringliteral">&quot;parallel_sort()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;  <a class="code" href="classlibMesh_1_1Parallel_1_1Sort.html">Parallel::Sort&lt;Parallel::DofObjectKey&gt;</a> sorter (communicator,</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;                                                 sorted_hilbert_keys);</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;  sorter.sort();</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;  STOP_LOG (<span class="stringliteral">&quot;parallel_sort()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;  <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; my_bin = sorter.bin();</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;  <span class="comment">// The number of objects in my_bin on each processor</span></div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;  std::vector&lt;unsigned int&gt; bin_sizes(communicator.size());</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;  communicator.allgather (static_cast&lt;unsigned int&gt;(my_bin.size()), bin_sizes);</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;  <span class="comment">// The offset of my first global index</span></div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_offset = 0;</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> pid : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(communicator.rank()))</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;    my_offset += bin_sizes[pid];</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;  <span class="comment">// (3) get the max value on each processor</span></div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;  std::vector&lt;Parallel::DofObjectKey&gt;</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;    upper_bounds(1);</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;  <span class="keywordflow">if</span> (!my_bin.empty())</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;    upper_bounds[0] = my_bin.back();</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;  communicator.allgather (upper_bounds, <span class="comment">/* identical_buffer_sizes = */</span> <span class="keyword">true</span>);</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;  <span class="comment">// Be careful here.  The *_upper_bounds will be used to find the processor</span></div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;  <span class="comment">// a given object belongs to.  So, if a processor contains no objects (possible!)</span></div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;  <span class="comment">// then copy the bound from the lower processor id.</span></div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : <a class="code" href="classlibMesh_1_1IntRange.html">IntRange&lt;processor_id_type&gt;</a>(1, communicator.size()))</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;    <span class="keywordflow">if</span> (!bin_sizes[p]) upper_bounds[p] = upper_bounds[p-1];</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;  <span class="comment">// (4) determine the position in the global ranking for</span></div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;  <span class="comment">//     each local object</span></div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;  {</div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;    <span class="comment">//----------------------------------------------</span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;    <span class="comment">// all objects, not just local ones</span></div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;</div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;    <span class="comment">// Request sets to send to each processor</span></div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;    std::map&lt;processor_id_type, std::vector&lt;Parallel::DofObjectKey&gt;&gt;</div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;      requested_ids;</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;    <span class="comment">// Results to gather from each processor</span></div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;    std::map&lt;processor_id_type, std::vector&lt;dof_id_type&gt;&gt;</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;      filled_request;</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;    <span class="comment">// build up list of requests</span></div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;    std::vector&lt;Parallel::DofObjectKey&gt;::const_iterator hi =</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;      hilbert_keys.begin();</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    <span class="keywordflow">for</span> (ForwardIterator it = begin; it != end; ++it)</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;      {</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;        <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (hi != hilbert_keys.end());</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;        std::vector&lt;Parallel::DofObjectKey&gt;::iterator lb =</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;          std::lower_bound(upper_bounds.begin(), upper_bounds.end(),</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;                           *hi);</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> pid =</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;          cast_int&lt;processor_id_type&gt;</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;          (std::distance (upper_bounds.begin(), lb));</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;        libmesh_assert_less (pid, communicator.size());</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;        requested_ids[pid].push_back(*hi);</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;        ++hi;</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;        <span class="comment">// go ahead and put pid in index_map, that way we</span></div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;        <span class="comment">// don&#39;t have to repeat the std::lower_bound()</span></div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;        index_map.push_back(pid);</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;      }</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;  <span class="keyword">auto</span> gather_functor =</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    [</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;<span class="preprocessor"></span>     &amp; upper_bounds,</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;     &amp; communicator,</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;<span class="preprocessor"></span>     &amp; bbox,</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;     &amp; my_bin,</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;       my_offset</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;    ]</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    (<a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a>, <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; keys,</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;     std::vector&lt;dof_id_type&gt; &amp; global_ids)</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;    {</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;      <span class="comment">// Ignore unused lambda capture warnings in devel mode</span></div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;      <a class="code" href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libmesh_ignore</a>(bbox);</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;      <span class="comment">// Fill the requests</span></div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;      <span class="keyword">const</span> std::size_t keys_size = keys.size();</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;      global_ids.clear();</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;      global_ids.reserve(keys_size);</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;      <span class="keywordflow">for</span> (std::size_t <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>=0; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a> != keys_size; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>++)</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;        {</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> &amp; hilbert_indices = keys[<a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>];</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;          libmesh_assert_less_equal (hilbert_indices, upper_bounds[communicator.rank()]);</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;          <span class="comment">// find the requested index in my node bin</span></div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;          std::vector&lt;Parallel::DofObjectKey&gt;::const_iterator pos =</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;            std::lower_bound (my_bin.begin(), my_bin.end(), hilbert_indices);</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;          <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (pos != my_bin.end());</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;<span class="preprocessor"></span>          <span class="comment">// If we could not find the requested Hilbert index in</span></div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;          <span class="comment">// my_bin, something went terribly wrong, possibly the</span></div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;          <span class="comment">// Mesh was displaced differently on different processors,</span></div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;          <span class="comment">// and therefore the Hilbert indices don&#39;t agree.</span></div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;          <span class="keywordflow">if</span> (*pos != hilbert_indices)</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;            {</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;              <span class="comment">// The input will be hilbert_indices.  We convert it</span></div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;              <span class="comment">// to BitVecType using the operator= provided by the</span></div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;              <span class="comment">// BitVecType class. BitVecType is a CBigBitVec!</span></div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;              Hilbert::BitVecType input;</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_UNIQUE_ID</span></div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;<span class="preprocessor"></span>              input = hilbert_indices.first;</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;<span class="preprocessor"></span>              input = hilbert_indices;</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;              <span class="comment">// Get output in a vector of CBigBitVec</span></div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;              std::vector&lt;CBigBitVec&gt; output(3);</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;              <span class="comment">// Call the indexToCoords function</span></div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;              Hilbert::indexToCoords(output.data(), 8*<span class="keyword">sizeof</span>(Hilbert::inttype), 3, input);</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;              <span class="comment">// The entries in the output racks are integers in the</span></div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;              <span class="comment">// range [0, Hilbert::inttype::max] which can be</span></div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;              <span class="comment">// converted to floating point values in [0,1] and</span></div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;              <span class="comment">// finally to actual values using the bounding box.</span></div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> max_int_as_real =</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;                <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a><span class="keyword">&gt;</span>(std::numeric_limits&lt;Hilbert::inttype&gt;::max());</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;</div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;              <span class="comment">// Get the points in [0,1]^3.  The zeroth rack of each entry in</span></div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;              <span class="comment">// &#39;output&#39; maps to the normalized x, y, and z locations,</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;              <span class="comment">// respectively.</span></div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;              <a class="code" href="classlibMesh_1_1Point.html">Point</a> p_hat(static_cast&lt;Real&gt;(output[0].racks()[0]) / max_int_as_real,</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;                          static_cast&lt;Real&gt;(output[1].racks()[0]) / max_int_as_real,</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;                          static_cast&lt;Real&gt;(output[2].racks()[0]) / max_int_as_real);</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;              <span class="comment">// Convert the points from [0,1]^3 to their actual (x,y,z) locations</span></div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;              <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a></div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;                xmin = bbox.first(0),</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;                xmax = bbox.second(0),</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;                ymin = bbox.first(1),</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;                ymax = bbox.second(1),</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;                zmin = bbox.first(2),</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;                zmax = bbox.second(2);</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;              <span class="comment">// Convert the points from [0,1]^3 to their actual (x,y,z) locations</span></div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;              <a class="code" href="classlibMesh_1_1Point.html">Point</a> p(xmin + (xmax-xmin)*p_hat(0),</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;                      ymin + (ymax-ymin)*p_hat(1),</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;                      zmin + (zmax-zmin)*p_hat(2));</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;              libmesh_error_msg(<span class="stringliteral">&quot;Could not find hilbert indices: &quot;</span></div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;                                &lt;&lt; hilbert_indices</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;                                &lt;&lt; <span class="stringliteral">&quot; corresponding to point &quot;</span> &lt;&lt; p);</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;            }</div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;          <span class="comment">// Finally, assign the global index based off the position of the index</span></div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;          <span class="comment">// in my array, properly offset.</span></div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;          global_ids.push_back (cast_int&lt;dof_id_type&gt;(std::distance(my_bin.begin(), pos) + my_offset));</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;        }</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;    };</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;  <span class="keyword">auto</span> action_functor =</div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;    [&amp;filled_request]</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;    (processor_id_type pid,</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;     <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp;,</div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;     <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; global_ids)</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;    {</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;      filled_request[pid] = global_ids;</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;    };</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> * ex = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;  Parallel::pull_parallel_vector_data</div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;    (communicator, requested_ids, gather_functor, action_functor, ex);</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;    <span class="comment">// We now have all the filled requests, so we can loop through our</span></div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;    <span class="comment">// nodes once and assign the global index to each one.</span></div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;    {</div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;      std::vector&lt;std::vector&lt;dof_id_type&gt;::const_iterator&gt;</div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;        next_obj_on_proc; next_obj_on_proc.reserve(communicator.size());</div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> pid : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(communicator.size()))</div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;        next_obj_on_proc.push_back(filled_request[pid].begin());</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cnt=0;</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;      <span class="keywordflow">for</span> (ForwardIterator it = begin; it != end; ++it, cnt++)</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;        {</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;          <span class="keyword">const</span> processor_id_type pid = cast_int&lt;processor_id_type&gt;</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;            (index_map[cnt]);</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;          libmesh_assert_less (pid, communicator.size());</div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;          <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (next_obj_on_proc[pid] != filled_request[pid].end());</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;</div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> global_index = *next_obj_on_proc[pid];</div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;          index_map[cnt] = global_index;</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;</div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;          ++next_obj_on_proc[pid];</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;        }</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;    }</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;  }</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;</div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;  libmesh_assert_equal_to(index_map.size(), n_objects);</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1IntRange_html"><div class="ttname"><a href="classlibMesh_1_1IntRange.html">libMesh::IntRange</a></div><div class="ttdoc">The IntRange templated class is intended to make it easy to loop over integers which are indices of a...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00053">int_range.h:53</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_aefbe7c94fa1895557e56fdc001710b16"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">libMesh::Parallel::DofObjectKey</a></div><div class="ttdeci">std::pair&lt; Hilbert::HilbertIndices, unique_id_type &gt; DofObjectKey</div><div class="ttdef"><b>Definition:</b> <a href="parallel__hilbert_8h_source.html#l00080">parallel_hilbert.h:80</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af18245d4f872c36a41fc74086bda3e80"><div class="ttname"><a href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00104">id_types.h:104</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a43f45640aab1af26176e69592c666432"><div class="ttname"><a href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libMesh::libmesh_ignore</a></div><div class="ttdeci">void libmesh_ignore(const Args &amp;...)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00516">libmesh_common.h:516</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdoc">An invalid processor_id to distinguish DoFs that have not been assigned to a processor. </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00488">dof_object.h:488</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="namespacelibMesh_html_aef28359fb4851abec08fc99cfbac118d"><div class="ttname"><a href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">libMesh::Real</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE Real</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00143">libmesh_common.h:143</a></div></div>
<div class="ttc" id="classlibMesh_1_1Parallel_1_1Sort_html"><div class="ttname"><a href="classlibMesh_1_1Parallel_1_1Sort.html">libMesh::Parallel::Sort</a></div><div class="ttdoc">The parallel sorting method is templated on the type of data which is to be sorted. </div><div class="ttdef"><b>Definition:</b> <a href="parallel__sort_8h_source.html#l00055">parallel_sort.h:55</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="classlibMesh_1_1Point_html"><div class="ttname"><a href="classlibMesh_1_1Point.html">libMesh::Point</a></div><div class="ttdoc">A Point defines a location in LIBMESH_DIM dimensional Real space. </div><div class="ttdef"><b>Definition:</b> <a href="point_8h_source.html#l00039">point.h:39</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private_html_acd3e3226af58784e414a3c242a3ef740"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">libMesh::MeshTools::Generation::Private::idx</a></div><div class="ttdeci">unsigned int idx(const ElemType type, const unsigned int nx, const unsigned int i, const unsigned int j)</div><div class="ttdoc">A useful inline function which replaces the macros used previously. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__generation_8C_source.html#l00078">mesh_generation.C:78</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afb1899390ba017ecd73db2856a3b68e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::find_local_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>, <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method determines a locally unique, contiguous index for each object in the input range. </p>

<p>在文件 <a class="el" href="mesh__communication__global__indices_8C_source.html">mesh_communication_global_indices.C</a> 第 <a class="el" href="mesh__communication__global__indices_8C_source.html#l00710">710</a> 行定义.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l01067">libMesh::Partitioner::_find_global_index_by_pid_map()</a>.</p>
<div class="fragment"><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;{</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;find_local_indices()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;  <span class="comment">// This method determines id-agnostic local indices</span></div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;  <span class="comment">// for nodes and elements by sorting Hilbert keys.</span></div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;  index_map.clear();</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;  <span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Point.html">Point</a> bboxinv = invert_bbox(bbox);</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;  <span class="comment">// (1) compute Hilbert keys</span></div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;  <span class="comment">// These aren&#39;t trivial to compute, and we will need them again.</span></div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;  <span class="comment">// But the binsort will sort the input vector, trashing the order</span></div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;  <span class="comment">// that we&#39;d like to rely on.  So, two vectors...</span></div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;  std::map&lt;Parallel::DofObjectKey, dof_id_type&gt; hilbert_keys;</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;  {</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    LOG_SCOPE(<span class="stringliteral">&quot;local_hilbert_indices&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;    <span class="keywordflow">for</span> (ForwardIterator it=begin; it!=end; ++it)</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;      {</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi(get_dofobject_key ((**it), bbox, bboxinv));</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;        hilbert_keys.emplace(hi, (*it)-&gt;id());</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;      }</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;  }</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;  {</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;    <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> cnt = 0;</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> key_val : hilbert_keys)</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;      index_map[key_val.second] = cnt++;</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;  }</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_aefbe7c94fa1895557e56fdc001710b16"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">libMesh::Parallel::DofObjectKey</a></div><div class="ttdeci">std::pair&lt; Hilbert::HilbertIndices, unique_id_type &gt; DofObjectKey</div><div class="ttdef"><b>Definition:</b> <a href="parallel__hilbert_8h_source.html#l00080">parallel_hilbert.h:80</a></div></div>
<div class="ttc" id="classlibMesh_1_1Point_html"><div class="ttname"><a href="classlibMesh_1_1Point.html">libMesh::Point</a></div><div class="ttdoc">A Point defines a location in LIBMESH_DIM dimensional Real space. </div><div class="ttdef"><b>Definition:</b> <a href="point_8h_source.html#l00039">point.h:39</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abb61dcc1aa8a3bda4fc67b2862cd2872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::gather </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a>&#160;</td>
          <td class="paramname"><em>root_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method takes an input <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="The DistributedMesh class is derived from the MeshBase class, and is intended to provide identical fu...">DistributedMesh</a></code> which may be distributed among all the processors. </p>
<p>Each processor then sends its local nodes and elements to processor <code>root_id</code>. The end result is that a previously distributed <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="The DistributedMesh class is derived from the MeshBase class, and is intended to provide identical fu...">DistributedMesh</a></code> will be serialized on processor <code>root_id</code>. Since this method is collective it must be called by all processors. For the special case of <code>root_id</code> equal to <code><a class="el" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4" title="An invalid processor_id to distinguish DoFs that have not been assigned to a processor. ">DofObject::invalid_processor_id</a></code> this function performs an allgather. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01153">1153</a> 行定义.</p>

<p>参考自 <a class="el" href="mesh__communication_8h_source.html#l00135">allgather()</a>.</p>
<div class="fragment"><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;{</div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;  <span class="comment">// no MPI == one processor, no need for this method...</span></div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;  <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a48cb46d7416585880081c5e64504da1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::gather_neighboring_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l00513">513</a> 行定义.</p>

<p>参考自 <a class="el" href="nemesis__io_8C_source.html#l00198">libMesh::Nemesis_IO::read()</a>.</p>
<div class="fragment"><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;{</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;  <span class="comment">// no MPI == one processor, no need for this method...</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;  <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a737da6ee13b781ac7aef37851a99af58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_elems_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy ids of ghost elements from their local processors. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01634">1634</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a61954736112b225cf323b93f57cd70ed">libMesh::MeshBase::query_elem_ptr()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a263b1727104cb46623b6e522cf90e6d4">libMesh::MeshBase::renumber_elem()</a>, <a class="el" href="parallel__ghost__sync_8h_source.html#l00357">libMesh::Parallel::sync_dofobject_data_by_id()</a> , 以及 <a class="el" href="parallel__ghost__sync_8h_source.html#l00453">libMesh::Parallel::sync_element_data_by_parent_id()</a>.</p>

<p>参考自 <a class="el" href="mesh__refinement_8C_source.html#l01468">libMesh::MeshRefinement::_refine_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;{</div>
<div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;</div>
<div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_elems_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;</div>
<div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;  SyncIds syncids(mesh, &amp;<a class="code" href="classlibMesh_1_1MeshBase.html#a263b1727104cb46623b6e522cf90e6d4">MeshBase::renumber_elem</a>);</div>
<div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a29c79f0c66ce48d4b3801a77b139df3b">Parallel::sync_element_data_by_parent_id</a></div>
<div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;    (mesh, mesh.active_elements_begin(),</div>
<div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;     mesh.active_elements_end(), syncids);</div>
<div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;</div>
<div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_UNIQUE_ID</span></div>
<div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;<span class="preprocessor"></span>  SyncUniqueIds&lt;Elem&gt; syncuniqueids(mesh, &amp;<a class="code" href="classlibMesh_1_1MeshBase.html#a61954736112b225cf323b93f57cd70ed">MeshBase::query_elem_ptr</a>);</div>
<div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">Parallel::sync_dofobject_data_by_id</a></div>
<div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;    (mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>(), mesh.active_elements_begin(),</div>
<div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;     mesh.active_elements_end(), syncuniqueids);</div>
<div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;<span class="preprocessor"></span>}</div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_ac7d4f06bb34625465942e6b8d10f135e"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">libMesh::Parallel::sync_dofobject_data_by_id</a></div><div class="ttdeci">void sync_dofobject_data_by_id(const Communicator &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</div><div class="ttdoc">Request data about a range of ghost dofobjects uniquely identified by their id. </div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00357">parallel_ghost_sync.h:357</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a61954736112b225cf323b93f57cd70ed"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a61954736112b225cf323b93f57cd70ed">libMesh::MeshBase::query_elem_ptr</a></div><div class="ttdeci">virtual const Elem * query_elem_ptr(const dof_id_type i) const =0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a263b1727104cb46623b6e522cf90e6d4"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a263b1727104cb46623b6e522cf90e6d4">libMesh::MeshBase::renumber_elem</a></div><div class="ttdeci">virtual void renumber_elem(dof_id_type old_id, dof_id_type new_id)=0</div><div class="ttdoc">Changes the id of element old_id, both by changing elem(old_id)-&amp;gt;id() and by moving elem(old_id) in th...</div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a29c79f0c66ce48d4b3801a77b139df3b"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a29c79f0c66ce48d4b3801a77b139df3b">libMesh::Parallel::sync_element_data_by_parent_id</a></div><div class="ttdeci">void sync_element_data_by_parent_id(MeshBase &amp;mesh, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</div><div class="ttdoc">Request data about a range of ghost elements uniquely identified by their parent id and which child t...</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00453">parallel_ghost_sync.h:453</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae09a612b52ccb019c89165d3bfce5773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_new_node_proc_ids_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming all processor ids on nodes touching local elements are parallel consistent, this function makes processor ids on new nodes on other processors parallel consistent as well. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01814">1814</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="dof__object_8h_source.html#l00488">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="mesh__tools_8C_source.html#l01894">libMesh::MeshTools::libmesh_assert_parallel_consistent_new_node_procids()</a>, <a class="el" href="mesh__tools_8C_source.html#l01932">libMesh::MeshTools::libmesh_assert_parallel_consistent_procids&lt; Node &gt;()</a>, <a class="el" href="mesh__communication_8C_source.html#l01308">mesh</a>, <a class="el" href="elem_8h_source.html#l02329">libMesh::Elem::node_ref()</a>, <a class="el" href="elem_8h_source.html#l02450">libMesh::Elem::node_ref_range()</a>, <a class="el" href="dof__object_8h_source.html#l00898">libMesh::DofObject::processor_id()</a>, <a class="el" href="parallel__ghost__sync_8h_source.html#l00780">libMesh::Parallel::sync_node_data_by_element_id()</a> , 以及 <a class="el" href="parallel__ghost__sync_8h_source.html#l00580">libMesh::Parallel::sync_node_data_by_element_id_once()</a>.</p>

<p>参考自 <a class="el" href="mesh__communication_8C_source.html#l01934">make_new_nodes_parallel_consistent()</a>.</p>
<div class="fragment"><div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;{</div>
<div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_new_node_proc_ids_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;</div>
<div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;</div>
<div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;  <span class="comment">// When this function is called, each section of a parallelized mesh</span></div>
<div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;  <span class="comment">// should be in the following state:</span></div>
<div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;  <span class="comment">// Local nodes should have unique authoritative ids,</span></div>
<div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;  <span class="comment">// and new nodes should be unpartitioned.</span></div>
<div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;  <span class="comment">// New ghost nodes touching local elements should be unpartitioned.</span></div>
<div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;</div>
<div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;  <span class="comment">// We may not have consistent processor ids for new nodes (because a</span></div>
<div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;  <span class="comment">// node may be old and partitioned on one processor but new and</span></div>
<div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;  <span class="comment">// unpartitioned on another) when we start</span></div>
<div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;<span class="preprocessor"></span>  <a class="code" href="namespacelibMesh_1_1MeshTools.html#afa9230889a01ee0f9489a3d3eb4d70c2">MeshTools::libmesh_assert_parallel_consistent_procids&lt;Node&gt;</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div>
<div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;  <span class="comment">// MeshTools::libmesh_assert_parallel_consistent_new_node_procids(mesh);</span></div>
<div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;  <span class="comment">// We have two kinds of new nodes.  *NEW* nodes are unpartitioned on</span></div>
<div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;  <span class="comment">// all processors: we need to use a id-independent (i.e. dumb)</span></div>
<div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;  <span class="comment">// heuristic to partition them.  But &quot;new&quot; nodes are newly created</span></div>
<div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;  <span class="comment">// on some processors (when ghost elements are refined) yet</span></div>
<div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;  <span class="comment">// correspond to existing nodes on other processors: we need to use</span></div>
<div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;  <span class="comment">// the existing processor id for them.</span></div>
<div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;  <span class="comment">// A node which is &quot;new&quot; on one processor will be associated with at</span></div>
<div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;  <span class="comment">// least one ghost element, and we can just query that ghost</span></div>
<div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;  <span class="comment">// element&#39;s owner to find out the correct processor id.</span></div>
<div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;</div>
<div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;  <span class="keyword">auto</span> node_unpartitioned =</div>
<div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;    [](<span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Elem.html">Elem</a> * elem, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> local_node_num)</div>
<div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;    { <span class="keywordflow">return</span> elem-&gt;<a class="code" href="classlibMesh_1_1Elem.html#a85d07487b3b947bee2ee977d46c4b864">node_ref</a>(local_node_num).<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>() ==</div>
<div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;        <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>; };</div>
<div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;</div>
<div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;  SyncProcIds sync(mesh);</div>
<div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;</div>
<div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a690437fd4e60ad2cedf64948c3f21519">sync_node_data_by_element_id_once</a></div>
<div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;    (mesh, mesh.not_local_elements_begin(),</div>
<div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;     mesh.not_local_elements_end(), <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(),</div>
<div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;     node_unpartitioned, sync);</div>
<div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;</div>
<div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;  <span class="comment">// Nodes should now be unpartitioned iff they are truly new; those</span></div>
<div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;  <span class="comment">// are the *only* nodes we will touch.</span></div>
<div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;<span class="preprocessor"></span>  <a class="code" href="namespacelibMesh_1_1MeshTools.html#a2699035cfb89b82a96bac61ad9ae291f">MeshTools::libmesh_assert_parallel_consistent_new_node_procids</a>(mesh);</div>
<div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;  NodeWasNew node_was_new(mesh);</div>
<div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;</div>
<div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;  <span class="comment">// Set the lowest processor id we can on truly new nodes</span></div>
<div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : mesh.element_ptr_range())</div>
<div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : elem-&gt;<a class="code" href="classlibMesh_1_1Elem.html#a648b34a7475203667c75597913822fdf">node_ref_range</a>())</div>
<div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;      <span class="keywordflow">if</span> (node_was_new.was_new.count(&amp;node))</div>
<div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;        {</div>
<div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;          <a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> &amp; pid = node.processor_id();</div>
<div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;          pid = std::min(pid, elem-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>());</div>
<div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;        }</div>
<div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;</div>
<div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;  <span class="comment">// Then finally see if other processors have a lower option</span></div>
<div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">Parallel::sync_node_data_by_element_id</a></div>
<div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;    (mesh, mesh.elements_begin(), mesh.elements_end(),</div>
<div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;     ElemNodesMaybeNew(), node_was_new, sync);</div>
<div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;</div>
<div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;  <span class="comment">// We should have consistent processor ids when we&#39;re done.</span></div>
<div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;<span class="preprocessor"></span>  <a class="code" href="namespacelibMesh_1_1MeshTools.html#afa9230889a01ee0f9489a3d3eb4d70c2">MeshTools::libmesh_assert_parallel_consistent_procids&lt;Node&gt;</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div>
<div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#a2699035cfb89b82a96bac61ad9ae291f">MeshTools::libmesh_assert_parallel_consistent_new_node_procids</a>(mesh);</div>
<div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;<span class="preprocessor"></span>}</div>
<div class="ttc" id="classlibMesh_1_1Elem_html"><div class="ttname"><a href="classlibMesh_1_1Elem.html">libMesh::Elem</a></div><div class="ttdoc">This is the base class from which all geometric element types are derived. </div><div class="ttdef"><b>Definition:</b> <a href="elem_8h_source.html#l00094">elem.h:94</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a2699035cfb89b82a96bac61ad9ae291f"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a2699035cfb89b82a96bac61ad9ae291f">libMesh::MeshTools::libmesh_assert_parallel_consistent_new_node_procids</a></div><div class="ttdeci">void libmesh_assert_parallel_consistent_new_node_procids(const MeshBase &amp;mesh)</div><div class="ttdoc">A function for verifying that processor assignment is parallel consistent (every processor agrees on ...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l01894">mesh_tools.C:1894</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af18245d4f872c36a41fc74086bda3e80"><div class="ttname"><a href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00104">id_types.h:104</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdoc">An invalid processor_id to distinguish DoFs that have not been assigned to a processor. </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00488">dof_object.h:488</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a78a93cd4ce160f40c758f96e2cadbe25"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">libMesh::Parallel::sync_node_data_by_element_id</a></div><div class="ttdeci">void sync_node_data_by_element_id(MeshBase &amp;mesh, const MeshBase::const_element_iterator &amp;range_begin, const MeshBase::const_element_iterator &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</div><div class="ttdoc">Synchronize data about a range of ghost nodes uniquely identified by an element id and local node id...</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00780">parallel_ghost_sync.h:780</a></div></div>
<div class="ttc" id="structlibMesh_1_1Parallel_1_1SyncEverything_html"><div class="ttname"><a href="structlibMesh_1_1Parallel_1_1SyncEverything.html">libMesh::Parallel::SyncEverything</a></div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00225">parallel_ghost_sync.h:225</a></div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html_a85d07487b3b947bee2ee977d46c4b864"><div class="ttname"><a href="classlibMesh_1_1Elem.html#a85d07487b3b947bee2ee977d46c4b864">libMesh::Elem::node_ref</a></div><div class="ttdeci">const Node &amp; node_ref(const unsigned int i) const </div><div class="ttdef"><b>Definition:</b> <a href="elem_8h_source.html#l02329">elem.h:2329</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_afa9230889a01ee0f9489a3d3eb4d70c2"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#afa9230889a01ee0f9489a3d3eb4d70c2">libMesh::MeshTools::libmesh_assert_parallel_consistent_procids&lt; Node &gt;</a></div><div class="ttdeci">void libmesh_assert_parallel_consistent_procids&lt; Node &gt;(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l01932">mesh_tools.C:1932</a></div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html_a648b34a7475203667c75597913822fdf"><div class="ttname"><a href="classlibMesh_1_1Elem.html#a648b34a7475203667c75597913822fdf">libMesh::Elem::node_ref_range</a></div><div class="ttdeci">SimpleRange&lt; NodeRefIter &gt; node_ref_range()</div><div class="ttdoc">Returns a range with all nodes of an element, usable in range-based for loops. </div><div class="ttdef"><b>Definition:</b> <a href="elem_8h_source.html#l02450">elem.h:2450</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a690437fd4e60ad2cedf64948c3f21519"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a690437fd4e60ad2cedf64948c3f21519">libMesh::Parallel::sync_node_data_by_element_id_once</a></div><div class="ttdeci">bool sync_node_data_by_element_id_once(MeshBase &amp;mesh, const MeshBase::const_element_iterator &amp;range_begin, const MeshBase::const_element_iterator &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</div><div class="ttdoc">Synchronize data about a range of ghost nodes uniquely identified by an element id and local node id...</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00580">parallel_ghost_sync.h:580</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_a0e8748b2c01f78902c9c432ad79cf546"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">libMesh::DofObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00898">dof_object.h:898</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afa47da82381f82ded5e3f0bedb0dbd5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_new_nodes_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy processor_ids and ids on new nodes from their local processors. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01934">1934</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l02222">libMesh::MeshTools::correct_node_proc_ids()</a>, <a class="el" href="mesh__communication_8C_source.html#l01814">make_new_node_proc_ids_parallel_consistent()</a>, <a class="el" href="mesh__communication_8C_source.html#l01612">make_node_bcids_parallel_consistent()</a>, <a class="el" href="mesh__communication_8C_source.html#l01562">make_node_ids_parallel_consistent()</a> , 以及 <a class="el" href="mesh__communication_8C_source.html#l01591">make_node_unique_ids_parallel_consistent()</a>.</p>

<p>参考自 <a class="el" href="mesh__refinement_8C_source.html#l01468">libMesh::MeshRefinement::_refine_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;{</div>
<div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;</div>
<div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;  <span class="comment">// When this function is called, each section of a parallelized mesh</span></div>
<div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;  <span class="comment">// should be in the following state:</span></div>
<div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;  <span class="comment">// All nodes should have the exact same physical location on every</span></div>
<div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;  <span class="comment">// processor where they exist.</span></div>
<div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;  <span class="comment">// Local nodes should have unique authoritative ids,</span></div>
<div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;  <span class="comment">// and new nodes should be unpartitioned.</span></div>
<div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;  <span class="comment">// New ghost nodes touching local elements should be unpartitioned.</span></div>
<div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;  <span class="comment">// New ghost nodes should have ids which are either already correct</span></div>
<div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;  <span class="comment">// or which are in the &quot;unpartitioned&quot; id space.</span></div>
<div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;  <span class="comment">// Non-new nodes should have correct ids and processor ids already.</span></div>
<div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;</div>
<div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;  <span class="comment">// First, let&#39;s sync up new nodes&#39; processor ids.</span></div>
<div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;</div>
<div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#ae09a612b52ccb019c89165d3bfce5773">make_new_node_proc_ids_parallel_consistent</a>(mesh);</div>
<div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;</div>
<div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;  <span class="comment">// Second, sync up dofobject ids.</span></div>
<div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#ab0eae4e562c489db701776c3970e772b">make_node_ids_parallel_consistent</a>(mesh);</div>
<div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;</div>
<div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;  <span class="comment">// Third, sync up dofobject unique_ids if applicable.</span></div>
<div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#a0e83bbe1c114c9de7be87927f7db9e85">make_node_unique_ids_parallel_consistent</a>(mesh);</div>
<div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;</div>
<div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;  <span class="comment">// Fourth, sync up any nodal boundary conditions</span></div>
<div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#a8082eb45c1053cbe83e6d1702633ca4b">make_node_bcids_parallel_consistent</a>(mesh);</div>
<div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;</div>
<div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;  <span class="comment">// Finally, correct the processor ids to make DofMap happy</span></div>
<div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#aca8746be5247c3f44a3b0797b5ed88f0">MeshTools::correct_node_proc_ids</a>(mesh);</div>
<div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_a0e83bbe1c114c9de7be87927f7db9e85"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#a0e83bbe1c114c9de7be87927f7db9e85">libMesh::MeshCommunication::make_node_unique_ids_parallel_consistent</a></div><div class="ttdeci">void make_node_unique_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdoc">Assuming all unique_ids on local nodes are globally unique, and assuming all processor ids are parall...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01591">mesh_communication.C:1591</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_aca8746be5247c3f44a3b0797b5ed88f0"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#aca8746be5247c3f44a3b0797b5ed88f0">libMesh::MeshTools::correct_node_proc_ids</a></div><div class="ttdeci">void correct_node_proc_ids(MeshBase &amp;mesh)</div><div class="ttdoc">Changes the processor ids on each node so be the same as the id of the lowest element touching that n...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l02222">mesh_tools.C:2222</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_a8082eb45c1053cbe83e6d1702633ca4b"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#a8082eb45c1053cbe83e6d1702633ca4b">libMesh::MeshCommunication::make_node_bcids_parallel_consistent</a></div><div class="ttdeci">void make_node_bcids_parallel_consistent(MeshBase &amp;)</div><div class="ttdoc">Assuming all processor ids are parallel consistent, this function makes all ghost boundary ids on nod...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01612">mesh_communication.C:1612</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_ae09a612b52ccb019c89165d3bfce5773"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#ae09a612b52ccb019c89165d3bfce5773">libMesh::MeshCommunication::make_new_node_proc_ids_parallel_consistent</a></div><div class="ttdeci">void make_new_node_proc_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdoc">Assuming all processor ids on nodes touching local elements are parallel consistent, this function makes processor ids on new nodes on other processors parallel consistent as well. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01814">mesh_communication.C:1814</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_ab0eae4e562c489db701776c3970e772b"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#ab0eae4e562c489db701776c3970e772b">libMesh::MeshCommunication::make_node_ids_parallel_consistent</a></div><div class="ttdeci">void make_node_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdoc">Assuming all ids on local nodes are globally unique, and assuming all processor ids are parallel cons...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01562">mesh_communication.C:1562</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8082eb45c1053cbe83e6d1702633ca4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_node_bcids_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming all processor ids are parallel consistent, this function makes all ghost boundary ids on nodes parallel consistent. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01612">1612</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="libmesh__common_8h_source.html#l00516">libMesh::libmesh_ignore()</a> , 以及 <a class="el" href="parallel__ghost__sync_8h_source.html#l00357">libMesh::Parallel::sync_dofobject_data_by_id()</a>.</p>

<p>参考自 <a class="el" href="mesh__communication_8C_source.html#l01934">make_new_nodes_parallel_consistent()</a>.</p>
<div class="fragment"><div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;{</div>
<div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;  <span class="comment">// Avoid unused variable warnings if unique ids aren&#39;t enabled.</span></div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;  <a class="code" href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libmesh_ignore</a>(mesh);</div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;</div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;</div>
<div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_node_bcids_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;</div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;  SyncBCIds&lt;Node&gt; syncbcids(mesh);</div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">Parallel::sync_dofobject_data_by_id</a>(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>(),</div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;                                      mesh.nodes_begin(),</div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;                                      mesh.nodes_end(),</div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;                                      syncbcids);</div>
<div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_html_a43f45640aab1af26176e69592c666432"><div class="ttname"><a href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libMesh::libmesh_ignore</a></div><div class="ttdeci">void libmesh_ignore(const Args &amp;...)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00516">libmesh_common.h:516</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_ac7d4f06bb34625465942e6b8d10f135e"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">libMesh::Parallel::sync_dofobject_data_by_id</a></div><div class="ttdeci">void sync_dofobject_data_by_id(const Communicator &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</div><div class="ttdoc">Request data about a range of ghost dofobjects uniquely identified by their id. </div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00357">parallel_ghost_sync.h:357</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab0eae4e562c489db701776c3970e772b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_node_ids_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming all ids on local nodes are globally unique, and assuming all processor ids are parallel consistent, this function makes all other ids parallel consistent. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01562">1562</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l01352">libMesh::MeshTools::libmesh_assert_topology_consistent_procids&lt; Node &gt;()</a>, <a class="el" href="mesh__communication_8C_source.html#l01308">mesh</a> , 以及 <a class="el" href="parallel__ghost__sync_8h_source.html#l00780">libMesh::Parallel::sync_node_data_by_element_id()</a>.</p>

<p>参考自 <a class="el" href="mesh__communication_8C_source.html#l01934">make_new_nodes_parallel_consistent()</a> , 以及 <a class="el" href="mesh__communication_8C_source.html#l01892">make_nodes_parallel_consistent()</a>.</p>
<div class="fragment"><div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;{</div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;</div>
<div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;  <span class="comment">// We need to agree on which processor owns every node, but we can&#39;t</span></div>
<div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;  <span class="comment">// easily assert that here because we don&#39;t currently agree on which</span></div>
<div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;  <span class="comment">// id every node has, and some of our temporary ids on unrelated</span></div>
<div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;  <span class="comment">// nodes will &quot;overlap&quot;.</span></div>
<div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;<span class="comment">//#ifdef DEBUG</span></div>
<div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;<span class="comment">//  MeshTools::libmesh_assert_parallel_consistent_procids&lt;Node&gt; (mesh);</span></div>
<div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;<span class="comment">//#endif // DEBUG</span></div>
<div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;</div>
<div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_node_ids_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;</div>
<div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;  SyncNodeIds syncids(mesh);</div>
<div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">Parallel::sync_node_data_by_element_id</a></div>
<div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;    (mesh, mesh.elements_begin(), mesh.elements_end(),</div>
<div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;     <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(), <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(), syncids);</div>
<div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;</div>
<div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;  <span class="comment">// At this point, with both ids and processor ids synced, we can</span></div>
<div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;  <span class="comment">// finally check for topological consistency of node processor ids.</span></div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;<span class="preprocessor"></span>  <a class="code" href="namespacelibMesh_1_1MeshTools.html#ad7fa726589463cf24cee5f9f3c140ba0">MeshTools::libmesh_assert_topology_consistent_procids&lt;Node&gt;</a> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;<span class="preprocessor"></span>}</div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ad7fa726589463cf24cee5f9f3c140ba0"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ad7fa726589463cf24cee5f9f3c140ba0">libMesh::MeshTools::libmesh_assert_topology_consistent_procids&lt; Node &gt;</a></div><div class="ttdeci">void libmesh_assert_topology_consistent_procids&lt; Node &gt;(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l01352">mesh_tools.C:1352</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a78a93cd4ce160f40c758f96e2cadbe25"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">libMesh::Parallel::sync_node_data_by_element_id</a></div><div class="ttdeci">void sync_node_data_by_element_id(MeshBase &amp;mesh, const MeshBase::const_element_iterator &amp;range_begin, const MeshBase::const_element_iterator &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</div><div class="ttdoc">Synchronize data about a range of ghost nodes uniquely identified by an element id and local node id...</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00780">parallel_ghost_sync.h:780</a></div></div>
<div class="ttc" id="structlibMesh_1_1Parallel_1_1SyncEverything_html"><div class="ttname"><a href="structlibMesh_1_1Parallel_1_1SyncEverything.html">libMesh::Parallel::SyncEverything</a></div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00225">parallel_ghost_sync.h:225</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab67880939a7d98e9cb3e7a6425a4d7ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming all processor ids on nodes touching local elements are parallel consistent, this function makes all other processor ids parallel consistent as well. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01785">1785</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a> , 以及 <a class="el" href="parallel__ghost__sync_8h_source.html#l00780">libMesh::Parallel::sync_node_data_by_element_id()</a>.</p>

<p>参考自 <a class="el" href="mesh__communication_8C_source.html#l01892">make_nodes_parallel_consistent()</a>.</p>
<div class="fragment"><div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;{</div>
<div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_node_proc_ids_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;</div>
<div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;</div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;  <span class="comment">// When this function is called, each section of a parallelized mesh</span></div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;  <span class="comment">// should be in the following state:</span></div>
<div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;  <span class="comment">// All nodes should have the exact same physical location on every</span></div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;  <span class="comment">// processor where they exist.</span></div>
<div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;  <span class="comment">// Local nodes should have unique authoritative ids,</span></div>
<div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;  <span class="comment">// and processor ids consistent with all processors which own</span></div>
<div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;  <span class="comment">// an element touching them.</span></div>
<div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;  <span class="comment">// Ghost nodes touching local elements should have processor ids</span></div>
<div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;  <span class="comment">// consistent with all processors which own an element touching</span></div>
<div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;  <span class="comment">// them.</span></div>
<div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;  SyncProcIds sync(mesh);</div>
<div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">Parallel::sync_node_data_by_element_id</a></div>
<div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;    (mesh, mesh.elements_begin(), mesh.elements_end(),</div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;     <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(), <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(), sync);</div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a78a93cd4ce160f40c758f96e2cadbe25"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">libMesh::Parallel::sync_node_data_by_element_id</a></div><div class="ttdeci">void sync_node_data_by_element_id(MeshBase &amp;mesh, const MeshBase::const_element_iterator &amp;range_begin, const MeshBase::const_element_iterator &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</div><div class="ttdoc">Synchronize data about a range of ghost nodes uniquely identified by an element id and local node id...</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00780">parallel_ghost_sync.h:780</a></div></div>
<div class="ttc" id="structlibMesh_1_1Parallel_1_1SyncEverything_html"><div class="ttname"><a href="structlibMesh_1_1Parallel_1_1SyncEverything.html">libMesh::Parallel::SyncEverything</a></div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00225">parallel_ghost_sync.h:225</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0e83bbe1c114c9de7be87927f7db9e85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_node_unique_ids_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming all unique_ids on local nodes are globally unique, and assuming all processor ids are parallel consistent, this function makes all ghost unique_ids parallel consistent. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01591">1591</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="libmesh__common_8h_source.html#l00516">libMesh::libmesh_ignore()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a88d3228c36aa7b481f0f5d77f95bd021">libMesh::MeshBase::query_node_ptr()</a> , 以及 <a class="el" href="parallel__ghost__sync_8h_source.html#l00357">libMesh::Parallel::sync_dofobject_data_by_id()</a>.</p>

<p>参考自 <a class="el" href="boundary__info_8C_source.html#l00620">libMesh::BoundaryInfo::add_elements()</a>, <a class="el" href="mesh__communication_8C_source.html#l01934">make_new_nodes_parallel_consistent()</a>, <a class="el" href="mesh__communication_8C_source.html#l01892">make_nodes_parallel_consistent()</a> , 以及 <a class="el" href="nemesis__io_8C_source.html#l00198">libMesh::Nemesis_IO::read()</a>.</p>
<div class="fragment"><div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;{</div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;  <span class="comment">// Avoid unused variable warnings if unique ids aren&#39;t enabled.</span></div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;  <a class="code" href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libmesh_ignore</a>(mesh);</div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;</div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;</div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_UNIQUE_ID</span></div>
<div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;<span class="preprocessor"></span>  LOG_SCOPE (<span class="stringliteral">&quot;make_node_unique_ids_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;</div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;  SyncUniqueIds&lt;Node&gt; syncuniqueids(mesh, &amp;<a class="code" href="classlibMesh_1_1MeshBase.html#a88d3228c36aa7b481f0f5d77f95bd021">MeshBase::query_node_ptr</a>);</div>
<div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">Parallel::sync_dofobject_data_by_id</a>(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>(),</div>
<div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;                                      mesh.nodes_begin(),</div>
<div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;                                      mesh.nodes_end(),</div>
<div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;                                      syncuniqueids);</div>
<div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;</div>
<div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;<span class="preprocessor"></span>}</div>
<div class="ttc" id="namespacelibMesh_html_a43f45640aab1af26176e69592c666432"><div class="ttname"><a href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libMesh::libmesh_ignore</a></div><div class="ttdeci">void libmesh_ignore(const Args &amp;...)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00516">libmesh_common.h:516</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a88d3228c36aa7b481f0f5d77f95bd021"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a88d3228c36aa7b481f0f5d77f95bd021">libMesh::MeshBase::query_node_ptr</a></div><div class="ttdeci">virtual const Node * query_node_ptr(const dof_id_type i) const =0</div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_ac7d4f06bb34625465942e6b8d10f135e"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">libMesh::Parallel::sync_dofobject_data_by_id</a></div><div class="ttdeci">void sync_dofobject_data_by_id(const Communicator &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</div><div class="ttdoc">Request data about a range of ghost dofobjects uniquely identified by their id. </div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00357">parallel_ghost_sync.h:357</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac76dd6bc5f023e8836591ca42a9caa94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_nodes_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy processor_ids and ids on ghost nodes from their local processors. </p>
<p>This is useful for code which wants to add nodes to a distributed mesh. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01892">1892</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l02222">libMesh::MeshTools::correct_node_proc_ids()</a>, <a class="el" href="mesh__communication_8C_source.html#l01562">make_node_ids_parallel_consistent()</a>, <a class="el" href="mesh__communication_8C_source.html#l01785">make_node_proc_ids_parallel_consistent()</a> , 以及 <a class="el" href="mesh__communication_8C_source.html#l01591">make_node_unique_ids_parallel_consistent()</a>.</p>

<p>参考自 <a class="el" href="mesh__refinement_8C_source.html#l01335">libMesh::MeshRefinement::_coarsen_elements()</a> , 以及 <a class="el" href="mesh__modification_8C_source.html#l00333">libMesh::MeshTools::Modification::all_tri()</a>.</p>
<div class="fragment"><div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;{</div>
<div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;</div>
<div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;  <span class="comment">// When this function is called, each section of a parallelized mesh</span></div>
<div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;  <span class="comment">// should be in the following state:</span></div>
<div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;  <span class="comment">// All nodes should have the exact same physical location on every</span></div>
<div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;  <span class="comment">// processor where they exist.</span></div>
<div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;  <span class="comment">// Local nodes should have unique authoritative ids,</span></div>
<div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;  <span class="comment">// and processor ids consistent with all processors which own</span></div>
<div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;  <span class="comment">// an element touching them.</span></div>
<div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;  <span class="comment">// Ghost nodes touching local elements should have processor ids</span></div>
<div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;  <span class="comment">// consistent with all processors which own an element touching</span></div>
<div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;  <span class="comment">// them.</span></div>
<div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;  <span class="comment">// Ghost nodes should have ids which are either already correct</span></div>
<div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;  <span class="comment">// or which are in the &quot;unpartitioned&quot; id space.</span></div>
<div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;</div>
<div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;  <span class="comment">// First, let&#39;s sync up processor ids.  Some of these processor ids</span></div>
<div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;  <span class="comment">// may be &quot;wrong&quot; from coarsening, but they&#39;re right in the sense</span></div>
<div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;  <span class="comment">// that they&#39;ll tell us who has the authoritative dofobject ids for</span></div>
<div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;  <span class="comment">// each node.</span></div>
<div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;</div>
<div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#ab67880939a7d98e9cb3e7a6425a4d7ec">make_node_proc_ids_parallel_consistent</a>(mesh);</div>
<div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;</div>
<div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;  <span class="comment">// Second, sync up dofobject ids.</span></div>
<div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#ab0eae4e562c489db701776c3970e772b">make_node_ids_parallel_consistent</a>(mesh);</div>
<div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;</div>
<div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;  <span class="comment">// Third, sync up dofobject unique_ids if applicable.</span></div>
<div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#a0e83bbe1c114c9de7be87927f7db9e85">make_node_unique_ids_parallel_consistent</a>(mesh);</div>
<div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;</div>
<div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;  <span class="comment">// Finally, correct the processor ids to make DofMap happy</span></div>
<div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#aca8746be5247c3f44a3b0797b5ed88f0">MeshTools::correct_node_proc_ids</a>(mesh);</div>
<div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_a0e83bbe1c114c9de7be87927f7db9e85"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#a0e83bbe1c114c9de7be87927f7db9e85">libMesh::MeshCommunication::make_node_unique_ids_parallel_consistent</a></div><div class="ttdeci">void make_node_unique_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdoc">Assuming all unique_ids on local nodes are globally unique, and assuming all processor ids are parall...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01591">mesh_communication.C:1591</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_aca8746be5247c3f44a3b0797b5ed88f0"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#aca8746be5247c3f44a3b0797b5ed88f0">libMesh::MeshTools::correct_node_proc_ids</a></div><div class="ttdeci">void correct_node_proc_ids(MeshBase &amp;mesh)</div><div class="ttdoc">Changes the processor ids on each node so be the same as the id of the lowest element touching that n...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l02222">mesh_tools.C:2222</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_ab0eae4e562c489db701776c3970e772b"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#ab0eae4e562c489db701776c3970e772b">libMesh::MeshCommunication::make_node_ids_parallel_consistent</a></div><div class="ttdeci">void make_node_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdoc">Assuming all ids on local nodes are globally unique, and assuming all processor ids are parallel cons...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01562">mesh_communication.C:1562</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_ab67880939a7d98e9cb3e7a6425a4d7ec"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#ab67880939a7d98e9cb3e7a6425a4d7ec">libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent</a></div><div class="ttdeci">void make_node_proc_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdoc">Assuming all processor ids on nodes touching local elements are parallel consistent, this function makes all other processor ids parallel consistent as well. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01785">mesh_communication.C:1785</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9eb166973b14e95ae36c14a39105907a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_p_levels_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy p levels of ghost elements from their local processors. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l01658">1658</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a> , 以及 <a class="el" href="parallel__ghost__sync_8h_source.html#l00357">libMesh::Parallel::sync_dofobject_data_by_id()</a>.</p>

<p>参考自 <a class="el" href="mesh__refinement_8C_source.html#l01335">libMesh::MeshRefinement::_coarsen_elements()</a> , 以及 <a class="el" href="mesh__refinement_8C_source.html#l01468">libMesh::MeshRefinement::_refine_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;{</div>
<div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;</div>
<div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_p_levels_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div>
<div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;</div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;  SyncPLevels syncplevels(mesh);</div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">Parallel::sync_dofobject_data_by_id</a></div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;    (mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>(), mesh.elements_begin(), mesh.elements_end(),</div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;     syncplevels);</div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_ac7d4f06bb34625465942e6b8d10f135e"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">libMesh::Parallel::sync_dofobject_data_by_id</a></div><div class="ttdeci">void sync_dofobject_data_by_id(const Communicator &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</div><div class="ttdoc">Request data about a range of ghost dofobjects uniquely identified by their id. </div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00357">parallel_ghost_sync.h:357</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afc09ecb045289c5b370cf2e16427ae1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::redistribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newly_coarsened_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method takes a parallel distributed mesh and redistributes the elements. </p>
<p>Specifically, any elements stored on a given processor are sent to the processor which "owns" them. Similarly, any elements assigned to the current processor but stored on another are received. Once this step is completed any required ghost elements are updated. The final result is that each processor stores only the elements it actually owns and any ghost elements required to satisfy data dependencies. This method can be invoked after a partitioning step to affect the new partitioning.</p>
<p>Redistribution can also be done with newly coarsened elements' neighbors only. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l00339">339</a> 行定义.</p>

<p>参考自 <a class="el" href="distributed__mesh_8C_source.html#l01038">libMesh::DistributedMesh::redistribute()</a>.</p>
<div class="fragment"><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;{</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;  <span class="comment">// no MPI == one processor, no redistribution</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;  <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa1d6e28995b84fba9cbcb72064d07637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::send_coarse_ghosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Examine a just-coarsened mesh, and for any newly-coarsened elements, send the associated ghosted elements to the processor which needs them. </p>

<p>在文件 <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a> 第 <a class="el" href="mesh__communication_8C_source.html#l00892">892</a> 行定义.</p>

<p>参考自 <a class="el" href="mesh__refinement_8C_source.html#l01335">libMesh::MeshRefinement::_coarsen_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;{</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;  <span class="comment">// no MPI == one processor, no need for this method...</span></div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;  <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>/home/lwz/libmesh/include/mesh/<a class="el" href="mesh__communication_8h_source.html">mesh_communication.h</a></li>
<li>/home/lwz/libmesh/src/mesh/<a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a></li>
<li>/home/lwz/libmesh/src/mesh/<a class="el" href="mesh__communication__global__indices_8C_source.html">mesh_communication_global_indices.C</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2023年 十二月 20日 星期三 12:09:34 , 为 libmesh解析使用  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
