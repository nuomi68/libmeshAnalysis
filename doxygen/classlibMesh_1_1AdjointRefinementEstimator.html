<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libmesh解析: libMesh::AdjointRefinementEstimator类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libmesh解析
   </div>
   <div id="projectbrief">本工作只是尝试解析原libmesh的代码,供学习使用</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li class="current"><a href="annotated.html"><span>类</span></a></li>
      <li><a href="files.html"><span>文件</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>类列表</span></a></li>
      <li><a href="classes.html"><span>类索引</span></a></li>
      <li><a href="inherits.html"><span>类继承关系</span></a></li>
      <li><a href="functions.html"><span>类成员</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>全部</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>类</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>命名空间</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>文件</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>函数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>变量</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>类型定义</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>枚举</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>枚举值</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>友元</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>页</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-attribs">Public 属性</a> &#124;
<a href="#pro-methods">Protected 成员函数</a> &#124;
<a href="#pro-attribs">Protected 属性</a> &#124;
<a href="classlibMesh_1_1AdjointRefinementEstimator-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::AdjointRefinementEstimator类 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements a "brute force" goal-oriented error estimator which computes an estimate of error in a quantity of interest based on the residual of the current coarse grid primal solution as weighted against an adjoint solution on a uniformly refined (in h and/or p, for an arbitrary number of levels) grid.  
 <a href="classlibMesh_1_1AdjointRefinementEstimator.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>&gt;</code></p>
<div class="dynheader">
类 libMesh::AdjointRefinementEstimator 继承关系图:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:ab37d862060bbddf77099b6e34c62ef71"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::pair<br class="typebreak"/>
&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, unsigned int &gt;<br class="typebreak"/>
, std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#ab37d862060bbddf77099b6e34c62ef71">ErrorMap</a></td></tr>
<tr class="memdesc:ab37d862060bbddf77099b6e34c62ef71"><td class="mdescLeft">&#160;</td><td class="mdescRight">When calculating many error vectors at once, we need a data structure to hold them all.  <a href="#ab37d862060bbddf77099b6e34c62ef71">更多...</a><br/></td></tr>
<tr class="separator:ab37d862060bbddf77099b6e34c62ef71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:afcdf4f028e2e69d7457d052cb8b27540"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#afcdf4f028e2e69d7457d052cb8b27540">AdjointRefinementEstimator</a> ()</td></tr>
<tr class="memdesc:afcdf4f028e2e69d7457d052cb8b27540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#afcdf4f028e2e69d7457d052cb8b27540">更多...</a><br/></td></tr>
<tr class="separator:afcdf4f028e2e69d7457d052cb8b27540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa49fea6d02efd39419a3ad98bf3390"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a5aa49fea6d02efd39419a3ad98bf3390">AdjointRefinementEstimator</a> (const <a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;)=default</td></tr>
<tr class="memdesc:a5aa49fea6d02efd39419a3ad98bf3390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy/move ctor, copy/move assignment operator, and destructor are all explicitly defaulted for this class.  <a href="#a5aa49fea6d02efd39419a3ad98bf3390">更多...</a><br/></td></tr>
<tr class="separator:a5aa49fea6d02efd39419a3ad98bf3390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ce0c886941a8456615305163e3b374"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a57ce0c886941a8456615305163e3b374">AdjointRefinementEstimator</a> (<a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a57ce0c886941a8456615305163e3b374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afd6c830b8dddbfb1014edf18f8f69c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4afd6c830b8dddbfb1014edf18f8f69c">operator=</a> (const <a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;)=default</td></tr>
<tr class="separator:a4afd6c830b8dddbfb1014edf18f8f69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a07208352932dfb91f3b7035729f137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a6a07208352932dfb91f3b7035729f137">operator=</a> (<a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a6a07208352932dfb91f3b7035729f137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc84f858a58030455da251676901a494"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#afc84f858a58030455da251676901a494">~AdjointRefinementEstimator</a> ()=default</td></tr>
<tr class="separator:afc84f858a58030455da251676901a494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aca6ed2c5e83a66cbea3fb745d42bb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a0aca6ed2c5e83a66cbea3fb745d42bb6">qoi_set</a> ()</td></tr>
<tr class="memdesc:a0aca6ed2c5e83a66cbea3fb745d42bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the <a class="el" href="classlibMesh_1_1QoISet.html" title="Data structure for specifying which Quantities of Interest should be calculated in an adjoint or a pa...">QoISet</a> (default: weight all QoIs equally) to use when computing errors.  <a href="#a0aca6ed2c5e83a66cbea3fb745d42bb6">更多...</a><br/></td></tr>
<tr class="separator:a0aca6ed2c5e83a66cbea3fb745d42bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdc392b69087dc11dc56fe15b29708a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#afcdc392b69087dc11dc56fe15b29708a">qoi_set</a> () const </td></tr>
<tr class="memdesc:afcdc392b69087dc11dc56fe15b29708a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the <a class="el" href="classlibMesh_1_1QoISet.html" title="Data structure for specifying which Quantities of Interest should be calculated in an adjoint or a pa...">QoISet</a> (default: weight all QoIs equally) to use when computing errors.  <a href="#afcdc392b69087dc11dc56fe15b29708a">更多...</a><br/></td></tr>
<tr class="separator:afcdc392b69087dc11dc56fe15b29708a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99004a29eeb5644df69adeca099242d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#af99004a29eeb5644df69adeca099242d">estimate_error</a> (const <a class="el" href="classlibMesh_1_1System.html">System</a> &amp;system, <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;error_per_cell, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; *solution_vector=nullptr, bool estimate_parent_error=false) override</td></tr>
<tr class="memdesc:af99004a29eeb5644df69adeca099242d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does uniform refinements and an adjoint solve to get an adjoint solution on each cell, then estimates the error by finding the weighted residual of the coarse solution with the fine adjoint solution.  <a href="#af99004a29eeb5644df69adeca099242d">更多...</a><br/></td></tr>
<tr class="separator:af99004a29eeb5644df69adeca099242d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0143c56bd2fdc236700dd3b1262d7097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a0143c56bd2fdc236700dd3b1262d7097">get_global_QoI_error_estimate</a> (unsigned int qoi_index)</td></tr>
<tr class="memdesc:a0143c56bd2fdc236700dd3b1262d7097"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an accessor function to access the computed global QoI error estimates.  <a href="#a0143c56bd2fdc236700dd3b1262d7097">更多...</a><br/></td></tr>
<tr class="separator:a0143c56bd2fdc236700dd3b1262d7097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db466224010af9c371440ffa67c43c2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibMesh.html#a370493a82a7f09613a0fdc56fc7912b7">ErrorEstimatorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a3db466224010af9c371440ffa67c43c2">type</a> () const override</td></tr>
<tr class="separator:a3db466224010af9c371440ffa67c43c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d2e7401de04e31b0a1c81650ec72e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#ac4d2e7401de04e31b0a1c81650ec72e8">get_residual_evaluation_physics</a> ()</td></tr>
<tr class="separator:ac4d2e7401de04e31b0a1c81650ec72e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d69ad607bba49f333dd775ccdd7ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a13d69ad607bba49f333dd775ccdd7ca1">set_residual_evaluation_physics</a> (<a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *set_physics)</td></tr>
<tr class="memdesc:a13d69ad607bba49f333dd775ccdd7ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the _residual_evaluation_physics member to argument.  <a href="#a13d69ad607bba49f333dd775ccdd7ca1">更多...</a><br/></td></tr>
<tr class="separator:a13d69ad607bba49f333dd775ccdd7ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7499cfbc2f746c821d121572d6b3ac08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a7499cfbc2f746c821d121572d6b3ac08">get_adjoint_evaluation_physics</a> ()</td></tr>
<tr class="separator:a7499cfbc2f746c821d121572d6b3ac08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c42e8462ef88c3e680b1d1b67e2d98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad8c42e8462ef88c3e680b1d1b67e2d98">set_adjoint_evaluation_physics</a> (<a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *set_physics)</td></tr>
<tr class="memdesc:ad8c42e8462ef88c3e680b1d1b67e2d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the _adjoint_evaluation_physics member to argument.  <a href="#ad8c42e8462ef88c3e680b1d1b67e2d98">更多...</a><br/></td></tr>
<tr class="separator:ad8c42e8462ef88c3e680b1d1b67e2d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad575aa2606bb47551e562a290499df0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#aad575aa2606bb47551e562a290499df0">estimate_errors</a> (const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;equation_systems, <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;error_per_cell, const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, <a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> &gt; &amp;error_norms, const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; * &gt; *solution_vectors=nullptr, bool estimate_parent_error=false)</td></tr>
<tr class="memdesc:aad575aa2606bb47551e562a290499df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This virtual function can be redefined in derived classes, but by default computes the sum of the error_per_cell for each system in the equation_systems.  <a href="#aad575aa2606bb47551e562a290499df0">更多...</a><br/></td></tr>
<tr class="separator:aad575aa2606bb47551e562a290499df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf8e0fb666d439804046465cf443867"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a6bf8e0fb666d439804046465cf443867">estimate_errors</a> (const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;equation_systems, <a class="el" href="classlibMesh_1_1ErrorEstimator.html#ab37d862060bbddf77099b6e34c62ef71">ErrorMap</a> &amp;errors_per_cell, const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; * &gt; *solution_vectors=nullptr, bool estimate_parent_error=false)</td></tr>
<tr class="memdesc:a6bf8e0fb666d439804046465cf443867"><td class="mdescLeft">&#160;</td><td class="mdescRight">This virtual function can be redefined in derived classes, but by default it calls estimate_error repeatedly to calculate the requested error vectors.  <a href="#a6bf8e0fb666d439804046465cf443867">更多...</a><br/></td></tr>
<tr class="separator:a6bf8e0fb666d439804046465cf443867"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public 属性</h2></td></tr>
<tr class="memitem:a4437c7888b7459952e06a9157bf61ffe"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a></td></tr>
<tr class="memdesc:a4437c7888b7459952e06a9157bf61ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many h refinements to perform to get the fine grid.  <a href="#a4437c7888b7459952e06a9157bf61ffe">更多...</a><br/></td></tr>
<tr class="separator:a4437c7888b7459952e06a9157bf61ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff7ac97985f693cd3cc7a8311a24558"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a></td></tr>
<tr class="memdesc:abff7ac97985f693cd3cc7a8311a24558"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many p refinements to perform to get the fine grid.  <a href="#abff7ac97985f693cd3cc7a8311a24558">更多...</a><br/></td></tr>
<tr class="separator:abff7ac97985f693cd3cc7a8311a24558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d626496b0b6f99f679c4ef4f0a5e46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a></td></tr>
<tr class="memdesc:a9d626496b0b6f99f679c4ef4f0a5e46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">When estimating the error in a single system, the <code>error_norm</code> is used to control the scaling and norm choice for each variable.  <a href="#a9d626496b0b6f99f679c4ef4f0a5e46e">更多...</a><br/></td></tr>
<tr class="separator:a9d626496b0b6f99f679c4ef4f0a5e46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected 成员函数</h2></td></tr>
<tr class="memitem:ac29685e2e9f05123fd4d6db97326a2a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#ac29685e2e9f05123fd4d6db97326a2a9">reduce_error</a> (std::vector&lt; <a class="el" href="namespacelibMesh.html#a26acf05f075521cbfb223db57e63d6d0">ErrorVectorReal</a> &gt; &amp;error_per_cell, const Parallel::Communicator &amp;comm) const </td></tr>
<tr class="memdesc:ac29685e2e9f05123fd4d6db97326a2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes the local error contributions in <code>error_per_cell</code> from each processor and combines them to get the global error vector.  <a href="#ac29685e2e9f05123fd4d6db97326a2a9">更多...</a><br/></td></tr>
<tr class="separator:ac29685e2e9f05123fd4d6db97326a2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected 属性</h2></td></tr>
<tr class="memitem:af73f953ce5c33a52ea2b53364c1aff9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a></td></tr>
<tr class="memdesc:af73f953ce5c33a52ea2b53364c1aff9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to object to use for physics assembly evaluations.  <a href="#af73f953ce5c33a52ea2b53364c1aff9c">更多...</a><br/></td></tr>
<tr class="separator:af73f953ce5c33a52ea2b53364c1aff9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacdc63e3e036a23fe2df82c14eee51e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a></td></tr>
<tr class="memdesc:abacdc63e3e036a23fe2df82c14eee51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to object to use for adjoint assembly.  <a href="#abacdc63e3e036a23fe2df82c14eee51e">更多...</a><br/></td></tr>
<tr class="separator:abacdc63e3e036a23fe2df82c14eee51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af635c66743cb57b7ffc0c16343055a8d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a></td></tr>
<tr class="separator:af635c66743cb57b7ffc0c16343055a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51061a9299eba61c328edca03b0cd20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a></td></tr>
<tr class="memdesc:ad51061a9299eba61c328edca03b0cd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classlibMesh_1_1QoISet.html" title="Data structure for specifying which Quantities of Interest should be calculated in an adjoint or a pa...">QoISet</a> to handle cases with multiple QoIs available.  <a href="#ad51061a9299eba61c328edca03b0cd20">更多...</a><br/></td></tr>
<tr class="separator:ad51061a9299eba61c328edca03b0cd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>This class implements a "brute force" goal-oriented error estimator which computes an estimate of error in a quantity of interest based on the residual of the current coarse grid primal solution as weighted against an adjoint solution on a uniformly refined (in h and/or p, for an arbitrary number of levels) grid. </p>
<dl class="section author"><dt>作者</dt><dd>Roy H. Stogner </dd></dl>
<dl class="section date"><dt>日期</dt><dd>2009 </dd></dl>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00050">50</a> 行定义.</p>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a class="anchor" id="ab37d862060bbddf77099b6e34c62ef71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::pair&lt;const <a class="el" href="classlibMesh_1_1System.html">System</a> *, unsigned int&gt;, std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a>&gt; &gt; <a class="el" href="classlibMesh_1_1ErrorEstimator.html#ab37d862060bbddf77099b6e34c62ef71">libMesh::ErrorEstimator::ErrorMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When calculating many error vectors at once, we need a data structure to hold them all. </p>

<p>在文件 <a class="el" href="error__estimator_8h_source.html">error_estimator.h</a> 第 <a class="el" href="error__estimator_8h_source.html#l00121">121</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a class="anchor" id="afcdf4f028e2e69d7457d052cb8b27540"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::AdjointRefinementEstimator::AdjointRefinementEstimator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Sets the most common default parameter values. </p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8C_source.html">adjoint_refinement_estimator.C</a> 第 <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00073">73</a> 行定义.</p>

<p>参考 <a class="el" href="error__estimator_8h_source.html#l00158">libMesh::ErrorEstimator::error_norm</a> , 以及 <a class="el" href="enum__norm__type_8h_source.html#l00061">libMesh::INVALID_NORM</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                                                       :</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <a class="code" href="classlibMesh_1_1ErrorEstimator.html#abd4e67c1f8f49543f64859513208faa4">ErrorEstimator</a>(),</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>(1),</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a>(0),</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>(<span class="keyword">nullptr</span>),</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a>(<span class="keyword">nullptr</span>),</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>(QoISet())</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;{</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  <span class="comment">// We&#39;re not actually going to use error_norm; our norms are</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="comment">// absolute values of QoI error.</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = <a class="code" href="namespacelibMesh.html#a2fef831ba9c2670aafb97bcb7e597346ad57b0f1b145c48bd9cafec20cca415bc">INVALID_NORM</a>;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a9d626496b0b6f99f679c4ef4f0a5e46e"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">libMesh::ErrorEstimator::error_norm</a></div><div class="ttdeci">SystemNorm error_norm</div><div class="ttdoc">When estimating the error in a single system, the error_norm is used to control the scaling and norm ...</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8h_source.html#l00158">error_estimator.h:158</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_abacdc63e3e036a23fe2df82c14eee51e"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">libMesh::AdjointRefinementEstimator::_adjoint_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _adjoint_evaluation_physics</div><div class="ttdoc">Pointer to object to use for adjoint assembly. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00161">adjoint_refinement_estimator.h:161</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdoc">A QoISet to handle cases with multiple QoIs available. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00169">adjoint_refinement_estimator.h:169</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_abd4e67c1f8f49543f64859513208faa4"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#abd4e67c1f8f49543f64859513208faa4">libMesh::ErrorEstimator::ErrorEstimator</a></div><div class="ttdeci">ErrorEstimator()=default</div><div class="ttdoc">Constructor. </div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af73f953ce5c33a52ea2b53364c1aff9c"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">libMesh::AdjointRefinementEstimator::_residual_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _residual_evaluation_physics</div><div class="ttdoc">Pointer to object to use for physics assembly evaluations. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00155">adjoint_refinement_estimator.h:155</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_a4437c7888b7459952e06a9157bf61ffe"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">libMesh::AdjointRefinementEstimator::number_h_refinements</a></div><div class="ttdeci">unsigned char number_h_refinements</div><div class="ttdoc">How many h refinements to perform to get the fine grid. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00116">adjoint_refinement_estimator.h:116</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_abff7ac97985f693cd3cc7a8311a24558"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">libMesh::AdjointRefinementEstimator::number_p_refinements</a></div><div class="ttdeci">unsigned char number_p_refinements</div><div class="ttdoc">How many p refinements to perform to get the fine grid. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00121">adjoint_refinement_estimator.h:121</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a2fef831ba9c2670aafb97bcb7e597346ad57b0f1b145c48bd9cafec20cca415bc"><div class="ttname"><a href="namespacelibMesh.html#a2fef831ba9c2670aafb97bcb7e597346ad57b0f1b145c48bd9cafec20cca415bc">libMesh::INVALID_NORM</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__norm__type_8h_source.html#l00061">enum_norm_type.h:61</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5aa49fea6d02efd39419a3ad98bf3390"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::AdjointRefinementEstimator::AdjointRefinementEstimator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy/move ctor, copy/move assignment operator, and destructor are all explicitly defaulted for this class. </p>

</div>
</div>
<a class="anchor" id="a57ce0c886941a8456615305163e3b374"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::AdjointRefinementEstimator::AdjointRefinementEstimator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc84f858a58030455da251676901a494"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual libMesh::AdjointRefinementEstimator::~AdjointRefinementEstimator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a class="anchor" id="af99004a29eeb5644df69adeca099242d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::AdjointRefinementEstimator::estimate_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1System.html">System</a> &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;&#160;</td>
          <td class="paramname"><em>error_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; *&#160;</td>
          <td class="paramname"><em>solution_vector</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>estimate_parent_error</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function does uniform refinements and an adjoint solve to get an adjoint solution on each cell, then estimates the error by finding the weighted residual of the coarse solution with the fine adjoint solution. </p>
<p>system.solve() and system.assembly() must be called, and so should have no side effects.</p>
<p>Only the provided system is solved on the refined mesh; we don't support adjoint solves on loosely coupled collections of Systems.</p>
<p>The estimated error is output in the vector <code>error_per_cell</code> </p>

<p>实现了 <a class="el" href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">libMesh::ErrorEstimator</a>.</p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8C_source.html">adjoint_refinement_estimator.C</a> 第 <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00091">91</a> 行定义.</p>

<p>参考 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00161">_adjoint_evaluation_physics</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00169">_qoi_set</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00155">_residual_evaluation_physics</a>, <a class="el" href="type__vector_8h_source.html#l00112">std::abs()</a>, <a class="el" href="system_8C_source.html#l00750">libMesh::System::add_vector()</a>, <a class="el" href="implicit__system_8C_source.html#l00169">libMesh::ImplicitSystem::adjoint_solve()</a>, <a class="el" href="mesh__base_8h_source.html#l01169">libMesh::MeshBase::allow_renumbering()</a>, <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a>, <a class="el" href="implicit__system_8h_source.html#l00159">libMesh::ImplicitSystem::assembly()</a>, <a class="el" href="numeric__vector_8C_source.html#l00050">libMesh::NumericVector&lt; T &gt;::build()</a>, <a class="el" href="numeric__vector_8h_source.html#l01002">libMesh::NumericVector&lt; T &gt;::clear()</a>, <a class="el" href="diff__system_8h_source.html#l00150">libMesh::DifferentiableSystem::clone()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a42ea91bba70b3e7b27dad2a636ad31ae">libMesh::NumericVector&lt; T &gt;::close()</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00164">computed_global_QoI_errors</a>, <a class="el" href="system_8h_source.html#l01585">libMesh::System::current_local_solution</a>, <a class="el" href="dof__map_8C_source.html#l01992">libMesh::DofMap::dof_indices()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a4efa46e6fd605dd2a4aef2cb1b4ca81a">libMesh::NumericVector&lt; T &gt;::dot()</a>, <a class="el" href="dof__map__constraints_8C_source.html#l03285">libMesh::DofMap::enforce_adjoint_constraints_exactly()</a>, <a class="el" href="libmesh__common_8h_source.html#l00225">libMesh::ErrorVectorReal</a>, <a class="el" href="numeric__vector_8h_source.html#l01012">libMesh::NumericVector&lt; T &gt;::get()</a>, <a class="el" href="system_8C_source.html#l01192">libMesh::System::get_adjoint_solution()</a>, <a class="el" href="system_8h_source.html#l02293">libMesh::System::get_dof_map()</a>, <a class="el" href="system_8h_source.html#l00730">libMesh::System::get_equation_systems()</a>, <a class="el" href="equation__systems_8h_source.html#l00634">libMesh::EquationSystems::get_mesh()</a>, <a class="el" href="system_8h_source.html#l01775">libMesh::System::get_project_with_constraints()</a>, <a class="el" href="dof__map_8h_source.html#l00511">libMesh::DofMap::get_send_list()</a>, <a class="el" href="system_8C_source.html#l00917">libMesh::System::get_vector()</a>, <a class="el" href="enum__parallel__type_8h_source.html#l00037">libMesh::GHOSTED</a>, <a class="el" href="dof__map__constraints_8C_source.html#l05470">libMesh::DofMap::has_adjoint_dirichlet_boundaries()</a>, <a class="el" href="qoi__set_8h_source.html#l00224">libMesh::QoISet::has_index()</a>, <a class="el" href="dof__object_8h_source.html#l00823">libMesh::DofObject::id()</a>, <a class="el" href="namespacelibMesh_1_1TriangleWrapper.html#ae06da07f4c64d00ebefa55ce7f5c5e6b">libMesh::TriangleWrapper::init()</a>, <a class="el" href="system_8h_source.html#l00406">libMesh::System::is_adjoint_already_solved()</a>, <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a7348b5b027adf716016354847e0df0b6">libMesh::NumericVector&lt; T &gt;::localize()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a807e5541b5e0608c8847daf6f3ffc1cf">libMesh::MeshBase::max_elem_id()</a>, <a class="el" href="mesh__communication_8C_source.html#l01308">mesh</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ae5b70f8be225d006fb25ef1e6b82bc3a">libMesh::MeshBase::n_active_elem()</a>, <a class="el" href="system_8C_source.html#l00112">libMesh::System::n_dofs()</a>, <a class="el" href="system_8C_source.html#l00149">libMesh::System::n_local_dofs()</a>, <a class="el" href="system_8h_source.html#l02516">libMesh::System::n_qois()</a>, <a class="el" href="system_8h_source.html#l02269">libMesh::System::number()</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00116">number_h_refinements</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00121">number_p_refinements</a>, <a class="el" href="elem_8h_source.html#l02843">libMesh::Elem::parent()</a>, <a class="el" href="mesh__base_8h_source.html#l00150">libMesh::MeshBase::partitioner()</a>, <a class="el" href="system_8h_source.html#l00821">libMesh::System::project_solution_on_reinit()</a>, <a class="el" href="libmesh__common_8h_source.html#l00143">libMesh::Real</a>, <a class="el" href="error__estimator_8C_source.html#l00032">libMesh::ErrorEstimator::reduce_error()</a>, <a class="el" href="equation__systems_8C_source.html#l00105">libMesh::EquationSystems::reinit()</a>, <a class="el" href="system_8C_source.html#l00845">libMesh::System::remove_vector()</a>, <a class="el" href="system_8h_source.html#l01780">libMesh::System::set_project_with_constraints()</a>, <a class="el" href="system_8C_source.html#l01086">libMesh::System::set_vector_preservation()</a>, <a class="el" href="system_8h_source.html#l01573">libMesh::System::solution</a>, <a class="el" href="numeric__vector_8h_source.html#l01179">libMesh::NumericVector&lt; T &gt;::swap()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01709">libMesh::MeshRefinement::uniformly_coarsen()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01669">libMesh::MeshRefinement::uniformly_p_coarsen()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01655">libMesh::MeshRefinement::uniformly_p_refine()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01684">libMesh::MeshRefinement::uniformly_refine()</a>, <a class="el" href="system_8C_source.html#l00492">libMesh::System::update()</a>, <a class="el" href="system_8C_source.html#l00957">libMesh::System::vector_name()</a>, <a class="el" href="system_8C_source.html#l01096">libMesh::System::vector_preservation()</a>, <a class="el" href="system_8h_source.html#l02483">libMesh::System::vectors_begin()</a>, <a class="el" href="system_8h_source.html#l02495">libMesh::System::vectors_end()</a> , 以及 <a class="el" href="qoi__set_8h_source.html#l00243">libMesh::QoISet::weight()</a>.</p>

<p>参考自 <a class="el" href="euler2__solver_8C_source.html#l00322">libMesh::Euler2Solver::integrate_adjoint_refinement_error_estimate()</a>, <a class="el" href="euler__solver_8C_source.html#l00254">libMesh::EulerSolver::integrate_adjoint_refinement_error_estimate()</a> , 以及 <a class="el" href="steady__solver_8C_source.html#l00112">libMesh::SteadySolver::integrate_adjoint_refinement_error_estimate()</a>.</p>
<div class="fragment"><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;{</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  <span class="comment">// We have to break the rules here, because we can&#39;t refine a const System</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  System &amp; mutable_system = <span class="keyword">const_cast&lt;</span>System &amp;<span class="keyword">&gt;</span>(_system);</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  <span class="comment">// We really have to break the rules, because we can&#39;t do an</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  <span class="comment">// adjoint_solve without a matrix.</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  ImplicitSystem &amp; system = <span class="keyword">dynamic_cast&lt;</span>ImplicitSystem &amp;<span class="keyword">&gt;</span>(mutable_system);</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  <span class="comment">// An EquationSystems reference will be convenient.</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  EquationSystems &amp; es = system.get_equation_systems();</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  <span class="comment">// The current mesh</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  MeshBase &amp; <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a> = es.get_mesh();</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  <span class="comment">// Get coarse grid adjoint solutions.  This should be a relatively</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  <span class="comment">// quick (especially with preconditioner reuse) way to get a good</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  <span class="comment">// initial guess for the fine grid adjoint solutions.  More</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <span class="comment">// importantly, subtracting off a coarse adjoint approximation gives</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="comment">// us better local error indication, and subtracting off *some* lift</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="comment">// function is necessary for correctness if we have heterogeneous</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <span class="comment">// adjoint Dirichlet conditions.</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  <span class="comment">// Solve the adjoint problem(s) on the coarse FE space</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="comment">// Only if the user didn&#39;t already solve it for us</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="comment">// If _adjoint_evaluation_physics pointer is not null, swap</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="comment">// the current physics with the one held by _adjoint_evaluation_physics</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <span class="comment">// before assembling the adjoint problem</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="keywordflow">if</span> (!system.is_adjoint_already_solved())</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  {</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="comment">// Swap in different physics if needed</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a>)</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;      <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).push_physics(*<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a>);</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="comment">// Solve the adjoint problem, remember physics swap also resets the cache, so</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    <span class="comment">// we will assemble again, otherwise we just take the transpose</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    system.adjoint_solve(<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>);</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a>)</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;      <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).pop_physics();</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  }</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  <span class="comment">// Loop over all the adjoint problems and, if any have heterogenous</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  <span class="comment">// Dirichlet conditions, get the corresponding coarse lift</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  <span class="comment">// function(s)</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0,</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;       n_qois = system.n_qois(); j != n_qois; j++)</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;      <span class="comment">// Skip this QoI if it is not in the QoI Set or if there are no</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;      <span class="comment">// heterogeneous Dirichlet boundaries for it</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#a46749d10659b735c902b306fb5262818">has_index</a>(j) &amp;&amp;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;          system.get_dof_map().has_adjoint_dirichlet_boundaries(j))</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        {</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;          <span class="comment">// Next, we are going to build up the residual for evaluating the flux QoI</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;          <a class="code" href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">NumericVector&lt;Number&gt;</a> * coarse_residual = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;          <span class="comment">// The definition of a flux QoI is R(u^h, L) where R is the residual as defined</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;          <span class="comment">// by a conservation law. Therefore, if we are using stabilization, the</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;          <span class="comment">// R should be specified by the user via the residual_evaluation_physics</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;          <span class="comment">// If the residual physics pointer is not null, use it when</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;          <span class="comment">// evaluating here.</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;          {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>)</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;              <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).push_physics(*<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>);</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            <span class="comment">// Assemble without applying constraints, to capture the solution values on the boundary</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            system.assembly(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            <span class="comment">// Get the residual vector (no constraints applied on boundary, so we wont blow away the lift)</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            coarse_residual = &amp;system.get_vector(<span class="stringliteral">&quot;RHS Vector&quot;</span>);</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            coarse_residual-&gt;close();</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="comment">// Now build the lift function and add it to the system vectors</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            std::ostringstream liftfunc_name;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            liftfunc_name &lt;&lt; <span class="stringliteral">&quot;adjoint_lift_function&quot;</span> &lt;&lt; j;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;            system.add_vector(liftfunc_name.str());</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            <span class="comment">// Initialize lift with coarse adjoint solve associate with this flux QoI to begin with</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            system.get_vector(liftfunc_name.str()).<a class="code" href="namespacelibMesh_1_1TriangleWrapper.html#ae06da07f4c64d00ebefa55ce7f5c5e6b">init</a>(system.get_adjoint_solution(j), <span class="keyword">false</span>);</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            <span class="comment">// Build the actual lift using adjoint dirichlet conditions</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            system.get_dof_map().enforce_adjoint_constraints_exactly</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;              (system.get_vector(liftfunc_name.str()), static_cast&lt;unsigned int&gt;(j));</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;            <span class="comment">// Compute the flux R(u^h, L)</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            std::cout&lt;&lt;<span class="stringliteral">&quot;The flux QoI &quot;</span>&lt;&lt;<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(j)&lt;&lt;<span class="stringliteral">&quot; is: &quot;</span>&lt;&lt;coarse_residual-&gt;dot(system.get_vector(liftfunc_name.str()))&lt;&lt;std::endl&lt;&lt;std::endl;</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            <span class="comment">// Restore the original physics if needed</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>)</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;              <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).pop_physics();</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;          }</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        } <span class="comment">// End if QoI in set and flux/dirichlet boundary QoI</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    } <span class="comment">// End loop over QoIs</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <span class="comment">// We&#39;ll want to back up all coarse grid vectors</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  std::map&lt;std::string, std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt;&gt; coarse_vectors;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; [var_name, vec] : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(system.vectors_begin(), system.vectors_end()))</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    coarse_vectors[var_name] = vec-&gt;clone();</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="comment">// Back up the coarse solution and coarse local solution</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt; coarse_solution = system.solution-&gt;clone();</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt; coarse_local_solution = system.current_local_solution-&gt;clone();</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  <span class="comment">// We need to make sure that the coarse adjoint vectors used in the</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  <span class="comment">// calculations below are preserved during reinit, regardless of how</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  <span class="comment">// the user is treating them in their code</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  <span class="comment">// The adjoint lift function we have defined above is set to be preserved</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  <span class="comment">// by default</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  std::vector&lt;bool&gt; old_adjoints_projection_settings(system.n_qois());</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> j : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(system.n_qois()))</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    {</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#a46749d10659b735c902b306fb5262818">has_index</a>(j))</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;          <span class="comment">// Get the vector preservation setting for this adjoint vector</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;          <span class="keyword">auto</span> adjoint_vector_name = system.vector_name(system.get_adjoint_solution(j));</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;          <span class="keyword">auto</span> old_adjoint_vector_projection_setting = system.vector_preservation(adjoint_vector_name);</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;          <span class="comment">// Save for restoration later on</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;          old_adjoints_projection_settings[j] = old_adjoint_vector_projection_setting;</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;          <span class="comment">// Set the preservation to true for the upcoming reinits</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;          system.set_vector_preservation(adjoint_vector_name, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        }</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  <span class="comment">// And we&#39;ll need to temporarily change solution projection settings</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  <span class="keywordtype">bool</span> old_projection_setting;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  old_projection_setting = system.project_solution_on_reinit();</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  <span class="comment">// Make sure the solution is projected when we refine the mesh</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  system.project_solution_on_reinit() = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  <span class="comment">// And we need to make sure we dont reapply constraints after refining the mesh</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  <span class="keywordtype">bool</span> old_project_with_constraints_setting;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  old_project_with_constraints_setting = system.get_project_with_constraints();</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  system.set_project_with_constraints(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;  <span class="comment">// And it&#39;ll be best to avoid any repartitioning</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;  std::unique_ptr&lt;Partitioner&gt; old_partitioner(mesh.partitioner().release());</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  <span class="comment">// And we can&#39;t allow any renumbering</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">bool</span> old_renumbering_setting = mesh.allow_renumbering();</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  mesh.allow_renumbering(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  <span class="comment">// Use a non-standard solution vector if necessary</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <span class="keywordflow">if</span> (solution_vector &amp;&amp; solution_vector != system.solution.<a class="code" href="classlibMesh_1_1NumericVector.html#a8eac3a527f0194feae3a9dd80c878df1">get</a>())</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;      <a class="code" href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">NumericVector&lt;Number&gt;</a> * newsol =</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        <span class="keyword">const_cast&lt;</span><a class="code" href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">NumericVector&lt;Number&gt;</a> *<span class="keyword">&gt;</span> (solution_vector);</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;      newsol-&gt;swap(*system.solution);</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      system.update();</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    }</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  <span class="comment">// Resize the error_per_cell vector to be</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  <span class="comment">// the number of elements, initialized to 0.</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  error_per_cell.clear();</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  error_per_cell.resize (mesh.max_elem_id(), 0.);</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="preprocessor"></span>  <span class="comment">// These variables are only used in assertions later so</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  <span class="comment">// avoid declaring them unless asserts are active.</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> n_coarse_elem = mesh.n_active_elem();</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> local_dof_bearing_nodes = 0;</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sysnum = system.number();</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> * node : mesh.local_node_ptr_range())</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0, nvars = node-&gt;n_vars(sysnum);</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;         v != nvars; ++v)</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;      <span class="keywordflow">if</span> (node-&gt;n_comp(sysnum, v))</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        {</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;          local_dof_bearing_nodes++;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;          <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        }</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="preprocessor">#endif // NDEBUG</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  <span class="comment">// Uniformly refine the mesh</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  MeshRefinement mesh_refinement(mesh);</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  <span class="comment">// We only need to worry about Galerkin orthogonality if we</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <span class="comment">// are estimating discretization error in a single model setting</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  {</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">bool</span> swapping_adjoint_physics = <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a>;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="keywordflow">if</span>(!swapping_adjoint_physics)</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;      <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a> &gt; 0 || <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a> &gt; 0);</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  }</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  <span class="comment">// FIXME: this may break if there is more than one System</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="comment">// on this mesh but estimate_error was still called instead of</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  <span class="comment">// estimate_errors</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++i)</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    {</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;      mesh_refinement.uniformly_refine(1);</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;      es.reinit();</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    }</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a>; ++i)</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    {</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;      mesh_refinement.uniformly_p_refine(1);</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;      es.reinit();</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    }</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;  <span class="comment">// Copy the projected coarse grid solutions, which will be</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  <span class="comment">// overwritten by solve()</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  std::vector&lt;std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt;&gt; coarse_adjoints;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> j : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(system.n_qois()))</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    {</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#a46749d10659b735c902b306fb5262818">has_index</a>(j))</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        {</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;          <span class="keyword">auto</span> coarse_adjoint = <a class="code" href="classlibMesh_1_1NumericVector.html#adba4a30965537656bb3b0c6f924ff040">NumericVector&lt;Number&gt;::build</a>(mesh.comm());</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;          <span class="comment">// Can do &quot;fast&quot; init since we&#39;re overwriting this in a sec</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;          coarse_adjoint-&gt;init(system.get_adjoint_solution(j),</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                               <span class="comment">/* fast = */</span> <span class="keyword">true</span>);</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;          *coarse_adjoint = system.get_adjoint_solution(j);</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;          coarse_adjoints.emplace_back(std::move(coarse_adjoint));</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        }</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        coarse_adjoints.emplace_back(<span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    }</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;  <span class="comment">// Next, we are going to build up the residual for evaluating the</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  <span class="comment">// error estimate.</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  <span class="comment">// If the residual physics pointer is not null, use it when</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;  <span class="comment">// evaluating here.</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;  {</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>)</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;      <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).push_physics(*<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>);</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="comment">// Rebuild the rhs with the projected primal solution, do not apply constraints</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    system.assembly(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="comment">// Restore the original physics if needed</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>)</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;      <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).pop_physics();</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  }</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;  <a class="code" href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">NumericVector&lt;Number&gt;</a> &amp; projected_residual = (<span class="keyword">dynamic_cast&lt;</span>ExplicitSystem &amp;<span class="keyword">&gt;</span>(system)).get_vector(<span class="stringliteral">&quot;RHS Vector&quot;</span>);</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;  projected_residual.close();</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a>)</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).push_physics(*<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a>);</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;  <span class="comment">// Solve the adjoint problem(s) on the refined FE space</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;  <span class="comment">// The matrix will be reassembled again because we have refined the mesh</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;  <span class="comment">// If we have no h or p refinements, no need to solve for a fine adjoint</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;  <span class="keywordflow">if</span>(<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a> &gt; 0 || <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a> &gt; 0)</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    system.adjoint_solve(<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>);</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;  <span class="comment">// Swap back if needed, recall that _adjoint_evaluation_physics now holds the pointer</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  <span class="comment">// to the pre-swap physics</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a>)</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).pop_physics();</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  <span class="comment">// Now that we have the refined adjoint solution and the projected primal solution,</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  <span class="comment">// we first compute the global QoI error estimate</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  <span class="comment">// Resize the computed_global_QoI_errors vector to hold the error estimates for each QoI</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a>.resize(system.n_qois());</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  <span class="comment">// Loop over all the adjoint solutions and get the QoI error</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  <span class="comment">// contributions from all of them.  While we&#39;re looping anyway we&#39;ll</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <span class="comment">// pull off the coarse adjoints</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> j : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(system.n_qois()))</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    {</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      <span class="comment">// Skip this QoI if not in the QoI Set</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#a46749d10659b735c902b306fb5262818">has_index</a>(j))</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        {</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;          <span class="comment">// If the adjoint solution has heterogeneous dirichlet</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;          <span class="comment">// values, then to get a proper error estimate here we need</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;          <span class="comment">// to subtract off a coarse grid lift function.</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;          <span class="comment">// |Q(u) - Q(u^h)| = |R([u^h]+, z^h+ - [L]+)| + HOT</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;          <span class="keywordflow">if</span>(system.get_dof_map().has_adjoint_dirichlet_boundaries(j))</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;            {</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;              <span class="comment">// Need to create a string with current loop index to retrieve</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;              <span class="comment">// the correct vector from the liftvectors map</span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;              std::ostringstream liftfunc_name;</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;              liftfunc_name &lt;&lt; <span class="stringliteral">&quot;adjoint_lift_function&quot;</span> &lt;&lt; j;</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;              <span class="comment">// Subtract off the corresponding lift vector from the adjoint solution</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;              system.get_adjoint_solution(j) -= system.get_vector(liftfunc_name.str());</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;              <span class="comment">// Now evaluate R(u^h, z^h+ - lift)</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;              <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a>[j] = projected_residual.dot(system.get_adjoint_solution(j));</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;              <span class="comment">// Add the lift back to get back the adjoint</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;              system.get_adjoint_solution(j) += system.get_vector(liftfunc_name.str());</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            }</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;            {</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;              <span class="comment">// Usual dual weighted residual error estimate</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;              <span class="comment">// |Q(u) - Q(u^h)| = |R([u^h]+, z^h+)| + HOT</span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;              <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a>[j] = projected_residual.dot(system.get_adjoint_solution(j));</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;            }</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        }</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    }</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;  <span class="comment">// We are all done with Dirichlet lift vectors and they should be removed, lest we run into I/O issues later</span></div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> j : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(system.n_qois()))</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    {</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;      <span class="comment">// Skip this QoI if not in the QoI Set</span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#a46749d10659b735c902b306fb5262818">has_index</a>(j))</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        {</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;          <span class="comment">// Lifts are created only for adjoint dirichlet QoIs</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;          <span class="keywordflow">if</span>(system.get_dof_map().has_adjoint_dirichlet_boundaries(j))</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;            {</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;              <span class="comment">// Need to create a string with current loop index to retrieve</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;              <span class="comment">// the correct vector from the liftvectors map</span></div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;              std::ostringstream liftfunc_name;</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;              liftfunc_name &lt;&lt; <span class="stringliteral">&quot;adjoint_lift_function&quot;</span> &lt;&lt; j;</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;              <span class="comment">// Remove the lift vector from system since we did not write it to file and it cannot be retrieved</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;              system.remove_vector(liftfunc_name.str());</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;            }</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        }</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    }</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  <span class="comment">// Done with the global error estimates, now construct the element wise error indicators</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;  <span class="comment">// To get a better element wise breakdown of the error estimate,</span></div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;  <span class="comment">// we subtract off a coarse representation of the adjoint solution.</span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;  <span class="comment">// |Q(u) - Q(u^h)| = |R([u^h]+, z^h+ - [z^h]+)|</span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;  <span class="comment">// This remains valid for all combinations of heterogenous adjoint bcs and</span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;  <span class="comment">// stabilized/non-stabilized formulations, except for the case where we not using a</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  <span class="comment">// heterogenous adjoint bc and have a stabilized formulation.</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;  <span class="comment">// Then, R(u^h_s, z^h_s)  != 0 (no Galerkin orthogonality w.r.t the non-stabilized residual)</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> j : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(system.n_qois()))</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    {</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;      <span class="comment">// Skip this QoI if not in the QoI Set</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#a46749d10659b735c902b306fb5262818">has_index</a>(j))</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        {</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;          <span class="comment">// If we have a nullptr residual evaluation physics pointer, we</span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;          <span class="comment">// assume the user&#39;s formulation is consistent from mesh to</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;          <span class="comment">// mesh, so we have Galerkin orthogonality and we can get</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;          <span class="comment">// better indicator results by subtracting a coarse adjoint.</span></div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;          <span class="comment">// If we have a residual evaluation physics pointer, but we</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;          <span class="comment">// also have heterogeneous adjoint dirichlet boundaries,</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;          <span class="comment">// then we have to subtract off *some* lift function for</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;          <span class="comment">// consistency, and we choose the coarse adjoint in lieu of</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;          <span class="comment">// having any better ideas.</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;          <span class="comment">// If we have a residual evaluation physics pointer and we</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;          <span class="comment">// have homogeneous adjoint dirichlet boundaries, then we</span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;          <span class="comment">// don&#39;t have to subtract off anything, and with stabilized</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;          <span class="comment">// formulations we get the best results if we don&#39;t.</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;          <span class="keywordflow">if</span>(system.get_dof_map().has_adjoint_dirichlet_boundaries(j)</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;             || !<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>)</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;            {</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;              <span class="comment">// z^h+ -&gt; z^h+ - [z^h]+</span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;              system.get_adjoint_solution(j) -= *coarse_adjoints[j];</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;            }</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        }</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    }</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  <span class="comment">// We ought to account for &#39;spill-over&#39; effects while computing the</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  <span class="comment">// element error indicators This happens because the same dof is</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;  <span class="comment">// shared by multiple elements, one way of mitigating this is to</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  <span class="comment">// scale the contribution from each dof by the number of elements it</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;  <span class="comment">// belongs to We first obtain the number of elements each node</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  <span class="comment">// belongs to</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;  <span class="comment">// A map that relates a node id to an int that will tell us how many elements it is a node of</span></div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;  std::unordered_map&lt;dof_id_type, unsigned int&gt; shared_element_count;</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;  <span class="comment">// To fill this map, we will loop over elements, and then in each element, we will loop</span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;  <span class="comment">// over the nodes each element contains, and then query it for the number of coarse</span></div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  <span class="comment">// grid elements it was a node of</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;  <span class="comment">// Keep track of which nodes we have already dealt with</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  std::unordered_set&lt;dof_id_type&gt; processed_node_ids;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;  <span class="comment">// We will be iterating over all the active elements in the fine mesh that live on</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  <span class="comment">// this processor.</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : mesh.active_local_element_ptr_range())</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Node &amp; node : elem-&gt;node_ref_range())</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;      {</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        <span class="comment">// Get the id of this node</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> node_id = node.id();</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        <span class="comment">// If we haven&#39;t already processed this node, do so now</span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        <span class="keywordflow">if</span> (processed_node_ids.find(node_id) == processed_node_ids.end())</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;          {</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;            <span class="comment">// Declare a neighbor_set to be filled by the find_point_neighbors</span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;            std::set&lt;const Elem *&gt; fine_grid_neighbor_set;</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;            <span class="comment">// Call find_point_neighbors to fill the neighbor_set</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;            elem-&gt;find_point_neighbors(node, fine_grid_neighbor_set);</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;            <span class="comment">// A vector to hold the coarse grid parents neighbors</span></div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;            std::vector&lt;dof_id_type&gt; coarse_grid_neighbors;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            <span class="comment">// Loop over all the fine neighbors of this node</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; fine_elem : fine_grid_neighbor_set)</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;              {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                <span class="comment">// Find the element id for the corresponding coarse grid element</span></div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                <span class="keyword">const</span> Elem * coarse_elem = fine_elem;</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++j)</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;                  {</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                    <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (coarse_elem-&gt;parent());</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                    coarse_elem = coarse_elem-&gt;parent();</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                  }</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                <span class="comment">// Loop over the existing coarse neighbors and check if this one is</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                <span class="comment">// already in there</span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> coarse_id = coarse_elem-&gt;id();</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                std::size_t j = 0;</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;                <span class="comment">// If the set already contains this element break out of the loop</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                <span class="keywordflow">for</span> (std::size_t cgns = coarse_grid_neighbors.size(); j != cgns; j++)</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                  <span class="keywordflow">if</span> (coarse_grid_neighbors[j] == coarse_id)</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;                <span class="comment">// If we didn&#39;t leave the loop even at the last element,</span></div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;                <span class="comment">// this is a new neighbour, put in the coarse_grid_neighbor_set</span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;                <span class="keywordflow">if</span> (j == coarse_grid_neighbors.size())</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                  coarse_grid_neighbors.push_back(coarse_id);</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;              } <span class="comment">// End loop over fine neighbors</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;            <span class="comment">// Set the shared_neighbour index for this node to the</span></div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;            <span class="comment">// size of the coarse grid neighbor set</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;            shared_element_count[node_id] =</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;              cast_int&lt;unsigned int&gt;(coarse_grid_neighbors.size());</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;            <span class="comment">// Add this node to processed_node_ids vector</span></div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;            processed_node_ids.insert(node_id);</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;          } <span class="comment">// End if not processed node</span></div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;      } <span class="comment">// End loop over nodes</span></div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;  <span class="comment">// Get a DoF map, will be used to get the nodal dof_indices for each element</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;  DofMap &amp; dof_map = system.get_dof_map();</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;  <span class="comment">// The global DOF indices, we will use these later on when we compute the element wise indicators</span></div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  std::vector&lt;dof_id_type&gt; dof_indices;</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  <span class="comment">// Localize the global rhs and adjoint solution vectors (which might be shared on multiple processors) onto a</span></div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  <span class="comment">// local ghosted vector, this ensures each processor has all the dof_indices to compute an error indicator for</span></div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;  <span class="comment">// an element it owns</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;  std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt; localized_projected_residual = <a class="code" href="classlibMesh_1_1NumericVector.html#adba4a30965537656bb3b0c6f924ff040">NumericVector&lt;Number&gt;::build</a>(system.comm());</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  localized_projected_residual-&gt;init(system.n_dofs(), system.n_local_dofs(), system.get_dof_map().get_send_list(), <span class="keyword">false</span>, <a class="code" href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d">GHOSTED</a>);</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;  projected_residual.localize(*localized_projected_residual, system.get_dof_map().get_send_list());</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;  <span class="comment">// Each adjoint solution will also require ghosting; for efficiency we&#39;ll reuse the same memory</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;  std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt; localized_adjoint_solution = <a class="code" href="classlibMesh_1_1NumericVector.html#adba4a30965537656bb3b0c6f924ff040">NumericVector&lt;Number&gt;::build</a>(system.comm());</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  localized_adjoint_solution-&gt;init(system.n_dofs(), system.n_local_dofs(), system.get_dof_map().get_send_list(), <span class="keyword">false</span>, <a class="code" href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d">GHOSTED</a>);</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;  <span class="comment">// We will loop over each adjoint solution, localize that adjoint</span></div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  <span class="comment">// solution and then loop over local elements</span></div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(system.n_qois()))</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    {</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;      <span class="comment">// Skip this QoI if not in the QoI Set</span></div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#a46749d10659b735c902b306fb5262818">has_index</a>(i))</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        {</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;          <span class="comment">// Get the weight for the current QoI</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;          <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> error_weight = <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#aca792ddab47c10954d5dc416d77d5b16">weight</a>(i);</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;          (system.get_adjoint_solution(i)).localize(*localized_adjoint_solution, system.get_dof_map().get_send_list());</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;          <span class="comment">// Loop over elements</span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : mesh.active_local_element_ptr_range())</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            {</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;              <span class="comment">// Go up number_h_refinements levels up to find the coarse parent</span></div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;              <span class="keyword">const</span> Elem * coarse = elem;</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++j)</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                {</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;                  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (coarse-&gt;parent());</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                  coarse = coarse-&gt;parent();</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                }</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> e_id = coarse-&gt;id();</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;              <span class="comment">// Get the local to global degree of freedom maps for this element</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;              dof_map.dof_indices (elem, dof_indices);</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;              <span class="comment">// We will have to manually do the dot products.</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;              <a class="code" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> local_contribution = 0.;</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;              <span class="comment">// Sum the contribution to the error indicator for each element from the current QoI</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; dof : dof_indices)</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;                local_contribution += (*localized_projected_residual)(dof) * (*localized_adjoint_solution)(dof);</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;              <span class="comment">// Multiply by the error weight for this QoI</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;              local_contribution *= error_weight;</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;              <span class="comment">// FIXME: we&#39;re throwing away information in the</span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;              <span class="comment">// --enable-complex case</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;              error_per_cell[e_id] += <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibMesh.html#a26acf05f075521cbfb223db57e63d6d0">ErrorVectorReal</a><span class="keyword">&gt;</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                (<a class="code" href="namespacestd.html#aea71d536ca6ae5ef192477c8e9c9b197">std::abs</a>(local_contribution));</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;            } <span class="comment">// End loop over elements</span></div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;        } <span class="comment">// End if belong to QoI set</span></div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    } <span class="comment">// End loop over QoIs</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;  <span class="comment">// Don&#39;t bother projecting the solution; we&#39;ll restore from backup</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;  <span class="comment">// after coarsening</span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;  system.project_solution_on_reinit() = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;  <span class="comment">// Uniformly coarsen the mesh, without projecting the solution</span></div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;  <span class="comment">// Only need to do this if we are estimating discretization error</span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;  <span class="comment">// with a single physics residual</span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a> ||</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a> &gt; 0 || <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a> &gt; 0);</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++i)</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    {</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;      mesh_refinement.uniformly_coarsen(1);</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;      <span class="comment">// FIXME - should the reinits here be necessary? - RHS</span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;      es.reinit();</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;    }</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a>; ++i)</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;    {</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;      mesh_refinement.uniformly_p_coarsen(1);</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;      es.reinit();</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    }</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;  <span class="comment">// We should have the same number of active elements as when we started,</span></div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;  <span class="comment">// but not necessarily the same number of elements since reinit() doesn&#39;t</span></div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;  <span class="comment">// always call contract()</span></div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;  libmesh_assert_equal_to (n_coarse_elem, mesh.n_active_elem());</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;  <span class="comment">// We should have the same number of dof-bearing nodes as when we</span></div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;  <span class="comment">// started</span></div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="preprocessor"></span>  <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> final_local_dof_bearing_nodes = 0;</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> * node : mesh.local_node_ptr_range())</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0, nvars = node-&gt;n_vars(sysnum);</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;         v != nvars; ++v)</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;      <span class="keywordflow">if</span> (node-&gt;n_comp(sysnum, v))</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        {</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;          final_local_dof_bearing_nodes++;</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;          <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        }</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  libmesh_assert_equal_to (local_dof_bearing_nodes,</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;                           final_local_dof_bearing_nodes);</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="preprocessor">#endif // NDEBUG</span></div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  <span class="comment">// Restore old solutions and clean up the heap</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;  system.project_solution_on_reinit() = old_projection_setting;</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;  system.set_project_with_constraints(old_project_with_constraints_setting);</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;  <span class="comment">// Restore the adjoint vector preservation settings</span></div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> j : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(system.n_qois()))</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    {</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#a46749d10659b735c902b306fb5262818">has_index</a>(j))</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;        {</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;          <span class="keyword">auto</span> adjoint_vector_name = system.vector_name(system.get_adjoint_solution(j));</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;          system.set_vector_preservation(adjoint_vector_name, old_adjoints_projection_settings[j]);</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;        }</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;    }</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;  <span class="comment">// Restore the coarse solution vectors and delete their copies</span></div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;  *system.solution = *coarse_solution;</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;  *system.current_local_solution = *coarse_local_solution;</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(system.vectors_begin(), system.vectors_end()))</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    {</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;      <span class="comment">// The (string) name of this vector</span></div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;      <span class="keyword">const</span> std::string &amp; var_name = pr.first;</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;      <span class="comment">// If it&#39;s a vector we already had (and not a newly created</span></div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;      <span class="comment">// vector like an adjoint rhs), we need to restore it.</span></div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;      <span class="keyword">auto</span> it = coarse_vectors.find(var_name);</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;      <span class="keywordflow">if</span> (it != coarse_vectors.end())</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;        {</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;          <a class="code" href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">NumericVector&lt;Number&gt;</a> * coarsevec = it-&gt;second.get();</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;          system.get_vector(var_name) = *coarsevec;</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;          coarsevec-&gt;clear();</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        }</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;    }</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  <span class="comment">// Restore old partitioner and renumbering settings</span></div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;  mesh.partitioner().reset(old_partitioner.release());</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;  mesh.allow_renumbering(old_renumbering_setting);</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;  <span class="comment">// Finally sum the vector of estimated error values.</span></div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#ac29685e2e9f05123fd4d6db97326a2a9">reduce_error</a>(error_per_cell, system.comm());</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;  <span class="comment">// We don&#39;t take a square root here; this is a goal-oriented</span></div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;  <span class="comment">// estimate not a Hilbert norm estimate.</span></div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;} <span class="comment">// end estimate_error function</span></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_abacdc63e3e036a23fe2df82c14eee51e"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">libMesh::AdjointRefinementEstimator::_adjoint_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _adjoint_evaluation_physics</div><div class="ttdoc">Pointer to object to use for adjoint assembly. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00161">adjoint_refinement_estimator.h:161</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_ac29685e2e9f05123fd4d6db97326a2a9"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#ac29685e2e9f05123fd4d6db97326a2a9">libMesh::ErrorEstimator::reduce_error</a></div><div class="ttdeci">void reduce_error(std::vector&lt; ErrorVectorReal &gt; &amp;error_per_cell, const Parallel::Communicator &amp;comm) const </div><div class="ttdoc">This method takes the local error contributions in error_per_cell from each processor and combines th...</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8C_source.html#l00032">error_estimator.C:32</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="classlibMesh_1_1QoISet_html_aca792ddab47c10954d5dc416d77d5b16"><div class="ttname"><a href="classlibMesh_1_1QoISet.html#aca792ddab47c10954d5dc416d77d5b16">libMesh::QoISet::weight</a></div><div class="ttdeci">Real weight(std::size_t) const </div><div class="ttdoc">Get the weight for this index (default 1.0) </div><div class="ttdef"><b>Definition:</b> <a href="qoi__set_8h_source.html#l00243">qoi_set.h:243</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdoc">A QoISet to handle cases with multiple QoIs available. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00169">adjoint_refinement_estimator.h:169</a></div></div>
<div class="ttc" id="classlibMesh_1_1QoISet_html_a46749d10659b735c902b306fb5262818"><div class="ttname"><a href="classlibMesh_1_1QoISet.html#a46749d10659b735c902b306fb5262818">libMesh::QoISet::has_index</a></div><div class="ttdeci">bool has_index(std::size_t) const </div><div class="ttdoc">Return whether or not this index is in the set to be calculated. </div><div class="ttdef"><b>Definition:</b> <a href="qoi__set_8h_source.html#l00224">qoi_set.h:224</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26acf05f075521cbfb223db57e63d6d0"><div class="ttname"><a href="namespacelibMesh.html#a26acf05f075521cbfb223db57e63d6d0">libMesh::ErrorVectorReal</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef float ErrorVectorReal</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00225">libmesh_common.h:225</a></div></div>
<div class="ttc" id="namespacestd_html_aea71d536ca6ae5ef192477c8e9c9b197"><div class="ttname"><a href="namespacestd.html#aea71d536ca6ae5ef192477c8e9c9b197">std::abs</a></div><div class="ttdeci">ADRealEigenVector&lt; T, D, asd &gt; abs(const ADRealEigenVector&lt; T, D, asd &gt; &amp;)</div><div class="ttdoc">计算自动微分实数向量的绝对值。 </div><div class="ttdef"><b>Definition:</b> <a href="type__vector_8h_source.html#l00112">type_vector.h:112</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d"><div class="ttname"><a href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d">libMesh::GHOSTED</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__parallel__type_8h_source.html#l00037">enum_parallel_type.h:37</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a6775c045a6c8e84299b5467df9fc81ae"><div class="ttname"><a href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; IndexType &gt; as_range(const std::pair&lt; IndexType, IndexType &gt; &amp;p)</div><div class="ttdoc">Helper function that allows us to treat a homogenous pair as a range. </div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1TriangleWrapper_html_ae06da07f4c64d00ebefa55ce7f5c5e6b"><div class="ttname"><a href="namespacelibMesh_1_1TriangleWrapper.html#ae06da07f4c64d00ebefa55ce7f5c5e6b">libMesh::TriangleWrapper::init</a></div><div class="ttdeci">void init(triangulateio &amp;t)</div><div class="ttdoc">Initializes the fields of t to nullptr/0 as necessary. </div></div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af73f953ce5c33a52ea2b53364c1aff9c"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">libMesh::AdjointRefinementEstimator::_residual_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _residual_evaluation_physics</div><div class="ttdoc">Pointer to object to use for physics assembly evaluations. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00155">adjoint_refinement_estimator.h:155</a></div></div>
<div class="ttc" id="classlibMesh_1_1NumericVector_html_adba4a30965537656bb3b0c6f924ff040"><div class="ttname"><a href="classlibMesh_1_1NumericVector.html#adba4a30965537656bb3b0c6f924ff040">libMesh::NumericVector::build</a></div><div class="ttdeci">static std::unique_ptr&lt; NumericVector&lt; T &gt; &gt; build(const Parallel::Communicator &amp;comm, const SolverPackage solver_package=libMesh::default_solver_package())</div><div class="ttdoc">构建一个 NumericVector 对象。 </div><div class="ttdef"><b>Definition:</b> <a href="numeric__vector_8C_source.html#l00050">numeric_vector.C:50</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af635c66743cb57b7ffc0c16343055a8d"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">libMesh::AdjointRefinementEstimator::computed_global_QoI_errors</a></div><div class="ttdeci">std::vector&lt; Number &gt; computed_global_QoI_errors</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00164">adjoint_refinement_estimator.h:164</a></div></div>
<div class="ttc" id="namespacelibMesh_html_aef28359fb4851abec08fc99cfbac118d"><div class="ttname"><a href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">libMesh::Real</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE Real</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00143">libmesh_common.h:143</a></div></div>
<div class="ttc" id="classlibMesh_1_1NumericVector_html_a8eac3a527f0194feae3a9dd80c878df1"><div class="ttname"><a href="classlibMesh_1_1NumericVector.html#a8eac3a527f0194feae3a9dd80c878df1">libMesh::NumericVector::get</a></div><div class="ttdeci">virtual void get(const std::vector&lt; numeric_index_type &gt; &amp;index, T *values) const </div><div class="ttdoc">一次访问多个组件。 values 将 *不会* 重新分配空间；它应该已经具有足够的空间。 默认实现对每个索引调用 operator() ，但某些实现可能在此处提供更快的方法。 ...</div><div class="ttdef"><b>Definition:</b> <a href="numeric__vector_8h_source.html#l01012">numeric_vector.h:1012</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a8b17bf24a15bc292850c3a3894e2e8f9"><div class="ttname"><a href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">libMesh::Number</a></div><div class="ttdeci">Real Number</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00214">libmesh_common.h:214</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af63481288585b5ba172278c33c726667"><div class="ttname"><a href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">libMesh::NumericVector&lt; Number &gt;</a></div><div class="ttdeci">template class LIBMESH_EXPORT NumericVector&lt; Number &gt;</div><div class="ttdef"><b>Definition:</b> <a href="numeric__vector_8C_source.html#l00436">numeric_vector.C:436</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_a4437c7888b7459952e06a9157bf61ffe"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">libMesh::AdjointRefinementEstimator::number_h_refinements</a></div><div class="ttdeci">unsigned char number_h_refinements</div><div class="ttdoc">How many h refinements to perform to get the fine grid. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00116">adjoint_refinement_estimator.h:116</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_abff7ac97985f693cd3cc7a8311a24558"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">libMesh::AdjointRefinementEstimator::number_p_refinements</a></div><div class="ttdeci">unsigned char number_p_refinements</div><div class="ttdoc">How many p refinements to perform to get the fine grid. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00121">adjoint_refinement_estimator.h:121</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aad575aa2606bb47551e562a290499df0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ErrorEstimator::estimate_errors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;&#160;</td>
          <td class="paramname"><em>equation_systems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;&#160;</td>
          <td class="paramname"><em>error_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, <a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>error_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; * &gt; *&#160;</td>
          <td class="paramname"><em>solution_vectors</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>estimate_parent_error</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This virtual function can be redefined in derived classes, but by default computes the sum of the error_per_cell for each system in the equation_systems. </p>
<p>Currently this function ignores the error_norm member variable, and uses the function argument error_norms instead.</p>
<p>This function is named estimate_errors instead of estimate_error because otherwise C++ can get confused. </p>

<p>被 <a class="el" href="classlibMesh_1_1UniformRefinementEstimator.html#a41eeb5e8506a3489f913e1d3ec9c30b0">libMesh::UniformRefinementEstimator</a> 重载.</p>

<p>在文件 <a class="el" href="error__estimator_8C_source.html">error_estimator.C</a> 第 <a class="el" href="error__estimator_8C_source.html#l00047">47</a> 行定义.</p>

<p>参考 <a class="el" href="error__estimator_8h_source.html#l00158">libMesh::ErrorEstimator::error_norm</a>, <a class="el" href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">libMesh::ErrorEstimator::estimate_error()</a>, <a class="el" href="equation__systems_8h_source.html#l00745">libMesh::EquationSystems::get_system()</a>, <a class="el" href="int__range_8h_source.html#l00111">libMesh::index_range()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a> , 以及 <a class="el" href="equation__systems_8h_source.html#l00649">libMesh::EquationSystems::n_systems()</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;{</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  SystemNorm old_error_norm = this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a>;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <span class="comment">// Sum the error values from each system</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> s : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(equation_systems.n_systems()))</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    {</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;      ErrorVector system_error_per_cell;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;      <span class="keyword">const</span> System &amp; sys = equation_systems.get_system(s);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;      <span class="keywordflow">if</span> (error_norms.find(&amp;sys) == error_norms.end())</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = old_error_norm;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = error_norms.find(&amp;sys)-&gt;second;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">NumericVector&lt;Number&gt;</a> * solution_vector = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      <span class="keywordflow">if</span> (solution_vectors &amp;&amp;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;          solution_vectors-&gt;find(&amp;sys) != solution_vectors-&gt;end())</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        solution_vector = solution_vectors-&gt;find(&amp;sys)-&gt;second;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;      this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">estimate_error</a>(sys, system_error_per_cell,</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                           solution_vector, estimate_parent_error);</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;      <span class="keywordflow">if</span> (s)</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;          libmesh_assert_equal_to (error_per_cell.size(), system_error_per_cell.size());</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : <a class="code" href="namespacelibMesh.html#a26e38c0dc87c05a5e8df7e26bfed543b">index_range</a>(error_per_cell))</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            error_per_cell[i] += system_error_per_cell[i];</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        }</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        error_per_cell = system_error_per_cell;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    }</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="comment">// Restore our old state before returning</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = old_error_norm;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a9d626496b0b6f99f679c4ef4f0a5e46e"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">libMesh::ErrorEstimator::error_norm</a></div><div class="ttdeci">SystemNorm error_norm</div><div class="ttdoc">When estimating the error in a single system, the error_norm is used to control the scaling and norm ...</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8h_source.html#l00158">error_estimator.h:158</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_ab5ee8217ac35baaa00cc3b72e9815d93"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">libMesh::ErrorEstimator::estimate_error</a></div><div class="ttdeci">virtual void estimate_error(const System &amp;system, ErrorVector &amp;error_per_cell, const NumericVector&lt; Number &gt; *solution_vector=nullptr, bool estimate_parent_error=false)=0</div><div class="ttdoc">This pure virtual function must be redefined in derived classes to compute the error for each active ...</div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af63481288585b5ba172278c33c726667"><div class="ttname"><a href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">libMesh::NumericVector&lt; Number &gt;</a></div><div class="ttdeci">template class LIBMESH_EXPORT NumericVector&lt; Number &gt;</div><div class="ttdef"><b>Definition:</b> <a href="numeric__vector_8C_source.html#l00436">numeric_vector.C:436</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26e38c0dc87c05a5e8df7e26bfed543b"><div class="ttname"><a href="namespacelibMesh.html#a26e38c0dc87c05a5e8df7e26bfed543b">libMesh::index_range</a></div><div class="ttdeci">auto index_range(const T &amp;sizable)</div><div class="ttdoc">Helper function that returns an IntRange&amp;lt;std::size_t&amp;gt; representing all the indices of the passed-in v...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00111">int_range.h:111</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6bf8e0fb666d439804046465cf443867"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ErrorEstimator::estimate_errors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;&#160;</td>
          <td class="paramname"><em>equation_systems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#ab37d862060bbddf77099b6e34c62ef71">ErrorMap</a> &amp;&#160;</td>
          <td class="paramname"><em>errors_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; * &gt; *&#160;</td>
          <td class="paramname"><em>solution_vectors</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>estimate_parent_error</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This virtual function can be redefined in derived classes, but by default it calls estimate_error repeatedly to calculate the requested error vectors. </p>
<p>FIXME: This is a default implementation - derived classes should reimplement it for efficiency.</p>
<p>Currently this function ignores the <a class="el" href="namespacelibMesh_1_1MeshTools.html#a0701de7f01fd5eced3da4a332ff5ae51">error_norm.weight()</a> values because it calculates each variable's error individually, unscaled.</p>
<p>The user selects which errors get computed by filling a map with error vectors: If errors_per_cell[&amp;system][v] exists, it will be filled with the error values in variable <code>v</code> of <code>system</code> </p>

<p>被 <a class="el" href="classlibMesh_1_1UniformRefinementEstimator.html#a676215e74e7c4517162b4431835453a4">libMesh::UniformRefinementEstimator</a> 重载.</p>

<p>在文件 <a class="el" href="error__estimator_8C_source.html">error_estimator.C</a> 第 <a class="el" href="error__estimator_8C_source.html#l00093">93</a> 行定义.</p>

<p>参考 <a class="el" href="error__estimator_8h_source.html#l00158">libMesh::ErrorEstimator::error_norm</a>, <a class="el" href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">libMesh::ErrorEstimator::estimate_error()</a>, <a class="el" href="equation__systems_8h_source.html#l00745">libMesh::EquationSystems::get_system()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a>, <a class="el" href="equation__systems_8h_source.html#l00649">libMesh::EquationSystems::n_systems()</a>, <a class="el" href="tecplot__io_8C_source.html#l00068">n_vars</a>, <a class="el" href="system_8h_source.html#l02349">libMesh::System::n_vars()</a> , 以及 <a class="el" href="system__norm_8C_source.html#l00112">libMesh::SystemNorm::type()</a>.</p>
<div class="fragment"><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;{</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  SystemNorm old_error_norm = this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a>;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  <span class="comment">// Find the requested error values from each system</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> s : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(equation_systems.n_systems()))</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    {</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;      <span class="keyword">const</span> System &amp; sys = equation_systems.get_system(s);</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="tecplot__io_8C.html#ac001e4247887b98c2aa5b8ec5107ca0d">n_vars</a> = sys.n_vars();</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v != <a class="code" href="tecplot__io_8C.html#ac001e4247887b98c2aa5b8ec5107ca0d">n_vars</a>; ++v)</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;          <span class="comment">// Only fill in ErrorVectors the user asks for</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;          <span class="keywordflow">if</span> (!errors_per_cell.count(std::make_pair(&amp;sys, v)))</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;          <span class="comment">// Calculate error in only one variable</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;          std::vector&lt;Real&gt; weights(n_vars, 0.0);</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;          weights[v] = 1.0;</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;          this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> =</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            SystemNorm(std::vector&lt;FEMNormType&gt;(n_vars, old_error_norm.type(v)),</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                       weights);</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">NumericVector&lt;Number&gt;</a> * solution_vector = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;          <span class="keywordflow">if</span> (solution_vectors &amp;&amp;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;              solution_vectors-&gt;find(&amp;sys) != solution_vectors-&gt;end())</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            solution_vector = solution_vectors-&gt;find(&amp;sys)-&gt;second;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;          this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">estimate_error</a></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            (sys, *errors_per_cell[std::make_pair(&amp;sys, v)],</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;             solution_vector, estimate_parent_error);</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        }</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    }</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="comment">// Restore our old state before returning</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = old_error_norm;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a9d626496b0b6f99f679c4ef4f0a5e46e"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">libMesh::ErrorEstimator::error_norm</a></div><div class="ttdeci">SystemNorm error_norm</div><div class="ttdoc">When estimating the error in a single system, the error_norm is used to control the scaling and norm ...</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8h_source.html#l00158">error_estimator.h:158</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_ab5ee8217ac35baaa00cc3b72e9815d93"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">libMesh::ErrorEstimator::estimate_error</a></div><div class="ttdeci">virtual void estimate_error(const System &amp;system, ErrorVector &amp;error_per_cell, const NumericVector&lt; Number &gt; *solution_vector=nullptr, bool estimate_parent_error=false)=0</div><div class="ttdoc">This pure virtual function must be redefined in derived classes to compute the error for each active ...</div></div>
<div class="ttc" id="tecplot__io_8C_html_ac001e4247887b98c2aa5b8ec5107ca0d"><div class="ttname"><a href="tecplot__io_8C.html#ac001e4247887b98c2aa5b8ec5107ca0d">n_vars</a></div><div class="ttdeci">const unsigned int n_vars</div><div class="ttdef"><b>Definition:</b> <a href="tecplot__io_8C_source.html#l00068">tecplot_io.C:68</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af63481288585b5ba172278c33c726667"><div class="ttname"><a href="namespacelibMesh.html#af63481288585b5ba172278c33c726667">libMesh::NumericVector&lt; Number &gt;</a></div><div class="ttdeci">template class LIBMESH_EXPORT NumericVector&lt; Number &gt;</div><div class="ttdef"><b>Definition:</b> <a href="numeric__vector_8C_source.html#l00436">numeric_vector.C:436</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7499cfbc2f746c821d121572d6b3ac08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a>* libMesh::AdjointRefinementEstimator::get_adjoint_evaluation_physics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>返回</dt><dd>A pointer to the <a class="el" href="classlibMesh_1_1DifferentiablePhysics.html" title="This class provides a specific system class. ">DifferentiablePhysics</a> object or <code>nullptr</code> if no external Physics object is attached. </dd></dl>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00140">140</a> 行定义.</p>

<p>参考 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00161">_adjoint_evaluation_physics</a>.</p>
<div class="fragment"><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  { <span class="keywordflow">return</span> this-&gt;<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_abacdc63e3e036a23fe2df82c14eee51e"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">libMesh::AdjointRefinementEstimator::_adjoint_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _adjoint_evaluation_physics</div><div class="ttdoc">Pointer to object to use for adjoint assembly. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00161">adjoint_refinement_estimator.h:161</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0143c56bd2fdc236700dd3b1262d7097"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a>&amp; libMesh::AdjointRefinementEstimator::get_global_QoI_error_estimate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>qoi_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an accessor function to access the computed global QoI error estimates. </p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00106">106</a> 行定义.</p>

<p>参考 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00164">computed_global_QoI_errors</a>.</p>

<p>参考自 <a class="el" href="euler2__solver_8C_source.html#l00322">libMesh::Euler2Solver::integrate_adjoint_refinement_error_estimate()</a>, <a class="el" href="euler__solver_8C_source.html#l00254">libMesh::EulerSolver::integrate_adjoint_refinement_error_estimate()</a> , 以及 <a class="el" href="steady__solver_8C_source.html#l00112">libMesh::SteadySolver::integrate_adjoint_refinement_error_estimate()</a>.</p>
<div class="fragment"><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a>[qoi_index];</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af635c66743cb57b7ffc0c16343055a8d"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">libMesh::AdjointRefinementEstimator::computed_global_QoI_errors</a></div><div class="ttdeci">std::vector&lt; Number &gt; computed_global_QoI_errors</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00164">adjoint_refinement_estimator.h:164</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac4d2e7401de04e31b0a1c81650ec72e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a>* libMesh::AdjointRefinementEstimator::get_residual_evaluation_physics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>返回</dt><dd>A pointer to the <a class="el" href="classlibMesh_1_1DifferentiablePhysics.html" title="This class provides a specific system class. ">DifferentiablePhysics</a> object or <code>nullptr</code> if no external Physics object is attached. </dd></dl>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00127">127</a> 行定义.</p>

<p>参考 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00155">_residual_evaluation_physics</a>.</p>
<div class="fragment"><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  { <span class="keywordflow">return</span> this-&gt;<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af73f953ce5c33a52ea2b53364c1aff9c"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">libMesh::AdjointRefinementEstimator::_residual_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _residual_evaluation_physics</div><div class="ttdoc">Pointer to object to use for physics assembly evaluations. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00155">adjoint_refinement_estimator.h:155</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4afd6c830b8dddbfb1014edf18f8f69c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a>&amp; libMesh::AdjointRefinementEstimator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a07208352932dfb91f3b7035729f137"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a>&amp; libMesh::AdjointRefinementEstimator::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0aca6ed2c5e83a66cbea3fb745d42bb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a>&amp; libMesh::AdjointRefinementEstimator::qoi_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the <a class="el" href="classlibMesh_1_1QoISet.html" title="Data structure for specifying which Quantities of Interest should be calculated in an adjoint or a pa...">QoISet</a> (default: weight all QoIs equally) to use when computing errors. </p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00073">73</a> 行定义.</p>

<p>参考 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00169">_qoi_set</a>.</p>

<p>参考自 <a class="el" href="euler2__solver_8C_source.html#l00322">libMesh::Euler2Solver::integrate_adjoint_refinement_error_estimate()</a>, <a class="el" href="twostep__time__solver_8C_source.html#l00400">libMesh::TwostepTimeSolver::integrate_adjoint_refinement_error_estimate()</a>, <a class="el" href="euler__solver_8C_source.html#l00254">libMesh::EulerSolver::integrate_adjoint_refinement_error_estimate()</a> , 以及 <a class="el" href="steady__solver_8C_source.html#l00112">libMesh::SteadySolver::integrate_adjoint_refinement_error_estimate()</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdoc">A QoISet to handle cases with multiple QoIs available. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00169">adjoint_refinement_estimator.h:169</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afcdc392b69087dc11dc56fe15b29708a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a>&amp; libMesh::AdjointRefinementEstimator::qoi_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the <a class="el" href="classlibMesh_1_1QoISet.html" title="Data structure for specifying which Quantities of Interest should be calculated in an adjoint or a pa...">QoISet</a> (default: weight all QoIs equally) to use when computing errors. </p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00079">79</a> 行定义.</p>

<p>参考 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00169">_qoi_set</a>.</p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdoc">A QoISet to handle cases with multiple QoIs available. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00169">adjoint_refinement_estimator.h:169</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac29685e2e9f05123fd4d6db97326a2a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ErrorEstimator::reduce_error </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacelibMesh.html#a26acf05f075521cbfb223db57e63d6d0">ErrorVectorReal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>error_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Parallel::Communicator &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method takes the local error contributions in <code>error_per_cell</code> from each processor and combines them to get the global error vector. </p>

<p>在文件 <a class="el" href="error__estimator_8C_source.html">error_estimator.C</a> 第 <a class="el" href="error__estimator_8C_source.html#l00032">32</a> 行定义.</p>

<p>参考自 <a class="el" href="uniform__refinement__estimator_8C_source.html#l00119">libMesh::UniformRefinementEstimator::_estimate_error()</a>, <a class="el" href="patch__recovery__error__estimator_8C_source.html#l00154">libMesh::PatchRecoveryErrorEstimator::estimate_error()</a>, <a class="el" href="weighted__patch__recovery__error__estimator_8C_source.html#l00055">libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error()</a>, <a class="el" href="jump__error__estimator_8C_source.html#l00056">libMesh::JumpErrorEstimator::estimate_error()</a>, <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00091">estimate_error()</a> , 以及 <a class="el" href="exact__error__estimator_8C_source.html#l00188">libMesh::ExactErrorEstimator::estimate_error()</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;{</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="comment">// parallel_object_only();</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="comment">// Each processor has now computed the error contributions</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  <span class="comment">// for its local elements.  We may need to sum the vector to</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="comment">// recover the error for each element.</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  comm.sum(error_per_cell);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad8c42e8462ef88c3e680b1d1b67e2d98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::AdjointRefinementEstimator::set_adjoint_evaluation_physics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *&#160;</td>
          <td class="paramname"><em>set_physics</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the _adjoint_evaluation_physics member to argument. </p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00146">146</a> 行定义.</p>

<p>参考 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00161">_adjoint_evaluation_physics</a>.</p>
<div class="fragment"><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  { this-&gt;<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">_adjoint_evaluation_physics</a> = set_physics; }</div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_abacdc63e3e036a23fe2df82c14eee51e"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#abacdc63e3e036a23fe2df82c14eee51e">libMesh::AdjointRefinementEstimator::_adjoint_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _adjoint_evaluation_physics</div><div class="ttdoc">Pointer to object to use for adjoint assembly. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00161">adjoint_refinement_estimator.h:161</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a13d69ad607bba49f333dd775ccdd7ca1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::AdjointRefinementEstimator::set_residual_evaluation_physics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *&#160;</td>
          <td class="paramname"><em>set_physics</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the _residual_evaluation_physics member to argument. </p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00133">133</a> 行定义.</p>

<p>参考 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00155">_residual_evaluation_physics</a>.</p>
<div class="fragment"><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  { this-&gt;<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a> = set_physics; }</div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af73f953ce5c33a52ea2b53364c1aff9c"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">libMesh::AdjointRefinementEstimator::_residual_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _residual_evaluation_physics</div><div class="ttdoc">Pointer to object to use for physics assembly evaluations. </div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00155">adjoint_refinement_estimator.h:155</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3db466224010af9c371440ffa67c43c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#a370493a82a7f09613a0fdc56fc7912b7">ErrorEstimatorType</a> libMesh::AdjointRefinementEstimator::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>返回</dt><dd>The type for the <a class="el" href="classlibMesh_1_1ErrorEstimator.html" title="This class holds functions that will estimate the error in a finite element solution on a given mesh...">ErrorEstimator</a> subclass. </dd></dl>

<p>实现了 <a class="el" href="classlibMesh_1_1ErrorEstimator.html#a8a3162f59ee5f231d73ab54252cfa8f1">libMesh::ErrorEstimator</a>.</p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8C_source.html">adjoint_refinement_estimator.C</a> 第 <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00086">86</a> 行定义.</p>

<p>参考 <a class="el" href="enum__error__estimator__type_8h_source.html#l00035">libMesh::ADJOINT_REFINEMENT</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;{</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacelibMesh.html#a370493a82a7f09613a0fdc56fc7912b7a1edbba5ae493642ac736dc793aac4063">ADJOINT_REFINEMENT</a>;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_html_a370493a82a7f09613a0fdc56fc7912b7a1edbba5ae493642ac736dc793aac4063"><div class="ttname"><a href="namespacelibMesh.html#a370493a82a7f09613a0fdc56fc7912b7a1edbba5ae493642ac736dc793aac4063">libMesh::ADJOINT_REFINEMENT</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__error__estimator__type_8h_source.html#l00035">enum_error_estimator_type.h:35</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a class="anchor" id="abacdc63e3e036a23fe2df82c14eee51e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a>* libMesh::AdjointRefinementEstimator::_adjoint_evaluation_physics</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to object to use for adjoint assembly. </p>
<p>Defaults to nullptr for backwards compatibility. </p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00161">161</a> 行定义.</p>

<p>参考自 <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00091">estimate_error()</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00140">get_adjoint_evaluation_physics()</a> , 以及 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00146">set_adjoint_evaluation_physics()</a>.</p>

</div>
</div>
<a class="anchor" id="ad51061a9299eba61c328edca03b0cd20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> libMesh::AdjointRefinementEstimator::_qoi_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classlibMesh_1_1QoISet.html" title="Data structure for specifying which Quantities of Interest should be calculated in an adjoint or a pa...">QoISet</a> to handle cases with multiple QoIs available. </p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00169">169</a> 行定义.</p>

<p>参考自 <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00091">estimate_error()</a> , 以及 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00073">qoi_set()</a>.</p>

</div>
</div>
<a class="anchor" id="af73f953ce5c33a52ea2b53364c1aff9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a>* libMesh::AdjointRefinementEstimator::_residual_evaluation_physics</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to object to use for physics assembly evaluations. </p>
<p>Defaults to nullptr for backwards compatibility. </p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00155">155</a> 行定义.</p>

<p>参考自 <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00091">estimate_error()</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00127">get_residual_evaluation_physics()</a> , 以及 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00133">set_residual_evaluation_physics()</a>.</p>

</div>
</div>
<a class="anchor" id="af635c66743cb57b7ffc0c16343055a8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a>&gt; libMesh::AdjointRefinementEstimator::computed_global_QoI_errors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00164">164</a> 行定义.</p>

<p>参考自 <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00091">estimate_error()</a> , 以及 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00106">get_global_QoI_error_estimate()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d626496b0b6f99f679c4ef4f0a5e46e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> libMesh::ErrorEstimator::error_norm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When estimating the error in a single system, the <code>error_norm</code> is used to control the scaling and norm choice for each variable. </p>
<p>Not all estimators will support all norm choices. The default scaling is for all variables to be weighted equally. The default norm choice depends on the error estimator.</p>
<p>Part of this functionality was supported via component_scale and sobolev_order in older <a class="el" href="namespacelibMesh.html" title="The libMesh namespace provides an interface to certain functionality in the library. ">libMesh</a> versions, and a small part was supported via component_mask in even older versions. Hopefully the encapsulation here will allow us to avoid changing this API again. </p>

<p>在文件 <a class="el" href="error__estimator_8h_source.html">error_estimator.h</a> 第 <a class="el" href="error__estimator_8h_source.html#l00158">158</a> 行定义.</p>

<p>参考自 <a class="el" href="uniform__refinement__estimator_8C_source.html#l00119">libMesh::UniformRefinementEstimator::_estimate_error()</a>, <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00073">AdjointRefinementEstimator()</a>, <a class="el" href="discontinuity__measure_8C_source.html#l00129">libMesh::DiscontinuityMeasure::boundary_side_integration()</a>, <a class="el" href="kelly__error__estimator_8C_source.html#l00135">libMesh::KellyErrorEstimator::boundary_side_integration()</a>, <a class="el" href="discontinuity__measure_8C_source.html#l00041">libMesh::DiscontinuityMeasure::DiscontinuityMeasure()</a>, <a class="el" href="jump__error__estimator_8C_source.html#l00056">libMesh::JumpErrorEstimator::estimate_error()</a>, <a class="el" href="adjoint__residual__error__estimator_8C_source.html#l00061">libMesh::AdjointResidualErrorEstimator::estimate_error()</a>, <a class="el" href="exact__error__estimator_8C_source.html#l00188">libMesh::ExactErrorEstimator::estimate_error()</a>, <a class="el" href="error__estimator_8C_source.html#l00047">libMesh::ErrorEstimator::estimate_errors()</a>, <a class="el" href="exact__error__estimator_8C_source.html#l00049">libMesh::ExactErrorEstimator::ExactErrorEstimator()</a>, <a class="el" href="exact__error__estimator_8C_source.html#l00402">libMesh::ExactErrorEstimator::find_squared_element_error()</a>, <a class="el" href="fourth__error__estimators_8C_source.html#l00063">libMesh::LaplacianErrorEstimator::init_context()</a>, <a class="el" href="discontinuity__measure_8C_source.html#l00059">libMesh::DiscontinuityMeasure::init_context()</a>, <a class="el" href="kelly__error__estimator_8C_source.html#l00059">libMesh::KellyErrorEstimator::init_context()</a>, <a class="el" href="fourth__error__estimators_8C_source.html#l00090">libMesh::LaplacianErrorEstimator::internal_side_integration()</a>, <a class="el" href="discontinuity__measure_8C_source.html#l00086">libMesh::DiscontinuityMeasure::internal_side_integration()</a>, <a class="el" href="kelly__error__estimator_8C_source.html#l00090">libMesh::KellyErrorEstimator::internal_side_integration()</a>, <a class="el" href="kelly__error__estimator_8C_source.html#l00041">libMesh::KellyErrorEstimator::KellyErrorEstimator()</a>, <a class="el" href="fourth__error__estimators_8C_source.html#l00046">libMesh::LaplacianErrorEstimator::LaplacianErrorEstimator()</a>, <a class="el" href="weighted__patch__recovery__error__estimator_8C_source.html#l00112">libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()()</a>, <a class="el" href="patch__recovery__error__estimator_8C_source.html#l00211">libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()()</a>, <a class="el" href="patch__recovery__error__estimator_8C_source.html#l00065">libMesh::PatchRecoveryErrorEstimator::PatchRecoveryErrorEstimator()</a>, <a class="el" href="jump__error__estimator_8C_source.html#l00450">libMesh::JumpErrorEstimator::reinit_sides()</a> , 以及 <a class="el" href="uniform__refinement__estimator_8C_source.html#l00054">libMesh::UniformRefinementEstimator::UniformRefinementEstimator()</a>.</p>

</div>
</div>
<a class="anchor" id="a4437c7888b7459952e06a9157bf61ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char libMesh::AdjointRefinementEstimator::number_h_refinements</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many h refinements to perform to get the fine grid. </p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00116">116</a> 行定义.</p>

<p>参考自 <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00091">estimate_error()</a>.</p>

</div>
</div>
<a class="anchor" id="abff7ac97985f693cd3cc7a8311a24558"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char libMesh::AdjointRefinementEstimator::number_p_refinements</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many p refinements to perform to get the fine grid. </p>

<p>在文件 <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a> 第 <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00121">121</a> 行定义.</p>

<p>参考自 <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00091">estimate_error()</a>.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>/home/lwz/libmesh/include/error_estimation/<a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a></li>
<li>/home/lwz/libmesh/src/error_estimation/<a class="el" href="adjoint__refinement__estimator_8C_source.html">adjoint_refinement_estimator.C</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2023年 十二月 20日 星期三 12:09:08 , 为 libmesh解析使用  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
