<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libmesh解析: libMesh::SubdomainPartitioner类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libmesh解析
   </div>
   <div id="projectbrief">本工作只是尝试解析原libmesh的代码,供学习使用</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li class="current"><a href="annotated.html"><span>类</span></a></li>
      <li><a href="files.html"><span>文件</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>类列表</span></a></li>
      <li><a href="classes.html"><span>类索引</span></a></li>
      <li><a href="inherits.html"><span>类继承关系</span></a></li>
      <li><a href="functions.html"><span>类成员</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>全部</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>类</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>命名空间</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>文件</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>函数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>变量</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>类型定义</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>枚举</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>枚举值</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>友元</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>页</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="#pub-attribs">Public 属性</a> &#124;
<a href="#pro-methods">Protected 成员函数</a> &#124;
<a href="#pro-attribs">Protected 属性</a> &#124;
<a href="#pro-static-attribs">静态 Protected 属性</a> &#124;
<a href="classlibMesh_1_1SubdomainPartitioner-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::SubdomainPartitioner类 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <code><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html" title="The SubdomainPartitioner partitions the elements in &quot;chunks&quot; of user-specified subdomain ids...">SubdomainPartitioner</a></code> partitions the elements in "chunks" of user-specified subdomain ids.  
 <a href="classlibMesh_1_1SubdomainPartitioner.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="subdomain__partitioner_8h_source.html">subdomain_partitioner.h</a>&gt;</code></p>
<div class="dynheader">
类 libMesh::SubdomainPartitioner 继承关系图:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:aba5beb711ed1c65fd3dabf52e503591d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#aba5beb711ed1c65fd3dabf52e503591d">SubdomainPartitioner</a> ()</td></tr>
<tr class="memdesc:aba5beb711ed1c65fd3dabf52e503591d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructors.  <a href="#aba5beb711ed1c65fd3dabf52e503591d">更多...</a><br/></td></tr>
<tr class="separator:aba5beb711ed1c65fd3dabf52e503591d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b754ecac6755535667ea276185f9a7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#a7b754ecac6755535667ea276185f9a7f">SubdomainPartitioner</a> (const <a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a> &amp;other)</td></tr>
<tr class="separator:a7b754ecac6755535667ea276185f9a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98de32a8141cf87d48215b5d1b34c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#ad98de32a8141cf87d48215b5d1b34c07">operator=</a> (const <a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a> &amp;)=delete</td></tr>
<tr class="memdesc:ad98de32a8141cf87d48215b5d1b34c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains a unique_ptr member, so it can't be default copy assigned.  <a href="#ad98de32a8141cf87d48215b5d1b34c07">更多...</a><br/></td></tr>
<tr class="separator:ad98de32a8141cf87d48215b5d1b34c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637740189bf4eb5dbdec4f2899083656"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#a637740189bf4eb5dbdec4f2899083656">SubdomainPartitioner</a> (<a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a637740189bf4eb5dbdec4f2899083656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move ctor, move assignment operator, and destructor are all explicitly defaulted for this class.  <a href="#a637740189bf4eb5dbdec4f2899083656">更多...</a><br/></td></tr>
<tr class="separator:a637740189bf4eb5dbdec4f2899083656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebd9bff041341d409af7c8f146ed844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#aaebd9bff041341d409af7c8f146ed844">operator=</a> (<a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a> &amp;&amp;)=default</td></tr>
<tr class="separator:aaebd9bff041341d409af7c8f146ed844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d26252205bc7bc4f39bcf41d6907f61"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#a2d26252205bc7bc4f39bcf41d6907f61">~SubdomainPartitioner</a> ()=default</td></tr>
<tr class="separator:a2d26252205bc7bc4f39bcf41d6907f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4b600c3ee52b7add448356ecdf4e0b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9">PartitionerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#aab4b600c3ee52b7add448356ecdf4e0b">type</a> () const override</td></tr>
<tr class="separator:aab4b600c3ee52b7add448356ecdf4e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37fe9e521c27a8acdb574984ac328f4"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classlibMesh_1_1Partitioner.html">Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#aa37fe9e521c27a8acdb574984ac328f4">clone</a> () const override</td></tr>
<tr class="separator:aa37fe9e521c27a8acdb574984ac328f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4843abeb1af6f4359f5cf5f7dcfa3ff3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1Partitioner.html">Partitioner</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#a4843abeb1af6f4359f5cf5f7dcfa3ff3">internal_partitioner</a> ()</td></tr>
<tr class="memdesc:a4843abeb1af6f4359f5cf5f7dcfa3ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a> used internally by the <a class="el" href="classlibMesh_1_1SubdomainPartitioner.html" title="The SubdomainPartitioner partitions the elements in &quot;chunks&quot; of user-specified subdomain ids...">SubdomainPartitioner</a>.  <a href="#a4843abeb1af6f4359f5cf5f7dcfa3ff3">更多...</a><br/></td></tr>
<tr class="separator:a4843abeb1af6f4359f5cf5f7dcfa3ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31df72bf643af2bd53e61ed6bf6e77f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a31df72bf643af2bd53e61ed6bf6e77f0">partition</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const unsigned int n)</td></tr>
<tr class="memdesc:a31df72bf643af2bd53e61ed6bf6e77f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions the <code><a class="el" href="classlibMesh_1_1MeshBase.html" title="This is the MeshBase class. ">MeshBase</a></code> into <code>n</code> parts by setting processor_id() on Nodes and Elems.  <a href="#a31df72bf643af2bd53e61ed6bf6e77f0">更多...</a><br/></td></tr>
<tr class="separator:a31df72bf643af2bd53e61ed6bf6e77f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af141c068984e9f0a044aa364d3f98b4b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#af141c068984e9f0a044aa364d3f98b4b">partition</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:af141c068984e9f0a044aa364d3f98b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions the <code><a class="el" href="classlibMesh_1_1MeshBase.html" title="This is the MeshBase class. ">MeshBase</a></code> into <code>mesh.n_processors()</code> by setting processor_id() on Nodes and Elems.  <a href="#af141c068984e9f0a044aa364d3f98b4b">更多...</a><br/></td></tr>
<tr class="separator:af141c068984e9f0a044aa364d3f98b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba95cc151a18676235b081c5accb547d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#aba95cc151a18676235b081c5accb547d">partition_range</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;, <a class="el" href="structlibMesh_1_1MeshBase_1_1element__iterator.html">MeshBase::element_iterator</a>, <a class="el" href="structlibMesh_1_1MeshBase_1_1element__iterator.html">MeshBase::element_iterator</a>, const unsigned int)</td></tr>
<tr class="memdesc:aba95cc151a18676235b081c5accb547d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions elements in the range (it, end) into n parts.  <a href="#aba95cc151a18676235b081c5accb547d">更多...</a><br/></td></tr>
<tr class="separator:aba95cc151a18676235b081c5accb547d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ebf3a7dd7c2477a6b17862f2c0741f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#ae9ebf3a7dd7c2477a6b17862f2c0741f">repartition</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const unsigned int n)</td></tr>
<tr class="memdesc:ae9ebf3a7dd7c2477a6b17862f2c0741f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repartitions the <code><a class="el" href="classlibMesh_1_1MeshBase.html" title="This is the MeshBase class. ">MeshBase</a></code> into <code>n</code> parts.  <a href="#ae9ebf3a7dd7c2477a6b17862f2c0741f">更多...</a><br/></td></tr>
<tr class="separator:ae9ebf3a7dd7c2477a6b17862f2c0741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0bf09b329429cf110aca4907e880bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a4a0bf09b329429cf110aca4907e880bc">repartition</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:a4a0bf09b329429cf110aca4907e880bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repartitions the <code><a class="el" href="classlibMesh_1_1MeshBase.html" title="This is the MeshBase class. ">MeshBase</a></code> into <code>mesh.n_processors()</code> parts.  <a href="#a4a0bf09b329429cf110aca4907e880bc">更多...</a><br/></td></tr>
<tr class="separator:a4a0bf09b329429cf110aca4907e880bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbd55dc00016fd45c2575595ce23285"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#adbbd55dc00016fd45c2575595ce23285">attach_weights</a> (<a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> *)</td></tr>
<tr class="memdesc:adbbd55dc00016fd45c2575595ce23285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach weights that can be used for partitioning.  <a href="#adbbd55dc00016fd45c2575595ce23285">更多...</a><br/></td></tr>
<tr class="separator:adbbd55dc00016fd45c2575595ce23285"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:a82818472b7297f8ceea01ba24025bb58"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classlibMesh_1_1Partitioner.html">Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a82818472b7297f8ceea01ba24025bb58">build</a> (const <a class="el" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9">PartitionerType</a> solver_package)</td></tr>
<tr class="memdesc:a82818472b7297f8ceea01ba24025bb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a <code><a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a></code> of the type specified by <code>partitioner_type</code>.  <a href="#a82818472b7297f8ceea01ba24025bb58">更多...</a><br/></td></tr>
<tr class="separator:a82818472b7297f8ceea01ba24025bb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496d076cc6dd052f3e448d6965e6654c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a496d076cc6dd052f3e448d6965e6654c">partition_unpartitioned_elements</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:a496d076cc6dd052f3e448d6965e6654c"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions assign processor IDs to newly-created elements (in parallel) which are currently assigned to processor 0.  <a href="#a496d076cc6dd052f3e448d6965e6654c">更多...</a><br/></td></tr>
<tr class="separator:a496d076cc6dd052f3e448d6965e6654c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815ead0dbc002c4fe3177803c75fca49"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a815ead0dbc002c4fe3177803c75fca49">partition_unpartitioned_elements</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const unsigned int n)</td></tr>
<tr class="separator:a815ead0dbc002c4fe3177803c75fca49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335c032a3e387485a7210ec806681c1a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a335c032a3e387485a7210ec806681c1a">set_parent_processor_ids</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:a335c032a3e387485a7210ec806681c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called after partitioning to set the processor IDs for the inactive parent elements.  <a href="#a335c032a3e387485a7210ec806681c1a">更多...</a><br/></td></tr>
<tr class="separator:a335c032a3e387485a7210ec806681c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc819bc421fd8e50323b46f9762c714"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#accc819bc421fd8e50323b46f9762c714">set_node_processor_ids</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:accc819bc421fd8e50323b46f9762c714"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called after partitioning to set the processor IDs for the nodes.  <a href="#accc819bc421fd8e50323b46f9762c714">更多...</a><br/></td></tr>
<tr class="separator:accc819bc421fd8e50323b46f9762c714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427edcaf367f25545f4ca18de953ccbc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a427edcaf367f25545f4ca18de953ccbc">processor_pairs_to_interface_nodes</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, std::map&lt; std::pair&lt; <a class="el" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a>, <a class="el" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> &gt;, std::set&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt;&gt; &amp;processor_pair_to_nodes)</td></tr>
<tr class="memdesc:a427edcaf367f25545f4ca18de953ccbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">On the partitioning interface, a surface is shared by two and only two processors.  <a href="#a427edcaf367f25545f4ca18de953ccbc">更多...</a><br/></td></tr>
<tr class="separator:a427edcaf367f25545f4ca18de953ccbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4517129393c07dfd490134e68136b42"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#ae4517129393c07dfd490134e68136b42">set_interface_node_processor_ids_linear</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:ae4517129393c07dfd490134e68136b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes on the partitioning interface is linearly assigned to each pair of processors.  <a href="#ae4517129393c07dfd490134e68136b42">更多...</a><br/></td></tr>
<tr class="separator:ae4517129393c07dfd490134e68136b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7130d717b7a9e09615cf8affc729b743"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a7130d717b7a9e09615cf8affc729b743">set_interface_node_processor_ids_BFS</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:a7130d717b7a9e09615cf8affc729b743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes on the partitioning interface is clustered into two groups BFS (Breadth First Search)scheme for per pair of processors.  <a href="#a7130d717b7a9e09615cf8affc729b743">更多...</a><br/></td></tr>
<tr class="separator:a7130d717b7a9e09615cf8affc729b743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216c0efb66f5acc50dd15d9c6baf6311"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a216c0efb66f5acc50dd15d9c6baf6311">set_interface_node_processor_ids_petscpartitioner</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:a216c0efb66f5acc50dd15d9c6baf6311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes on the partitioning interface is partitioned into two groups using a PETSc partitioner for each pair of processors.  <a href="#a216c0efb66f5acc50dd15d9c6baf6311">更多...</a><br/></td></tr>
<tr class="separator:a216c0efb66f5acc50dd15d9c6baf6311"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public 属性</h2></td></tr>
<tr class="memitem:a24b119263f03f3d23380be5ab324a4ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::set<br class="typebreak"/>
&lt; <a class="el" href="namespacelibMesh.html#a634d676f703fd1cf217d85d6794abcb3">subdomain_id_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#a24b119263f03f3d23380be5ab324a4ff">chunks</a></td></tr>
<tr class="memdesc:a24b119263f03f3d23380be5ab324a4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each entry of "chunks" represents a set of subdomains which are to be partitioned together.  <a href="#a24b119263f03f3d23380be5ab324a4ff">更多...</a><br/></td></tr>
<tr class="separator:a24b119263f03f3d23380be5ab324a4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected 成员函数</h2></td></tr>
<tr class="memitem:a2a7605e15db82408f632a14db4b7b6f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#a2a7605e15db82408f632a14db4b7b6f0">_do_partition</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const unsigned int n) override</td></tr>
<tr class="memdesc:a2a7605e15db82408f632a14db4b7b6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition the <code><a class="el" href="classlibMesh_1_1MeshBase.html" title="This is the MeshBase class. ">MeshBase</a></code> into <code>n</code> subdomains.  <a href="#a2a7605e15db82408f632a14db4b7b6f0">更多...</a><br/></td></tr>
<tr class="separator:a2a7605e15db82408f632a14db4b7b6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd1901649390e0e67d507a4b546a6d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a0fd1901649390e0e67d507a4b546a6d9">single_partition</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:a0fd1901649390e0e67d507a4b546a6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivially "partitions" the mesh for one processor.  <a href="#a0fd1901649390e0e67d507a4b546a6d9">更多...</a><br/></td></tr>
<tr class="separator:a0fd1901649390e0e67d507a4b546a6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26347358c79d17b006320e702f8bff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#af26347358c79d17b006320e702f8bff4">single_partition_range</a> (<a class="el" href="structlibMesh_1_1MeshBase_1_1element__iterator.html">MeshBase::element_iterator</a> it, <a class="el" href="structlibMesh_1_1MeshBase_1_1element__iterator.html">MeshBase::element_iterator</a> end)</td></tr>
<tr class="memdesc:af26347358c79d17b006320e702f8bff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slightly generalized version of single_partition which acts on a range of elements defined by the pair of iterators (it, end).  <a href="#af26347358c79d17b006320e702f8bff4">更多...</a><br/></td></tr>
<tr class="separator:af26347358c79d17b006320e702f8bff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91df287a38324e9531b8aba0344ad184"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a91df287a38324e9531b8aba0344ad184">_do_repartition</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const unsigned int n)</td></tr>
<tr class="memdesc:a91df287a38324e9531b8aba0344ad184"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the actual re-partitioning method which can be overridden in derived classes.  <a href="#a91df287a38324e9531b8aba0344ad184">更多...</a><br/></td></tr>
<tr class="separator:a91df287a38324e9531b8aba0344ad184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae067b3d774e9d5a18f1b33371b8f1011"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#ae067b3d774e9d5a18f1b33371b8f1011">_find_global_index_by_pid_map</a> (const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:ae067b3d774e9d5a18f1b33371b8f1011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct contiguous global indices for the current partitioning.  <a href="#ae067b3d774e9d5a18f1b33371b8f1011">更多...</a><br/></td></tr>
<tr class="separator:ae067b3d774e9d5a18f1b33371b8f1011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3564b6e231686a61734c0c38b5cf3f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#aa3564b6e231686a61734c0c38b5cf3f7">build_graph</a> (const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:aa3564b6e231686a61734c0c38b5cf3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a dual graph for partitioner.  <a href="#aa3564b6e231686a61734c0c38b5cf3f7">更多...</a><br/></td></tr>
<tr class="separator:aa3564b6e231686a61734c0c38b5cf3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac4fc794ea76eb36b6f459dc43cc306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#aeac4fc794ea76eb36b6f459dc43cc306">assign_partitioning</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const std::vector&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &amp;parts)</td></tr>
<tr class="memdesc:aeac4fc794ea76eb36b6f459dc43cc306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the computed partitioning to the mesh.  <a href="#aeac4fc794ea76eb36b6f459dc43cc306">更多...</a><br/></td></tr>
<tr class="separator:aeac4fc794ea76eb36b6f459dc43cc306"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected 属性</h2></td></tr>
<tr class="memitem:abd9ee6417201fee9c219347d095b68f4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1Partitioner.html">Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#abd9ee6417201fee9c219347d095b68f4">_internal_partitioner</a></td></tr>
<tr class="memdesc:abd9ee6417201fee9c219347d095b68f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a> we use.  <a href="#abd9ee6417201fee9c219347d095b68f4">更多...</a><br/></td></tr>
<tr class="separator:abd9ee6417201fee9c219347d095b68f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1701ba592caafda75ba383d04bf1a47e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a1701ba592caafda75ba383d04bf1a47e">_weights</a></td></tr>
<tr class="memdesc:a1701ba592caafda75ba383d04bf1a47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The weights that might be used for partitioning.  <a href="#a1701ba592caafda75ba383d04bf1a47e">更多...</a><br/></td></tr>
<tr class="separator:a1701ba592caafda75ba383d04bf1a47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af7f29e6040ed94dbfed8a8688e80b7"><td class="memItemLeft" align="right" valign="top">std::unordered_map<br class="typebreak"/>
&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>, <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a></td></tr>
<tr class="memdesc:a4af7f29e6040ed94dbfed8a8688e80b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps active element ids into a contiguous range, as needed by parallel partitioner.  <a href="#a4af7f29e6040ed94dbfed8a8688e80b7">更多...</a><br/></td></tr>
<tr class="separator:a4af7f29e6040ed94dbfed8a8688e80b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232c493ab22b03ee4fb068dcd4703fc1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a232c493ab22b03ee4fb068dcd4703fc1">_n_active_elem_on_proc</a></td></tr>
<tr class="memdesc:a232c493ab22b03ee4fb068dcd4703fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of active elements on each processor.  <a href="#a232c493ab22b03ee4fb068dcd4703fc1">更多...</a><br/></td></tr>
<tr class="separator:a232c493ab22b03ee4fb068dcd4703fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6af170d354795a9bbdb89f94b72325"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#a7a6af170d354795a9bbdb89f94b72325">_dual_graph</a></td></tr>
<tr class="memdesc:a7a6af170d354795a9bbdb89f94b72325"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dual graph corresponds to the mesh, and it is typically used in paritioner.  <a href="#a7a6af170d354795a9bbdb89f94b72325">更多...</a><br/></td></tr>
<tr class="separator:a7a6af170d354795a9bbdb89f94b72325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af355eb8c855fc5442531490a04dfe7e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlibMesh_1_1Elem.html">Elem</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#af355eb8c855fc5442531490a04dfe7e4">_local_id_to_elem</a></td></tr>
<tr class="separator:af355eb8c855fc5442531490a04dfe7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
静态 Protected 属性</h2></td></tr>
<tr class="memitem:aeef033efe6d3a102444c47700d0ddab6"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Partitioner.html#aeef033efe6d3a102444c47700d0ddab6">communication_blocksize</a></td></tr>
<tr class="memdesc:aeef033efe6d3a102444c47700d0ddab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The blocksize to use when doing blocked parallel communication.  <a href="#aeef033efe6d3a102444c47700d0ddab6">更多...</a><br/></td></tr>
<tr class="separator:aeef033efe6d3a102444c47700d0ddab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>The <code><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html" title="The SubdomainPartitioner partitions the elements in &quot;chunks&quot; of user-specified subdomain ids...">SubdomainPartitioner</a></code> partitions the elements in "chunks" of user-specified subdomain ids. </p>
<p>Once all the chunks are partitioned, the overall mesh partitioning is simply the union of the chunk partitionings. For example, if the "chunks" vector is given by: chunks[0] = {1, 2, 4} chunks[1] = {3, 7, 8} chunks[2] = {5, 6} then we will call the internal <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a> three times, once for subdomains 1, 2, and 4, once for subdomains 3, 7, and 8, and once for subdomains 5 and 6.</p>
<dl class="section note"><dt>注解</dt><dd>This <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a> may produce highly non-optimal communication patterns and is likely to place geometrically disjoint sets of elements on the same processor. Its intended use is to help facilitate load balancing. That is, if the user knows that certain subdomains (or groups of subdomains) are more expensive to compute than others, he/she can ensure that they are partitioned more or less evenly among the available processors by specifying them together in a single entry of the "chunk" vector.</dd></dl>
<dl class="section author"><dt>作者</dt><dd>John W. Peterson </dd></dl>
<dl class="section date"><dt>日期</dt><dd>2017 Independently partitions chunks of subdomains and combines the results. </dd></dl>

<p>在文件 <a class="el" href="subdomain__partitioner_8h_source.html">subdomain_partitioner.h</a> 第 <a class="el" href="subdomain__partitioner_8h_source.html#l00057">57</a> 行定义.</p>
</div><h2 class="groupheader">构造及析构函数说明</h2>
<a class="anchor" id="aba5beb711ed1c65fd3dabf52e503591d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::SubdomainPartitioner::SubdomainPartitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructors. </p>
<p>The default ctor initializes the internal <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a> object to a <a class="el" href="classlibMesh_1_1MetisPartitioner.html" title="The MetisPartitioner uses the Metis graph partitioner to partition the elements. ">MetisPartitioner</a> so the class is usable, although this type can be customized later. </p>

<p>在文件 <a class="el" href="subdomain__partitioner_8C_source.html">subdomain_partitioner.C</a> 第 <a class="el" href="subdomain__partitioner_8C_source.html#l00031">31</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                            :</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  <a class="code" href="classlibMesh_1_1SubdomainPartitioner.html#abd9ee6417201fee9c219347d095b68f4">_internal_partitioner</a>(std::make_unique&lt;MetisPartitioner&gt;())</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{}</div>
<div class="ttc" id="classlibMesh_1_1SubdomainPartitioner_html_abd9ee6417201fee9c219347d095b68f4"><div class="ttname"><a href="classlibMesh_1_1SubdomainPartitioner.html#abd9ee6417201fee9c219347d095b68f4">libMesh::SubdomainPartitioner::_internal_partitioner</a></div><div class="ttdeci">std::unique_ptr&lt; Partitioner &gt; _internal_partitioner</div><div class="ttdoc">The internal Partitioner we use. </div><div class="ttdef"><b>Definition:</b> <a href="subdomain__partitioner_8h_source.html#l00122">subdomain_partitioner.h:122</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7b754ecac6755535667ea276185f9a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::SubdomainPartitioner::SubdomainPartitioner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="subdomain__partitioner_8C_source.html">subdomain_partitioner.C</a> 第 <a class="el" href="subdomain__partitioner_8C_source.html#l00036">36</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  : <a class="code" href="classlibMesh_1_1Partitioner.html#a9dc0ce0193c0702fa7e4226a94404acd">Partitioner</a>(other),</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="classlibMesh_1_1SubdomainPartitioner.html#a24b119263f03f3d23380be5ab324a4ff">chunks</a>(other.chunks),</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="classlibMesh_1_1SubdomainPartitioner.html#abd9ee6417201fee9c219347d095b68f4">_internal_partitioner</a>(other._internal_partitioner-&gt;clone())</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;{}</div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a9dc0ce0193c0702fa7e4226a94404acd"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a9dc0ce0193c0702fa7e4226a94404acd">libMesh::Partitioner::Partitioner</a></div><div class="ttdeci">Partitioner()</div><div class="ttdoc">Constructor. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00058">partitioner.h:58</a></div></div>
<div class="ttc" id="classlibMesh_1_1SubdomainPartitioner_html_a24b119263f03f3d23380be5ab324a4ff"><div class="ttname"><a href="classlibMesh_1_1SubdomainPartitioner.html#a24b119263f03f3d23380be5ab324a4ff">libMesh::SubdomainPartitioner::chunks</a></div><div class="ttdeci">std::vector&lt; std::set&lt; subdomain_id_type &gt; &gt; chunks</div><div class="ttdoc">Each entry of &amp;quot;chunks&amp;quot; represents a set of subdomains which are to be partitioned together...</div><div class="ttdef"><b>Definition:</b> <a href="subdomain__partitioner_8h_source.html#l00099">subdomain_partitioner.h:99</a></div></div>
<div class="ttc" id="classlibMesh_1_1SubdomainPartitioner_html_abd9ee6417201fee9c219347d095b68f4"><div class="ttname"><a href="classlibMesh_1_1SubdomainPartitioner.html#abd9ee6417201fee9c219347d095b68f4">libMesh::SubdomainPartitioner::_internal_partitioner</a></div><div class="ttdeci">std::unique_ptr&lt; Partitioner &gt; _internal_partitioner</div><div class="ttdoc">The internal Partitioner we use. </div><div class="ttdef"><b>Definition:</b> <a href="subdomain__partitioner_8h_source.html#l00122">subdomain_partitioner.h:122</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a637740189bf4eb5dbdec4f2899083656"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::SubdomainPartitioner::SubdomainPartitioner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move ctor, move assignment operator, and destructor are all explicitly defaulted for this class. </p>

</div>
</div>
<a class="anchor" id="a2d26252205bc7bc4f39bcf41d6907f61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual libMesh::SubdomainPartitioner::~SubdomainPartitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a class="anchor" id="a2a7605e15db82408f632a14db4b7b6f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::SubdomainPartitioner::_do_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition the <code><a class="el" href="classlibMesh_1_1MeshBase.html" title="This is the MeshBase class. ">MeshBase</a></code> into <code>n</code> subdomains. </p>

<p>实现了 <a class="el" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b">libMesh::Partitioner</a>.</p>

<p>在文件 <a class="el" href="subdomain__partitioner_8C_source.html">subdomain_partitioner.C</a> 第 <a class="el" href="subdomain__partitioner_8C_source.html#l00049">49</a> 行定义.</p>

<p>参考 <a class="el" href="subdomain__partitioner_8h_source.html#l00122">_internal_partitioner</a>, <a class="el" href="subdomain__partitioner_8h_source.html#l00099">chunks</a>, <a class="el" href="partitioner_8h_source.html#l00137">libMesh::Partitioner::partition_range()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00297">libMesh::Partitioner::single_partition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;{</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  libmesh_assert_greater (n, 0);</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  <span class="comment">// Check for an easy return.  If the user has not specified any</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <span class="comment">// entries in the chunks vector, we just do a single partitioning.</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="keywordflow">if</span> ((n == 1) || <a class="code" href="classlibMesh_1_1SubdomainPartitioner.html#a24b119263f03f3d23380be5ab324a4ff">chunks</a>.empty())</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    {</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;      this-&gt;<a class="code" href="classlibMesh_1_1Partitioner.html#a0fd1901649390e0e67d507a4b546a6d9">single_partition</a> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    }</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="comment">// Now actually do the partitioning.</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;_do_partition()&quot;</span>, <span class="stringliteral">&quot;SubdomainPartitioner&quot;</span>);</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  <span class="comment">// For each chunk, construct an iterator range for the set of</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <span class="comment">// subdomains in question, and pass it to the internal Partitioner.</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; id_set : <a class="code" href="classlibMesh_1_1SubdomainPartitioner.html#a24b119263f03f3d23380be5ab324a4ff">chunks</a>)</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <a class="code" href="classlibMesh_1_1SubdomainPartitioner.html#abd9ee6417201fee9c219347d095b68f4">_internal_partitioner</a>-&gt;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      <a class="code" href="classlibMesh_1_1Partitioner.html#aba95cc151a18676235b081c5accb547d">partition_range</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>,</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                      <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.active_subdomain_set_elements_begin(id_set),</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                      <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.active_subdomain_set_elements_end(id_set),</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                      n);</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a0fd1901649390e0e67d507a4b546a6d9"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a0fd1901649390e0e67d507a4b546a6d9">libMesh::Partitioner::single_partition</a></div><div class="ttdeci">bool single_partition(MeshBase &amp;mesh)</div><div class="ttdoc">Trivially &amp;quot;partitions&amp;quot; the mesh for one processor. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00297">partitioner.C:297</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="classlibMesh_1_1SubdomainPartitioner_html_a24b119263f03f3d23380be5ab324a4ff"><div class="ttname"><a href="classlibMesh_1_1SubdomainPartitioner.html#a24b119263f03f3d23380be5ab324a4ff">libMesh::SubdomainPartitioner::chunks</a></div><div class="ttdeci">std::vector&lt; std::set&lt; subdomain_id_type &gt; &gt; chunks</div><div class="ttdoc">Each entry of &amp;quot;chunks&amp;quot; represents a set of subdomains which are to be partitioned together...</div><div class="ttdef"><b>Definition:</b> <a href="subdomain__partitioner_8h_source.html#l00099">subdomain_partitioner.h:99</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_aba95cc151a18676235b081c5accb547d"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#aba95cc151a18676235b081c5accb547d">libMesh::Partitioner::partition_range</a></div><div class="ttdeci">virtual void partition_range(MeshBase &amp;, MeshBase::element_iterator, MeshBase::element_iterator, const unsigned int)</div><div class="ttdoc">Partitions elements in the range (it, end) into n parts. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00137">partitioner.h:137</a></div></div>
<div class="ttc" id="classlibMesh_1_1SubdomainPartitioner_html_abd9ee6417201fee9c219347d095b68f4"><div class="ttname"><a href="classlibMesh_1_1SubdomainPartitioner.html#abd9ee6417201fee9c219347d095b68f4">libMesh::SubdomainPartitioner::_internal_partitioner</a></div><div class="ttdeci">std::unique_ptr&lt; Partitioner &gt; _internal_partitioner</div><div class="ttdoc">The internal Partitioner we use. </div><div class="ttdef"><b>Definition:</b> <a href="subdomain__partitioner_8h_source.html#l00122">subdomain_partitioner.h:122</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a91df287a38324e9531b8aba0344ad184"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::Partitioner::_do_repartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the actual re-partitioning method which can be overridden in derived classes. </p>
<dl class="section note"><dt>注解</dt><dd>The default behavior is to simply call the partition function. </dd></dl>

<p>被 <a class="el" href="classlibMesh_1_1ParmetisPartitioner.html#afae178cbfff393b15fbd188c8acda95b">libMesh::ParmetisPartitioner</a> 重载.</p>

<p>在文件 <a class="el" href="partitioner_8h_source.html">partitioner.h</a> 第 <a class="el" href="partitioner_8h_source.html#l00251">251</a> 行定义.</p>

<p>参考 <a class="el" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b">libMesh::Partitioner::_do_partition()</a>.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l00262">libMesh::Partitioner::repartition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                                                      { this-&gt;<a class="code" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b">_do_partition</a> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, n); }</div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a95ae8657d4679a5f309069bc1aacb12b"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b">libMesh::Partitioner::_do_partition</a></div><div class="ttdeci">virtual void _do_partition(MeshBase &amp;mesh, const unsigned int n)=0</div><div class="ttdoc">This is the actual partitioning method which must be overridden in derived classes. </div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae067b3d774e9d5a18f1b33371b8f1011"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::_find_global_index_by_pid_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct contiguous global indices for the current partitioning. </p>
<p>The global indices are ordered part-by-part </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l01067">1067</a> 行定义.</p>

<p>参考 <a class="el" href="partitioner_8h_source.html#l00286">libMesh::Partitioner::_global_index_by_pid_map</a>, <a class="el" href="partitioner_8h_source.html#l00295">libMesh::Partitioner::_n_active_elem_on_proc</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l00558">libMesh::MeshTools::create_bounding_box()</a>, <a class="el" href="mesh__communication__global__indices_8C_source.html#l00710">libMesh::MeshCommunication::find_local_indices()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a>, <a class="el" href="mesh__base_8h_source.html#l00540">libMesh::MeshBase::n_active_local_elem()</a>, <a class="el" href="parallel__object_8h_source.html#l00103">libMesh::ParallelObject::n_processors()</a> , 以及 <a class="el" href="parallel__ghost__sync_8h_source.html#l00357">libMesh::Parallel::sync_dofobject_data_by_id()</a>.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l01111">libMesh::Partitioner::build_graph()</a>.</p>
<div class="fragment"><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;{</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> n_active_local_elem = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a82616af7498c609e19090b9437533ab2">n_active_local_elem</a>();</div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;</div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;  <span class="comment">// Find the number of active elements on each processor.  We cannot use</span></div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;  <span class="comment">// mesh.n_active_elem_on_proc(pid) since that only returns the number of</span></div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;  <span class="comment">// elements assigned to pid which are currently stored on the calling</span></div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;  <span class="comment">// processor. This will not in general be correct for parallel meshes</span></div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;  <span class="comment">// when (pid!=mesh.processor_id()).</span></div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;  <span class="keyword">auto</span> n_proc = mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">n_processors</a>();</div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a232c493ab22b03ee4fb068dcd4703fc1">_n_active_elem_on_proc</a>.resize(n_proc);</div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;  mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>().allgather(n_active_local_elem, <a class="code" href="classlibMesh_1_1Partitioner.html#a232c493ab22b03ee4fb068dcd4703fc1">_n_active_elem_on_proc</a>);</div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;</div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;  std::vector&lt;dof_id_type&gt; n_active_elem_before_proc(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">n_processors</a>());</div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;</div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(n_proc-1))</div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;    n_active_elem_before_proc[i+1] =</div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;      n_active_elem_before_proc[i] + <a class="code" href="classlibMesh_1_1Partitioner.html#a232c493ab22b03ee4fb068dcd4703fc1">_n_active_elem_on_proc</a>[i];</div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;</div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;  <a class="code" href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a> bbox =</div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;    <a class="code" href="namespacelibMesh_1_1MeshTools.html#a2793e67a6d7e4c5e59692a4acfbcd425">MeshTools::create_bounding_box</a>(mesh);</div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>.clear();</div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;</div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;  <span class="comment">// create the mapping which is contiguous by processor</span></div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;  <a class="code" href="classlibMesh_1_1MeshCommunication.html">MeshCommunication</a>().<a class="code" href="classlibMesh_1_1MeshCommunication.html#afb1899390ba017ecd73db2856a3b68e5">find_local_indices</a> (bbox,</div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;                                          mesh.active_local_elements_begin(),</div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;                                          mesh.active_local_elements_end(),</div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;                                          <a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>);</div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;</div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;  <a class="code" href="structlibMesh_1_1SyncLocalIDs.html">SyncLocalIDs</a> sync(<a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>);</div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;</div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">Parallel::sync_dofobject_data_by_id</a></div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;      (mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>(), mesh.active_elements_begin(), mesh.active_elements_end(), sync);</div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;</div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : mesh.active_element_ptr_range())</div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;    {</div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> pid = elem-&gt;processor_id();</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;      libmesh_assert_less (<a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>[elem-&gt;id()], <a class="code" href="classlibMesh_1_1Partitioner.html#a232c493ab22b03ee4fb068dcd4703fc1">_n_active_elem_on_proc</a>[pid]);</div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;</div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;      <a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>[elem-&gt;id()] += n_active_elem_before_proc[pid];</div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;    }</div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a4af7f29e6040ed94dbfed8a8688e80b7"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">libMesh::Partitioner::_global_index_by_pid_map</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, dof_id_type &gt; _global_index_by_pid_map</div><div class="ttdoc">Maps active element ids into a contiguous range, as needed by parallel partitioner. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00286">partitioner.h:286</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a2793e67a6d7e4c5e59692a4acfbcd425"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a2793e67a6d7e4c5e59692a4acfbcd425">libMesh::MeshTools::create_bounding_box</a></div><div class="ttdeci">libMesh::BoundingBox create_bounding_box(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00558">mesh_tools.C:558</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a50719f74165b613ab929afd29b6d5f4a"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">libMesh::ParallelObject::n_processors</a></div><div class="ttdeci">processor_id_type n_processors() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00103">parallel_object.h:103</a></div></div>
<div class="ttc" id="structlibMesh_1_1SyncLocalIDs_html"><div class="ttname"><a href="structlibMesh_1_1SyncLocalIDs.html">libMesh::SyncLocalIDs</a></div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l01040">partitioner.C:1040</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af18245d4f872c36a41fc74086bda3e80"><div class="ttname"><a href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00104">id_types.h:104</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html">libMesh::MeshCommunication</a></div><div class="ttdoc">This is the MeshCommunication class. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8h_source.html#l00050">mesh_communication.h:50</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_ac7d4f06bb34625465942e6b8d10f135e"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">libMesh::Parallel::sync_dofobject_data_by_id</a></div><div class="ttdeci">void sync_dofobject_data_by_id(const Communicator &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</div><div class="ttdoc">Request data about a range of ghost dofobjects uniquely identified by their id. </div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00357">parallel_ghost_sync.h:357</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a82616af7498c609e19090b9437533ab2"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a82616af7498c609e19090b9437533ab2">libMesh::MeshBase::n_active_local_elem</a></div><div class="ttdeci">dof_id_type n_active_local_elem() const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00540">mesh_base.h:540</a></div></div>
<div class="ttc" id="classlibMesh_1_1BoundingBox_html"><div class="ttname"><a href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a></div><div class="ttdoc">Defines a Cartesian bounding box by the two corner extremum. </div><div class="ttdef"><b>Definition:</b> <a href="bounding__box_8h_source.html#l00040">bounding_box.h:40</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_afb1899390ba017ecd73db2856a3b68e5"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#afb1899390ba017ecd73db2856a3b68e5">libMesh::MeshCommunication::find_local_indices</a></div><div class="ttdeci">void find_local_indices(const libMesh::BoundingBox &amp;, const ForwardIterator &amp;, const ForwardIterator &amp;, std::unordered_map&lt; dof_id_type, dof_id_type &gt; &amp;) const </div><div class="ttdoc">This method determines a locally unique, contiguous index for each object in the input range...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication__global__indices_8C_source.html#l00710">mesh_communication_global_indices.C:710</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a232c493ab22b03ee4fb068dcd4703fc1"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a232c493ab22b03ee4fb068dcd4703fc1">libMesh::Partitioner::_n_active_elem_on_proc</a></div><div class="ttdeci">std::vector&lt; dof_id_type &gt; _n_active_elem_on_proc</div><div class="ttdoc">The number of active elements on each processor. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00295">partitioner.h:295</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeac4fc794ea76eb36b6f459dc43cc306"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::assign_partitioning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the computed partitioning to the mesh. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l01334">1334</a> 行定义.</p>

<p>参考 <a class="el" href="partitioner_8h_source.html#l00286">libMesh::Partitioner::_global_index_by_pid_map</a>, <a class="el" href="partitioner_8h_source.html#l00295">libMesh::Partitioner::_n_active_elem_on_proc</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a>, <a class="el" href="mesh__communication_8C_source.html#l01308">mesh</a>, <a class="el" href="mesh__base_8h_source.html#l00540">libMesh::MeshBase::n_active_local_elem()</a> , 以及 <a class="el" href="parallel__object_8h_source.html#l00114">libMesh::ParallelObject::processor_id()</a>.</p>
<div class="fragment"><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;{</div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;  LOG_SCOPE(<span class="stringliteral">&quot;assign_partitioning()&quot;</span>, <span class="stringliteral">&quot;Partitioner&quot;</span>);</div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;</div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;</div>
<div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;  <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> first_local_elem = 0;</div>
<div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> pid : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">processor_id</a>()))</div>
<div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;    first_local_elem += <a class="code" href="classlibMesh_1_1Partitioner.html#a232c493ab22b03ee4fb068dcd4703fc1">_n_active_elem_on_proc</a>[pid];</div>
<div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;</div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;<span class="preprocessor"></span>  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> n_active_local_elem = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a82616af7498c609e19090b9437533ab2">n_active_local_elem</a>();</div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;  std::map&lt;processor_id_type, std::vector&lt;dof_id_type&gt;&gt;</div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;    requested_ids;</div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;</div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;  <span class="comment">// Results to gather from each processor - kept in a map so we</span></div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;  <span class="comment">// do only one loop over elements after all receives are done.</span></div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;  std::map&lt;processor_id_type, std::vector&lt;processor_id_type&gt;&gt;</div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;    filled_request;</div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;</div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : mesh.active_element_ptr_range())</div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;    {</div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;      <span class="comment">// we need to get the index from the owning processor</span></div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;      <span class="comment">// (note we cannot assign it now -- we are iterating</span></div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;      <span class="comment">// over elements again and this will be bad!)</span></div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;      requested_ids[elem-&gt;processor_id()].push_back(elem-&gt;id());</div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;    }</div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;</div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;  <span class="keyword">auto</span> gather_functor =</div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;    [<span class="keyword">this</span>,</div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;     &amp; parts,</div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;<span class="preprocessor"></span>     &amp; <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>,</div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;     n_active_local_elem,</div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;<span class="preprocessor"></span>     first_local_elem]</div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;    (<a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a>, <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; ids,</div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;     std::vector&lt;processor_id_type&gt; &amp; data)</div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;    {</div>
<div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;      <span class="keyword">const</span> std::size_t ids_size = ids.size();</div>
<div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;      data.resize(ids.size());</div>
<div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;</div>
<div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;      <span class="keywordflow">for</span> (std::size_t i=0; i != ids_size; i++)</div>
<div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;        {</div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> requested_elem_index = ids[i];</div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;</div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;          <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(<a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>.count(requested_elem_index));</div>
<div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;</div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> global_index_by_pid =</div>
<div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;            <a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>[requested_elem_index];</div>
<div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;</div>
<div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> local_index =</div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;            global_index_by_pid - first_local_elem;</div>
<div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;</div>
<div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;          libmesh_assert_less (local_index, parts.size());</div>
<div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;          libmesh_assert_less (local_index, n_active_local_elem);</div>
<div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;</div>
<div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;          <span class="keyword">const</span> processor_id_type elem_procid =</div>
<div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;            cast_int&lt;processor_id_type&gt;(parts[local_index]);</div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;</div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;          libmesh_assert_less (elem_procid, mesh.n_partitions());</div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;</div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;          data[i] = elem_procid;</div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;        }</div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;    };</div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;</div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;  <span class="keyword">auto</span> action_functor =</div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;    [&amp;filled_request]</div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;    (processor_id_type pid,</div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;     <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp;,</div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;     <span class="keyword">const</span> std::vector&lt;processor_id_type&gt; &amp; new_procids)</div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;    {</div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;      filled_request[pid] = new_procids;</div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;    };</div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;</div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;  <span class="comment">// Trade requests with other processors</span></div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;  <span class="keyword">const</span> processor_id_type * ex = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;  Parallel::pull_parallel_vector_data</div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;    (mesh.comm(), requested_ids, gather_functor, action_functor, ex);</div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;</div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;  <span class="comment">// and finally assign the partitioning.</span></div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;  <span class="comment">// note we are iterating in exactly the same order</span></div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;  <span class="comment">// used to build up the request, so we can expect the</span></div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;  <span class="comment">// required entries to be in the proper sequence.</span></div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;  std::vector&lt;unsigned int&gt; counters(mesh.n_processors(), 0);</div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : mesh.active_element_ptr_range())</div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;    {</div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;      <span class="keyword">const</span> processor_id_type current_pid = elem-&gt;processor_id();</div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;</div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;      libmesh_assert_less (counters[current_pid], requested_ids[current_pid].size());</div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;</div>
<div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;      <span class="keyword">const</span> processor_id_type elem_procid =</div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;        filled_request[current_pid][counters[current_pid]++];</div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;</div>
<div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;      libmesh_assert_less (elem_procid, mesh.n_partitions());</div>
<div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;      elem-&gt;processor_id() = elem_procid;</div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;    }</div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a4af7f29e6040ed94dbfed8a8688e80b7"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">libMesh::Partitioner::_global_index_by_pid_map</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, dof_id_type &gt; _global_index_by_pid_map</div><div class="ttdoc">Maps active element ids into a contiguous range, as needed by parallel partitioner. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00286">partitioner.h:286</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af18245d4f872c36a41fc74086bda3e80"><div class="ttname"><a href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00104">id_types.h:104</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a82616af7498c609e19090b9437533ab2"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a82616af7498c609e19090b9437533ab2">libMesh::MeshBase::n_active_local_elem</a></div><div class="ttdeci">dof_id_type n_active_local_elem() const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00540">mesh_base.h:540</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a232c493ab22b03ee4fb068dcd4703fc1"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a232c493ab22b03ee4fb068dcd4703fc1">libMesh::Partitioner::_n_active_elem_on_proc</a></div><div class="ttdeci">std::vector&lt; dof_id_type &gt; _n_active_elem_on_proc</div><div class="ttdoc">The number of active elements on each processor. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00295">partitioner.h:295</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_ae1e7d1a1118f63d9889a761c27433bbc"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">libMesh::ParallelObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00114">parallel_object.h:114</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adbbd55dc00016fd45c2575595ce23285"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::Partitioner::attach_weights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach weights that can be used for partitioning. </p>
<p>This <a class="el" href="classlibMesh_1_1ErrorVector.html" title="The ErrorVector is a specialization of the StatisticsVector for error data computed on a finite eleme...">ErrorVector</a> should be <em>exactly</em> the same on every processor and should have mesh-&gt;max_elem_id() entries. </p>

<p>被 <a class="el" href="classlibMesh_1_1MetisPartitioner.html#a2cd4a7964679744ac2605f86f93c74fa">libMesh::MetisPartitioner</a> 重载.</p>

<p>在文件 <a class="el" href="partitioner_8h_source.html">partitioner.h</a> 第 <a class="el" href="partitioner_8h_source.html#l00213">213</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;{ libmesh_not_implemented(); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a82818472b7297f8ceea01ba24025bb58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1Partitioner.html">Partitioner</a> &gt; libMesh::Partitioner::build </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9">PartitionerType</a>&#160;</td>
          <td class="paramname"><em>solver_package</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a <code><a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a></code> of the type specified by <code>partitioner_type</code>. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00158">158</a> 行定义.</p>

<p>参考 <a class="el" href="enum__partitioner__type_8h_source.html#l00034">libMesh::CENTROID_PARTITIONER</a>, <a class="el" href="namespacelibMesh_1_1Utility.html#aa99a42a5efab878469e7f58e5c033335">libMesh::Utility::enum_to_string()</a>, <a class="el" href="enum__partitioner__type_8h_source.html#l00037">libMesh::HILBERT_SFC_PARTITIONER</a>, <a class="el" href="enum__partitioner__type_8h_source.html#l00035">libMesh::LINEAR_PARTITIONER</a>, <a class="el" href="enum__partitioner__type_8h_source.html#l00042">libMesh::MAPPED_SUBDOMAIN_PARTITIONER</a>, <a class="el" href="enum__partitioner__type_8h_source.html#l00039">libMesh::METIS_PARTITIONER</a>, <a class="el" href="enum__partitioner__type_8h_source.html#l00038">libMesh::MORTON_SFC_PARTITIONER</a>, <a class="el" href="enum__partitioner__type_8h_source.html#l00040">libMesh::PARMETIS_PARTITIONER</a>, <a class="el" href="enum__partitioner__type_8h_source.html#l00036">libMesh::SFC_PARTITIONER</a> , 以及 <a class="el" href="enum__partitioner__type_8h_source.html#l00041">libMesh::SUBDOMAIN_PARTITIONER</a>.</p>

<p>参考自 <a class="el" href="replicated__mesh_8C_source.html#l00040">libMesh::ReplicatedMesh::ReplicatedMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;{</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  <span class="keywordflow">switch</span> (partitioner_type)</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  {</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9a62a65bd782f9ad6327b3aa762eb19088">CENTROID_PARTITIONER</a>:</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;      <span class="keywordflow">return</span> std::make_unique&lt;CentroidPartitioner&gt;();</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9a2e2c241af689e40ee9545a34c149fea9">LINEAR_PARTITIONER</a>:</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;      <span class="keywordflow">return</span> std::make_unique&lt;LinearPartitioner&gt;();</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9a3f9448b9f3c3786a98b1c8a84e26dec0">MAPPED_SUBDOMAIN_PARTITIONER</a>:</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;      <span class="keywordflow">return</span> std::make_unique&lt;MappedSubdomainPartitioner&gt;();</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9aaf52f0d63e10859bfe1cd67c39329f15">METIS_PARTITIONER</a>:</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;      <span class="keywordflow">return</span> std::make_unique&lt;MetisPartitioner&gt;();</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9af07c1c088cf9f04ddbd8afa0003ec535">PARMETIS_PARTITIONER</a>:</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;      <span class="keywordflow">return</span> std::make_unique&lt;ParmetisPartitioner&gt;();</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9ad7399e02d62dd412d03d4e1d692cf974">HILBERT_SFC_PARTITIONER</a>:</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;      <span class="keywordflow">return</span> std::make_unique&lt;HilbertSFCPartitioner&gt;();</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9aa5f4ff5cc252058a293790864bbcc9b8">MORTON_SFC_PARTITIONER</a>:</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;      <span class="keywordflow">return</span> std::make_unique&lt;MortonSFCPartitioner&gt;();</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9aa53176dc4550fff08bbc932b6a4b31a8">SFC_PARTITIONER</a>:</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;      <span class="keywordflow">return</span> std::make_unique&lt;SFCPartitioner&gt;();</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9a5e20e43cab58b6f9800f24c31167f3d3">SUBDOMAIN_PARTITIONER</a>:</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;      <span class="keywordflow">return</span> std::make_unique&lt;SubdomainPartitioner&gt;();</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;      libmesh_error_msg(<span class="stringliteral">&quot;Invalid partitioner type: &quot;</span> &lt;&lt;</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                        <a class="code" href="namespacelibMesh_1_1Utility.html#aa99a42a5efab878469e7f58e5c033335">Utility::enum_to_string</a>(partitioner_type));</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  }</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_html_a26aa013c1fc1e7715b23527abdd1b8b9aa53176dc4550fff08bbc932b6a4b31a8"><div class="ttname"><a href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9aa53176dc4550fff08bbc932b6a4b31a8">libMesh::SFC_PARTITIONER</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__partitioner__type_8h_source.html#l00036">enum_partitioner_type.h:36</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26aa013c1fc1e7715b23527abdd1b8b9a5e20e43cab58b6f9800f24c31167f3d3"><div class="ttname"><a href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9a5e20e43cab58b6f9800f24c31167f3d3">libMesh::SUBDOMAIN_PARTITIONER</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__partitioner__type_8h_source.html#l00041">enum_partitioner_type.h:41</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26aa013c1fc1e7715b23527abdd1b8b9a62a65bd782f9ad6327b3aa762eb19088"><div class="ttname"><a href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9a62a65bd782f9ad6327b3aa762eb19088">libMesh::CENTROID_PARTITIONER</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__partitioner__type_8h_source.html#l00034">enum_partitioner_type.h:34</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26aa013c1fc1e7715b23527abdd1b8b9aa5f4ff5cc252058a293790864bbcc9b8"><div class="ttname"><a href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9aa5f4ff5cc252058a293790864bbcc9b8">libMesh::MORTON_SFC_PARTITIONER</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__partitioner__type_8h_source.html#l00038">enum_partitioner_type.h:38</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Utility_html_aa99a42a5efab878469e7f58e5c033335"><div class="ttname"><a href="namespacelibMesh_1_1Utility.html#aa99a42a5efab878469e7f58e5c033335">libMesh::Utility::enum_to_string</a></div><div class="ttdeci">std::string enum_to_string(const T e)</div></div>
<div class="ttc" id="namespacelibMesh_html_a26aa013c1fc1e7715b23527abdd1b8b9a2e2c241af689e40ee9545a34c149fea9"><div class="ttname"><a href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9a2e2c241af689e40ee9545a34c149fea9">libMesh::LINEAR_PARTITIONER</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__partitioner__type_8h_source.html#l00035">enum_partitioner_type.h:35</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26aa013c1fc1e7715b23527abdd1b8b9aaf52f0d63e10859bfe1cd67c39329f15"><div class="ttname"><a href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9aaf52f0d63e10859bfe1cd67c39329f15">libMesh::METIS_PARTITIONER</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__partitioner__type_8h_source.html#l00039">enum_partitioner_type.h:39</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26aa013c1fc1e7715b23527abdd1b8b9ad7399e02d62dd412d03d4e1d692cf974"><div class="ttname"><a href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9ad7399e02d62dd412d03d4e1d692cf974">libMesh::HILBERT_SFC_PARTITIONER</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__partitioner__type_8h_source.html#l00037">enum_partitioner_type.h:37</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26aa013c1fc1e7715b23527abdd1b8b9af07c1c088cf9f04ddbd8afa0003ec535"><div class="ttname"><a href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9af07c1c088cf9f04ddbd8afa0003ec535">libMesh::PARMETIS_PARTITIONER</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__partitioner__type_8h_source.html#l00040">enum_partitioner_type.h:40</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26aa013c1fc1e7715b23527abdd1b8b9a3f9448b9f3c3786a98b1c8a84e26dec0"><div class="ttname"><a href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9a3f9448b9f3c3786a98b1c8a84e26dec0">libMesh::MAPPED_SUBDOMAIN_PARTITIONER</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__partitioner__type_8h_source.html#l00042">enum_partitioner_type.h:42</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa3564b6e231686a61734c0c38b5cf3f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::build_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a dual graph for partitioner. </p>

<p>被 <a class="el" href="classlibMesh_1_1ParmetisPartitioner.html#aaf3b8b7159c78bc6a1c3317241f421ee">libMesh::ParmetisPartitioner</a> 重载.</p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l01111">1111</a> 行定义.</p>

<p>参考 <a class="el" href="partitioner_8h_source.html#l00302">libMesh::Partitioner::_dual_graph</a>, <a class="el" href="partitioner_8C_source.html#l01067">libMesh::Partitioner::_find_global_index_by_pid_map()</a>, <a class="el" href="partitioner_8h_source.html#l00286">libMesh::Partitioner::_global_index_by_pid_map</a>, <a class="el" href="partitioner_8h_source.html#l00305">libMesh::Partitioner::_local_id_to_elem</a>, <a class="el" href="partitioner_8h_source.html#l00295">libMesh::Partitioner::_n_active_elem_on_proc</a>, <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a>, <a class="el" href="mesh__base_8h_source.html#l01673">libMesh::MeshBase::get_constraint_rows()</a>, <a class="el" href="dof__object_8h_source.html#l00823">libMesh::DofObject::id()</a>, <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>, <a class="el" href="libmesh__common_8h_source.html#l00516">libMesh::libmesh_ignore()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a>, <a class="el" href="mesh__base_8h_source.html#l00540">libMesh::MeshBase::n_active_local_elem()</a> , 以及 <a class="el" href="parallel__object_8h_source.html#l00114">libMesh::ParallelObject::processor_id()</a>.</p>
<div class="fragment"><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;{</div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;  LOG_SCOPE(<span class="stringliteral">&quot;build_graph()&quot;</span>, <span class="stringliteral">&quot;Partitioner&quot;</span>);</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;</div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> n_active_local_elem  = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a82616af7498c609e19090b9437533ab2">n_active_local_elem</a>();</div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;</div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;  <span class="comment">// If we have boundary elements in this mesh, we want to account for</span></div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;  <span class="comment">// the connectivity between them and interior elements.  We can find</span></div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;  <span class="comment">// interior elements from boundary elements, but we need to build up</span></div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;  <span class="comment">// a lookup map to do the reverse.</span></div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;  <span class="keyword">typedef</span> std::unordered_multimap&lt;const Elem *, const Elem *&gt; map_type;</div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;  map_type interior_to_boundary_map;</div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;</div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;  <span class="comment">// If we have spline nodes in this mesh, we want to account for the</span></div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;  <span class="comment">// connectivity between them and integration elements.  We can find</span></div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;  <span class="comment">// spline nodes from integration elements, but need a reverse map</span></div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;  <span class="comment">// {integration_elements} = elems_constrained_by[spline_nodeelem]</span></div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;  map_type elems_constrained_by;</div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;</div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; mesh_constrained_nodes = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a988e7456320f55e731dc8e4bb9373ea3">get_constraint_rows</a>();</div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;</div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Elem.html">Elem</a> * elem : mesh.active_element_ptr_range())</div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;    {</div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;      <span class="keywordflow">if</span> (!mesh_constrained_nodes.empty()) <span class="comment">// quick test for non-IGA cases</span></div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;        {</div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> end_it = mesh_constrained_nodes.end();</div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;          <span class="comment">// Use a set to avoid duplicates</span></div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;          std::set&lt;const Elem *&gt; constraining_elems;</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Node.html">Node</a> &amp; node : elem-&gt;node_ref_range())</div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;            {</div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;              <span class="keyword">auto</span> row_it = mesh_constrained_nodes.find(&amp;node);</div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;              <span class="keywordflow">if</span> (row_it != end_it)</div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> [pr, coef] : row_it-&gt;second)</div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;                  {</div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;                    <a class="code" href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libmesh_ignore</a>(coef); <span class="comment">// avoid gcc 7 warning</span></div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;                    constraining_elems.insert(pr.first);</div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;                  }</div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;            }</div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Elem.html">Elem</a> * constraining_elem : constraining_elems)</div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;            elems_constrained_by.emplace(constraining_elem, elem);</div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;        }</div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;</div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;      <span class="comment">// If we don&#39;t have an interior_parent and we don&#39;t have any</span></div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;      <span class="comment">// constrained nodes then there&#39;s nothing else to look up.</span></div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;      <span class="keywordflow">if</span> (elem-&gt;interior_parent())</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;        {</div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;          <span class="comment">// get all relevant interior elements</span></div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;          std::set&lt;const Elem *&gt; neighbor_set;</div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;          elem-&gt;find_interior_neighbors(neighbor_set);</div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;</div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor : neighbor_set)</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;            interior_to_boundary_map.emplace(neighbor, elem);</div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;        }</div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;    }</div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;</div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_AMR</span></div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;<span class="preprocessor"></span>  std::vector&lt;const Elem *&gt; neighbors_offspring;</div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;  <span class="comment">// This is costly, and we only need to do it if the mesh has</span></div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;  <span class="comment">// changed since we last partitioned... but the mesh probably has</span></div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;  <span class="comment">// changed since we last partitioned, and if it hasn&#39;t we don&#39;t</span></div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;  <span class="comment">// have a reliable way to be sure of that.</span></div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#ae067b3d774e9d5a18f1b33371b8f1011">_find_global_index_by_pid_map</a>(mesh);</div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;</div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;  <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> first_local_elem = 0;</div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> pid : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">processor_id</a>()))</div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;     first_local_elem += <a class="code" href="classlibMesh_1_1Partitioner.html#a232c493ab22b03ee4fb068dcd4703fc1">_n_active_elem_on_proc</a>[pid];</div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;</div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a7a6af170d354795a9bbdb89f94b72325">_dual_graph</a>.clear();</div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a7a6af170d354795a9bbdb89f94b72325">_dual_graph</a>.resize(n_active_local_elem);</div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#af355eb8c855fc5442531490a04dfe7e4">_local_id_to_elem</a>.resize(n_active_local_elem);</div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;</div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : mesh.active_local_element_ptr_range())</div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;    {</div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;      <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (<a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>.count(elem-&gt;id()));</div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> global_index_by_pid =</div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;        <a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>[elem-&gt;id()];</div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;</div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> local_index =</div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;        global_index_by_pid - first_local_elem;</div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;      libmesh_assert_less (local_index, n_active_local_elem);</div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;</div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;      std::vector&lt;dof_id_type&gt; &amp; graph_row = <a class="code" href="classlibMesh_1_1Partitioner.html#a7a6af170d354795a9bbdb89f94b72325">_dual_graph</a>[local_index];</div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;</div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;      <span class="comment">// Save this off to make it easy to index later</span></div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;      <a class="code" href="classlibMesh_1_1Partitioner.html#af355eb8c855fc5442531490a04dfe7e4">_local_id_to_elem</a>[local_index] = <span class="keyword">const_cast&lt;</span><a class="code" href="classlibMesh_1_1Elem.html">Elem</a>*<span class="keyword">&gt;</span>(elem);</div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;</div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;      <span class="comment">// Loop over the element&#39;s neighbors.  An element</span></div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;      <span class="comment">// adjacency corresponds to a face neighbor</span></div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> neighbor : elem-&gt;neighbor_ptr_range())</div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;        {</div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;          <span class="keywordflow">if</span> (neighbor != <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;            {</div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;              <span class="comment">// If the neighbor is active treat it</span></div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;              <span class="comment">// as a connection</span></div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;              <span class="keywordflow">if</span> (neighbor-&gt;active())</div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;                {</div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;                  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(<a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>.count(neighbor-&gt;id()));</div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;                  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> neighbor_global_index_by_pid =</div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;                    <a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>[neighbor-&gt;id()];</div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;</div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;                  graph_row.push_back(neighbor_global_index_by_pid);</div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;                }</div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;</div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_AMR</span></div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;              <span class="comment">// Otherwise we need to find all of the</span></div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;              <span class="comment">// neighbor&#39;s children that are connected to</span></div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;              <span class="comment">// us and add them</span></div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;              <span class="keywordflow">else</span></div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;                {</div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;                  <span class="comment">// The side of the neighbor to which</span></div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;                  <span class="comment">// we are connected</span></div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ns =</div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;                    neighbor-&gt;which_neighbor_am_i (elem);</div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;                  libmesh_assert_less (ns, neighbor-&gt;n_neighbors());</div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;</div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;                  <span class="comment">// Get all the active children (&amp; grandchildren, etc...)</span></div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;                  <span class="comment">// of the neighbor</span></div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;</div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;                  <span class="comment">// FIXME - this is the wrong thing, since we</span></div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;                  <span class="comment">// should be getting the active family tree on</span></div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;                  <span class="comment">// our side only.  But adding too many graph</span></div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;                  <span class="comment">// links may cause hanging nodes to tend to be</span></div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;                  <span class="comment">// on partition interiors, which would reduce</span></div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;                  <span class="comment">// communication overhead for constraint</span></div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;                  <span class="comment">// equations, so we&#39;ll leave it.</span></div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;</div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;                  neighbor-&gt;active_family_tree (neighbors_offspring);</div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;</div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;                  <span class="comment">// Get all the neighbor&#39;s children that</span></div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;                  <span class="comment">// live on that side and are thus connected</span></div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;                  <span class="comment">// to us</span></div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; child : neighbors_offspring)</div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;                    {</div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;                      <span class="comment">// This does not assume a level-1 mesh.</span></div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;                      <span class="comment">// Note that since children have sides numbered</span></div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;                      <span class="comment">// coincident with the parent then this is a sufficient test.</span></div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;                      <span class="keywordflow">if</span> (child-&gt;neighbor_ptr(ns) == elem)</div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;                        {</div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;                          <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (child-&gt;active());</div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;                          <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (<a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>.count(child-&gt;id()));</div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;                          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> child_global_index_by_pid =</div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;                            <a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>[child-&gt;id()];</div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;</div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;                          graph_row.push_back(child_global_index_by_pid);</div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;                        }</div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;                    }</div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;                }</div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;</div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;<span class="preprocessor">#endif </span><span class="comment">/* ifdef LIBMESH_ENABLE_AMR */</span><span class="preprocessor"></span></div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;</div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;            }</div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;        }</div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;</div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;      <span class="keywordflow">if</span> ((elem-&gt;dim() &lt; LIBMESH_DIM) &amp;&amp;</div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;          elem-&gt;interior_parent())</div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;        {</div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;          <span class="comment">// get all relevant interior elements</span></div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;          std::set&lt;const Elem *&gt; neighbor_set;</div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;          elem-&gt;find_interior_neighbors(neighbor_set);</div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;</div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor : neighbor_set)</div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;            {</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> neighbor_global_index_by_pid =</div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;                <a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>[neighbor-&gt;id()];</div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;</div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;              graph_row.push_back(neighbor_global_index_by_pid);</div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;            }</div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;        }</div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;      <span class="comment">// Check for any boundary neighbors</span></div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(interior_to_boundary_map.equal_range(elem)))</div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;        {</div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;          <span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Elem.html">Elem</a> * neighbor = pr.second;</div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;</div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> neighbor_global_index_by_pid =</div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;            <a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>[neighbor-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#aeceebf9cd5d53b02df3cd1e9907139e2">id</a>()];</div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;</div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;          graph_row.push_back(neighbor_global_index_by_pid);</div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;        }</div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;</div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;      <span class="comment">// Check for any constraining elements</span></div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;      <span class="keywordflow">if</span> (!mesh_constrained_nodes.empty()) <span class="comment">// quick test for non-IGA cases</span></div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;        {</div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> end_it = mesh_constrained_nodes.end();</div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;          <span class="comment">// Use a set to avoid duplicates</span></div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;          std::set&lt;const Elem *&gt; constraining_elems;</div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Node.html">Node</a> &amp; node : elem-&gt;node_ref_range())</div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;            {</div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;              <span class="keyword">auto</span> row_it = mesh_constrained_nodes.find(&amp;node);</div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;              <span class="keywordflow">if</span> (row_it != end_it)</div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> [pr, coef] : row_it-&gt;second)</div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;                  {</div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;                    <a class="code" href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libmesh_ignore</a>(coef); <span class="comment">// avoid gcc 7 warning</span></div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;                    constraining_elems.insert(pr.first);</div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;                  }</div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;            }</div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Elem.html">Elem</a> * constraining_elem : constraining_elems)</div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;            {</div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> constraining_global_index_by_pid =</div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;                <a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>[constraining_elem-&gt;id()];</div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;</div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;              graph_row.push_back(constraining_global_index_by_pid);</div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;            }</div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;        }</div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;</div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;      <span class="comment">// Check for any constrained elements</span></div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(elems_constrained_by.equal_range(elem)))</div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;        {</div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;          <span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Elem.html">Elem</a> * constrained = pr.second;</div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> constrained_global_index_by_pid =</div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;            <a class="code" href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">_global_index_by_pid_map</a>[constrained-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#aeceebf9cd5d53b02df3cd1e9907139e2">id</a>()];</div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;</div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;          graph_row.push_back(constrained_global_index_by_pid);</div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;        }</div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;    }</div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a988e7456320f55e731dc8e4bb9373ea3"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a988e7456320f55e731dc8e4bb9373ea3">libMesh::MeshBase::get_constraint_rows</a></div><div class="ttdeci">constraint_rows_type &amp; get_constraint_rows()</div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l01673">mesh_base.h:1673</a></div></div>
<div class="ttc" id="classlibMesh_1_1Node_html"><div class="ttname"><a href="classlibMesh_1_1Node.html">libMesh::Node</a></div><div class="ttdoc">A Node is like a Point, but with more information. </div><div class="ttdef"><b>Definition:</b> <a href="node_8h_source.html#l00052">node.h:52</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a4af7f29e6040ed94dbfed8a8688e80b7"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a4af7f29e6040ed94dbfed8a8688e80b7">libMesh::Partitioner::_global_index_by_pid_map</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, dof_id_type &gt; _global_index_by_pid_map</div><div class="ttdoc">Maps active element ids into a contiguous range, as needed by parallel partitioner. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00286">partitioner.h:286</a></div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html"><div class="ttname"><a href="classlibMesh_1_1Elem.html">libMesh::Elem</a></div><div class="ttdoc">This is the base class from which all geometric element types are derived. </div><div class="ttdef"><b>Definition:</b> <a href="elem_8h_source.html#l00094">elem.h:94</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_af355eb8c855fc5442531490a04dfe7e4"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#af355eb8c855fc5442531490a04dfe7e4">libMesh::Partitioner::_local_id_to_elem</a></div><div class="ttdeci">std::vector&lt; Elem * &gt; _local_id_to_elem</div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00305">partitioner.h:305</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a43f45640aab1af26176e69592c666432"><div class="ttname"><a href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libMesh::libmesh_ignore</a></div><div class="ttdeci">void libmesh_ignore(const Args &amp;...)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00516">libmesh_common.h:516</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a6775c045a6c8e84299b5467df9fc81ae"><div class="ttname"><a href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; IndexType &gt; as_range(const std::pair&lt; IndexType, IndexType &gt; &amp;p)</div><div class="ttdoc">Helper function that allows us to treat a homogenous pair as a range. </div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_ae067b3d774e9d5a18f1b33371b8f1011"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#ae067b3d774e9d5a18f1b33371b8f1011">libMesh::Partitioner::_find_global_index_by_pid_map</a></div><div class="ttdeci">virtual void _find_global_index_by_pid_map(const MeshBase &amp;mesh)</div><div class="ttdoc">Construct contiguous global indices for the current partitioning. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l01067">partitioner.C:1067</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a82616af7498c609e19090b9437533ab2"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a82616af7498c609e19090b9437533ab2">libMesh::MeshBase::n_active_local_elem</a></div><div class="ttdeci">dof_id_type n_active_local_elem() const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00540">mesh_base.h:540</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aeceebf9cd5d53b02df3cd1e9907139e2"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aeceebf9cd5d53b02df3cd1e9907139e2">libMesh::DofObject::id</a></div><div class="ttdeci">dof_id_type id() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00823">dof_object.h:823</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a7a6af170d354795a9bbdb89f94b72325"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a7a6af170d354795a9bbdb89f94b72325">libMesh::Partitioner::_dual_graph</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; dof_id_type &gt; &gt; _dual_graph</div><div class="ttdoc">A dual graph corresponds to the mesh, and it is typically used in paritioner. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00302">partitioner.h:302</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a232c493ab22b03ee4fb068dcd4703fc1"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a232c493ab22b03ee4fb068dcd4703fc1">libMesh::Partitioner::_n_active_elem_on_proc</a></div><div class="ttdeci">std::vector&lt; dof_id_type &gt; _n_active_elem_on_proc</div><div class="ttdoc">The number of active elements on each processor. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00295">partitioner.h:295</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_ae1e7d1a1118f63d9889a761c27433bbc"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">libMesh::ParallelObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00114">parallel_object.h:114</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa37fe9e521c27a8acdb574984ac328f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1Partitioner.html">Partitioner</a>&gt; libMesh::SubdomainPartitioner::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>返回</dt><dd>A copy of this partitioner wrapped in a smart pointer. </dd></dl>

<p>实现了 <a class="el" href="classlibMesh_1_1Partitioner.html#a1980a34c5b3b6f74fb5f8ea1e4663548">libMesh::Partitioner</a>.</p>

<p>在文件 <a class="el" href="subdomain__partitioner_8h_source.html">subdomain_partitioner.h</a> 第 <a class="el" href="subdomain__partitioner_8h_source.html#l00088">88</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  {</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordflow">return</span> std::make_unique&lt;SubdomainPartitioner&gt;(*this);</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4843abeb1af6f4359f5cf5f7dcfa3ff3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1Partitioner.html">Partitioner</a>&gt;&amp; libMesh::SubdomainPartitioner::internal_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a> used internally by the <a class="el" href="classlibMesh_1_1SubdomainPartitioner.html" title="The SubdomainPartitioner partitions the elements in &quot;chunks&quot; of user-specified subdomain ids...">SubdomainPartitioner</a>. </p>
<dl class="section note"><dt>注解</dt><dd>The internal <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a> cannot also be a <a class="el" href="classlibMesh_1_1SubdomainPartitioner.html" title="The SubdomainPartitioner partitions the elements in &quot;chunks&quot; of user-specified subdomain ids...">SubdomainPartitioner</a>, otherwise an infinite loop will result. To have this class use e.g. the space-filling curve <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a> internally, one could do:</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classlibMesh_1_1SubdomainPartitioner.html#aba5beb711ed1c65fd3dabf52e503591d">SubdomainPartitioner</a> sp;</div>
<div class="line">sp.internal_partitioner() = std::make_unique&lt;SFCPartitioner&gt;();</div>
</div><!-- fragment --> 
<p>在文件 <a class="el" href="subdomain__partitioner_8h_source.html">subdomain_partitioner.h</a> 第 <a class="el" href="subdomain__partitioner_8h_source.html#l00115">115</a> 行定义.</p>

<p>参考 <a class="el" href="subdomain__partitioner_8h_source.html#l00122">_internal_partitioner</a>.</p>
<div class="fragment"><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1SubdomainPartitioner.html#abd9ee6417201fee9c219347d095b68f4">_internal_partitioner</a>; }</div>
<div class="ttc" id="classlibMesh_1_1SubdomainPartitioner_html_abd9ee6417201fee9c219347d095b68f4"><div class="ttname"><a href="classlibMesh_1_1SubdomainPartitioner.html#abd9ee6417201fee9c219347d095b68f4">libMesh::SubdomainPartitioner::_internal_partitioner</a></div><div class="ttdeci">std::unique_ptr&lt; Partitioner &gt; _internal_partitioner</div><div class="ttdoc">The internal Partitioner we use. </div><div class="ttdef"><b>Definition:</b> <a href="subdomain__partitioner_8h_source.html#l00122">subdomain_partitioner.h:122</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad98de32a8141cf87d48215b5d1b34c07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a>&amp; libMesh::SubdomainPartitioner::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This class contains a unique_ptr member, so it can't be default copy assigned. </p>

</div>
</div>
<a class="anchor" id="aaebd9bff041341d409af7c8f146ed844"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a>&amp; libMesh::SubdomainPartitioner::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1SubdomainPartitioner.html">SubdomainPartitioner</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a31df72bf643af2bd53e61ed6bf6e77f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partitions the <code><a class="el" href="classlibMesh_1_1MeshBase.html" title="This is the MeshBase class. ">MeshBase</a></code> into <code>n</code> parts by setting processor_id() on Nodes and Elems. </p>
<dl class="section note"><dt>注解</dt><dd>If you are implementing a new type of <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a>, you most likely do <em>not</em> want to override the <a class="el" href="classlibMesh_1_1Partitioner.html#a31df72bf643af2bd53e61ed6bf6e77f0" title="Partitions the MeshBase into n parts by setting processor_id() on Nodes and Elems. ">partition()</a> function, see instead the protected virtual <a class="el" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b" title="This is the actual partitioning method which must be overridden in derived classes. ">_do_partition()</a> method below. The <a class="el" href="classlibMesh_1_1Partitioner.html#a31df72bf643af2bd53e61ed6bf6e77f0" title="Partitions the MeshBase into n parts by setting processor_id() on Nodes and Elems. ">partition()</a> function is responsible for doing a lot of libmesh-internals-specific setup and finalization before and after the <a class="el" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b" title="This is the actual partitioning method which must be overridden in derived classes. ">_do_partition()</a> function is called. The only responsibility of the <a class="el" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b" title="This is the actual partitioning method which must be overridden in derived classes. ">_do_partition()</a> function, on the other hand, is to set the processor IDs of the elements according to a specific partitioning algorithm. See, e.g. <a class="el" href="classlibMesh_1_1MetisPartitioner.html" title="The MetisPartitioner uses the Metis graph partitioner to partition the elements. ">MetisPartitioner</a> for an example. </dd></dl>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00195">195</a> 行定义.</p>

<p>参考 <a class="el" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b">libMesh::Partitioner::_do_partition()</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l01139">libMesh::MeshTools::libmesh_assert_valid_remote_elems()</a>, <a class="el" href="mesh__communication_8C_source.html#l01308">mesh</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ae5b70f8be225d006fb25ef1e6b82bc3a">libMesh::MeshBase::n_active_elem()</a>, <a class="el" href="partitioner_8C_source.html#l00344">libMesh::Partitioner::partition_unpartitioned_elements()</a>, <a class="el" href="mesh__base_8C_source.html#l00923">libMesh::MeshBase::redistribute()</a>, <a class="el" href="mesh__base_8h_source.html#l01754">libMesh::MeshBase::set_n_partitions()</a>, <a class="el" href="partitioner_8C_source.html#l00851">libMesh::Partitioner::set_node_processor_ids()</a>, <a class="el" href="partitioner_8C_source.html#l00425">libMesh::Partitioner::set_parent_processor_ids()</a>, <a class="el" href="partitioner_8C_source.html#l00297">libMesh::Partitioner::single_partition()</a> , 以及 <a class="el" href="mesh__base_8h_source.html#l01150">libMesh::MeshBase::update_post_partitioning()</a>.</p>

<p>参考自 <a class="el" href="parmetis__partitioner_8C_source.html#l00110">libMesh::ParmetisPartitioner::_do_repartition()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00188">libMesh::Partitioner::partition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;{</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  <span class="comment">// BSK - temporary fix while redistribution is integrated 6/26/2008</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  <span class="comment">// Uncomment this to not repartition in parallel</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  <span class="comment">//   if (!mesh.is_serial())</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  <span class="comment">//     return;</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;  <span class="comment">// we cannot partition into more pieces than we have</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;  <span class="comment">// active elements!</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_parts =</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    (std::min(mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#ae5b70f8be225d006fb25ef1e6b82bc3a">n_active_elem</a>(), <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a><span class="keyword">&gt;</span>(n)));</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  <span class="comment">// Set the number of partitions in the mesh</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#aa1d4be6015417d17b41780fbcf5472a2">set_n_partitions</a>()=n_parts;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  <span class="keywordflow">if</span> (n_parts == 1)</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    {</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      this-&gt;<a class="code" href="classlibMesh_1_1Partitioner.html#a0fd1901649390e0e67d507a4b546a6d9">single_partition</a> (mesh);</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    }</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  <span class="comment">// First assign a temporary partitioning to any unpartitioned elements</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a496d076cc6dd052f3e448d6965e6654c">Partitioner::partition_unpartitioned_elements</a>(mesh, n_parts);</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  <span class="comment">// Call the partitioning function</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b">_do_partition</a>(mesh,n_parts);</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  <span class="comment">// Set the parent&#39;s processor ids</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a335c032a3e387485a7210ec806681c1a">Partitioner::set_parent_processor_ids</a>(mesh);</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  <span class="comment">// Redistribute elements if necessary, before setting node processor</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  <span class="comment">// ids, to make sure those will be set consistently</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;  mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a3a449a50a596d89c88b0bc3624d30d01">redistribute</a>();</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="preprocessor"></span>  <a class="code" href="namespacelibMesh_1_1MeshTools.html#a553f4980413b774f6ea4c39b18f331af">MeshTools::libmesh_assert_valid_remote_elems</a>(mesh);</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  <span class="comment">// Messed up elem processor_id()s can leave us without the child</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  <span class="comment">// elements we need to restrict vectors on a distributed mesh</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  MeshTools::libmesh_assert_valid_procids&lt;Elem&gt;(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  <span class="comment">// Set the node&#39;s processor ids</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#accc819bc421fd8e50323b46f9762c714">Partitioner::set_node_processor_ids</a>(mesh);</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="preprocessor"></span>  MeshTools::libmesh_assert_valid_procids&lt;Elem&gt;(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;  <span class="comment">// Give derived Mesh classes a chance to update any cached data to</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;  <span class="comment">// reflect the new partitioning</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#adaeaebe20eee61037642776c4952ac31">update_post_partitioning</a>();</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ae5b70f8be225d006fb25ef1e6b82bc3a"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ae5b70f8be225d006fb25ef1e6b82bc3a">libMesh::MeshBase::n_active_elem</a></div><div class="ttdeci">virtual dof_id_type n_active_elem() const =0</div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a553f4980413b774f6ea4c39b18f331af"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a553f4980413b774f6ea4c39b18f331af">libMesh::MeshTools::libmesh_assert_valid_remote_elems</a></div><div class="ttdeci">void libmesh_assert_valid_remote_elems(const MeshBase &amp;mesh)</div><div class="ttdoc">A function for verifying that active local elements&amp;#39; neighbors are never remote elements. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l01139">mesh_tools.C:1139</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a0fd1901649390e0e67d507a4b546a6d9"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a0fd1901649390e0e67d507a4b546a6d9">libMesh::Partitioner::single_partition</a></div><div class="ttdeci">bool single_partition(MeshBase &amp;mesh)</div><div class="ttdoc">Trivially &amp;quot;partitions&amp;quot; the mesh for one processor. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00297">partitioner.C:297</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_accc819bc421fd8e50323b46f9762c714"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#accc819bc421fd8e50323b46f9762c714">libMesh::Partitioner::set_node_processor_ids</a></div><div class="ttdeci">static void set_node_processor_ids(MeshBase &amp;mesh)</div><div class="ttdoc">This function is called after partitioning to set the processor IDs for the nodes. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00851">partitioner.C:851</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a95ae8657d4679a5f309069bc1aacb12b"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b">libMesh::Partitioner::_do_partition</a></div><div class="ttdeci">virtual void _do_partition(MeshBase &amp;mesh, const unsigned int n)=0</div><div class="ttdoc">This is the actual partitioning method which must be overridden in derived classes. </div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a496d076cc6dd052f3e448d6965e6654c"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a496d076cc6dd052f3e448d6965e6654c">libMesh::Partitioner::partition_unpartitioned_elements</a></div><div class="ttdeci">static void partition_unpartitioned_elements(MeshBase &amp;mesh)</div><div class="ttdoc">These functions assign processor IDs to newly-created elements (in parallel) which are currently assi...</div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00344">partitioner.C:344</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a335c032a3e387485a7210ec806681c1a"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a335c032a3e387485a7210ec806681c1a">libMesh::Partitioner::set_parent_processor_ids</a></div><div class="ttdeci">static void set_parent_processor_ids(MeshBase &amp;mesh)</div><div class="ttdoc">This function is called after partitioning to set the processor IDs for the inactive parent elements...</div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00425">partitioner.C:425</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_adaeaebe20eee61037642776c4952ac31"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#adaeaebe20eee61037642776c4952ac31">libMesh::MeshBase::update_post_partitioning</a></div><div class="ttdeci">virtual void update_post_partitioning()</div><div class="ttdoc">Recalculate any cached data after elements and nodes have been repartitioned. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l01150">mesh_base.h:1150</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a3a449a50a596d89c88b0bc3624d30d01"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a3a449a50a596d89c88b0bc3624d30d01">libMesh::MeshBase::redistribute</a></div><div class="ttdeci">virtual void redistribute()</div><div class="ttdoc">Redistribute elements between processors. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8C_source.html#l00923">mesh_base.C:923</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_aa1d4be6015417d17b41780fbcf5472a2"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#aa1d4be6015417d17b41780fbcf5472a2">libMesh::MeshBase::set_n_partitions</a></div><div class="ttdeci">unsigned int &amp; set_n_partitions()</div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l01754">mesh_base.h:1754</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af141c068984e9f0a044aa364d3f98b4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partitions the <code><a class="el" href="classlibMesh_1_1MeshBase.html" title="This is the MeshBase class. ">MeshBase</a></code> into <code>mesh.n_processors()</code> by setting processor_id() on Nodes and Elems. </p>
<dl class="section note"><dt>注解</dt><dd>If you are implementing a new type of <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a>, you most likely do <em>not</em> want to override the <a class="el" href="classlibMesh_1_1Partitioner.html#a31df72bf643af2bd53e61ed6bf6e77f0" title="Partitions the MeshBase into n parts by setting processor_id() on Nodes and Elems. ">partition()</a> function, see instead the protected virtual <a class="el" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b" title="This is the actual partitioning method which must be overridden in derived classes. ">_do_partition()</a> method below. The <a class="el" href="classlibMesh_1_1Partitioner.html#a31df72bf643af2bd53e61ed6bf6e77f0" title="Partitions the MeshBase into n parts by setting processor_id() on Nodes and Elems. ">partition()</a> function is responsible for doing a lot of libmesh-internals-specific setup and finalization before and after the <a class="el" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b" title="This is the actual partitioning method which must be overridden in derived classes. ">_do_partition()</a> function is called. The only responsibility of the <a class="el" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b" title="This is the actual partitioning method which must be overridden in derived classes. ">_do_partition()</a> function, on the other hand, is to set the processor IDs of the elements according to a specific partitioning algorithm. See, e.g. <a class="el" href="classlibMesh_1_1MetisPartitioner.html" title="The MetisPartitioner uses the Metis graph partitioner to partition the elements. ">MetisPartitioner</a> for an example. </dd></dl>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00188">188</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00103">libMesh::ParallelObject::n_processors()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00195">libMesh::Partitioner::partition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;{</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1Partitioner.html#a31df72bf643af2bd53e61ed6bf6e77f0">partition</a>(mesh,mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">n_processors</a>());</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a50719f74165b613ab929afd29b6d5f4a"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">libMesh::ParallelObject::n_processors</a></div><div class="ttdeci">processor_id_type n_processors() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00103">parallel_object.h:103</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a31df72bf643af2bd53e61ed6bf6e77f0"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a31df72bf643af2bd53e61ed6bf6e77f0">libMesh::Partitioner::partition</a></div><div class="ttdeci">virtual void partition(MeshBase &amp;mesh, const unsigned int n)</div><div class="ttdoc">Partitions the MeshBase into n parts by setting processor_id() on Nodes and Elems. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00195">partitioner.C:195</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aba95cc151a18676235b081c5accb547d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::Partitioner::partition_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibMesh_1_1MeshBase_1_1element__iterator.html">MeshBase::element_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibMesh_1_1MeshBase_1_1element__iterator.html">MeshBase::element_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partitions elements in the range (it, end) into n parts. </p>
<p>The mesh from which the iterators are created must also be passed in, since it is a parallel object and has other useful information in it.</p>
<p>Although <a class="el" href="classlibMesh_1_1Partitioner.html#aba95cc151a18676235b081c5accb547d" title="Partitions elements in the range (it, end) into n parts. ">partition_range()</a> is part of the public <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a> interface, it should not generally be called by applications. Its main purpose is to support the <a class="el" href="classlibMesh_1_1SubdomainPartitioner.html" title="The SubdomainPartitioner partitions the elements in &quot;chunks&quot; of user-specified subdomain ids...">SubdomainPartitioner</a>, which uses it internally to individually partition ranges of elements before combining them into the final partitioning. Most of the time, the protected <a class="el" href="classlibMesh_1_1Partitioner.html#a95ae8657d4679a5f309069bc1aacb12b" title="This is the actual partitioning method which must be overridden in derived classes. ">_do_partition()</a> function is implemented in terms of <a class="el" href="classlibMesh_1_1Partitioner.html#aba95cc151a18676235b081c5accb547d" title="Partitions elements in the range (it, end) into n parts. ">partition_range()</a> by passing a range which includes all the elements of the <a class="el" href="classlibMesh_1_1Mesh.html" title="The Mesh class is a thin wrapper, around the ReplicatedMesh class by default. ">Mesh</a>. </p>

<p>被 <a class="el" href="classlibMesh_1_1CentroidPartitioner.html#af02c959ced620c728c706a4bf5f11e9e">libMesh::CentroidPartitioner</a>, <a class="el" href="classlibMesh_1_1MappedSubdomainPartitioner.html#a090bf8a7527e2390cc0d2aed0189b546">libMesh::MappedSubdomainPartitioner</a>, <a class="el" href="classlibMesh_1_1SFCPartitioner.html#a51abbf410fbc56e99eb9d91cc622e494">libMesh::SFCPartitioner</a>, <a class="el" href="classlibMesh_1_1LinearPartitioner.html#a1c6eb45145fd3d8a3029a576a06272ad">libMesh::LinearPartitioner</a> , 以及 <a class="el" href="classlibMesh_1_1MetisPartitioner.html#a2d4b9f8e644ce2d9823c75c13b1f283f">libMesh::MetisPartitioner</a> 重载.</p>

<p>在文件 <a class="el" href="partitioner_8h_source.html">partitioner.h</a> 第 <a class="el" href="partitioner_8h_source.html#l00137">137</a> 行定义.</p>

<p>参考自 <a class="el" href="subdomain__partitioner_8C_source.html#l00049">_do_partition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  { libmesh_not_implemented(); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a496d076cc6dd052f3e448d6965e6654c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::partition_unpartitioned_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These functions assign processor IDs to newly-created elements (in parallel) which are currently assigned to processor 0. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00344">344</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00103">libMesh::ParallelObject::n_processors()</a>.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l00195">libMesh::Partitioner::partition()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00262">libMesh::Partitioner::repartition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;{</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a496d076cc6dd052f3e448d6965e6654c">Partitioner::partition_unpartitioned_elements</a>(mesh, mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">n_processors</a>());</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a50719f74165b613ab929afd29b6d5f4a"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">libMesh::ParallelObject::n_processors</a></div><div class="ttdeci">processor_id_type n_processors() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00103">parallel_object.h:103</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a496d076cc6dd052f3e448d6965e6654c"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a496d076cc6dd052f3e448d6965e6654c">libMesh::Partitioner::partition_unpartitioned_elements</a></div><div class="ttdeci">static void partition_unpartitioned_elements(MeshBase &amp;mesh)</div><div class="ttdoc">These functions assign processor IDs to newly-created elements (in parallel) which are currently assi...</div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00344">partitioner.C:344</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a815ead0dbc002c4fe3177803c75fca49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::partition_unpartitioned_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00351">351</a> 行定义.</p>

<p>参考 <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l00558">libMesh::MeshTools::create_bounding_box()</a>, <a class="el" href="mesh__communication__global__indices_8C_source.html#l00748">libMesh::MeshCommunication::find_global_indices()</a>, <a class="el" href="int__range_8h_source.html#l00134">libMesh::make_range()</a>, <a class="el" href="mesh__tools_8C_source.html#l00850">libMesh::MeshTools::n_elem()</a> , 以及 <a class="el" href="parallel__object_8h_source.html#l00103">libMesh::ParallelObject::n_processors()</a>.</p>
<div class="fragment"><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;{</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  <a class="code" href="structlibMesh_1_1MeshBase_1_1element__iterator.html">MeshBase::element_iterator</a>       it  = mesh.unpartitioned_elements_begin();</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;  <span class="keyword">const</span> <a class="code" href="structlibMesh_1_1MeshBase_1_1element__iterator.html">MeshBase::element_iterator</a> end = mesh.unpartitioned_elements_end();</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> n_unpartitioned_elements = <a class="code" href="namespacelibMesh_1_1MeshTools.html#a20881e0b5de5ef63808dd24d90e70b2a">MeshTools::n_elem</a> (it, end);</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  <span class="comment">// the unpartitioned elements must exist on all processors. If the range is empty on one</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  <span class="comment">// it is empty on all, and we can quit right here.</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <span class="keywordflow">if</span> (!n_unpartitioned_elements)</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  <span class="comment">// find the target subdomain sizes</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;  std::vector&lt;dof_id_type&gt; subdomain_bounds(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">n_processors</a>());</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> pid : <a class="code" href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">make_range</a>(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">n_processors</a>()))</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    {</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;      <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> tgt_subdomain_size = 0;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;      <span class="comment">// watch out for the case that n_subdomains &lt; n_processors</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;      <span class="keywordflow">if</span> (pid &lt; n_subdomains)</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        {</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;          tgt_subdomain_size = n_unpartitioned_elements/n_subdomains;</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;          <span class="keywordflow">if</span> (pid &lt; n_unpartitioned_elements%n_subdomains)</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;            tgt_subdomain_size++;</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        }</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;      <span class="comment">//libMesh::out &lt;&lt; &quot;pid, #= &quot; &lt;&lt; pid &lt;&lt; &quot;, &quot; &lt;&lt; tgt_subdomain_size &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;      <span class="keywordflow">if</span> (pid == 0)</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        subdomain_bounds[0] = tgt_subdomain_size;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        subdomain_bounds[pid] = subdomain_bounds[pid-1] + tgt_subdomain_size;</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    }</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;  libmesh_assert_equal_to (subdomain_bounds.back(), n_unpartitioned_elements);</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  <span class="comment">// create the unique mapping for all unpartitioned elements independent of partitioning</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;  <span class="comment">// determine the global indexing for all the unpartitioned elements</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;  std::vector&lt;dof_id_type&gt; global_indices;</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;  <span class="comment">// Calling this on all processors a unique range in [0,n_unpartitioned_elements) is constructed.</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  <span class="comment">// Only the indices for the elements we pass in are returned in the array.</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  <a class="code" href="classlibMesh_1_1MeshCommunication.html">MeshCommunication</a>().<a class="code" href="classlibMesh_1_1MeshCommunication.html#aabdd0e5938cd28818a10628cf2c716cd">find_global_indices</a> (mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>(),</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                                           <a class="code" href="namespacelibMesh_1_1MeshTools.html#a2793e67a6d7e4c5e59692a4acfbcd425">MeshTools::create_bounding_box</a>(mesh), it, end,</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                                           global_indices);</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;  <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> cnt=0;</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(it, end))</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    {</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      libmesh_assert_less (cnt, global_indices.size());</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> global_index =</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        global_indices[cnt++];</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;      libmesh_assert_less (global_index, subdomain_bounds.back());</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;      libmesh_assert_less (global_index, n_unpartitioned_elements);</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> subdomain_id =</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        cast_int&lt;processor_id_type&gt;</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;        (std::distance(subdomain_bounds.begin(),</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                       std::upper_bound(subdomain_bounds.begin(),</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                                        subdomain_bounds.end(),</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;                                        global_index)));</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;      libmesh_assert_less (subdomain_id, n_subdomains);</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;      elem-&gt;processor_id() = subdomain_id;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;      <span class="comment">//libMesh::out &lt;&lt; &quot;assigning &quot; &lt;&lt; global_index &lt;&lt; &quot; to &quot; &lt;&lt; subdomain_id &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    }</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;}</div>
<div class="ttc" id="structlibMesh_1_1MeshBase_1_1element__iterator_html"><div class="ttname"><a href="structlibMesh_1_1MeshBase_1_1element__iterator.html">libMesh::MeshBase::element_iterator</a></div><div class="ttdoc">The definition of the element_iterator struct. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l02068">mesh_base.h:2068</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a20881e0b5de5ef63808dd24d90e70b2a"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a20881e0b5de5ef63808dd24d90e70b2a">libMesh::MeshTools::n_elem</a></div><div class="ttdeci">dof_id_type n_elem(const MeshBase::const_element_iterator &amp;begin, const MeshBase::const_element_iterator &amp;end)</div><div class="ttdoc">Count up the number of elements of a specific type (as defined by an iterator range). </div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00850">mesh_tools.C:850</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a2793e67a6d7e4c5e59692a4acfbcd425"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a2793e67a6d7e4c5e59692a4acfbcd425">libMesh::MeshTools::create_bounding_box</a></div><div class="ttdeci">libMesh::BoundingBox create_bounding_box(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00558">mesh_tools.C:558</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a50719f74165b613ab929afd29b6d5f4a"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">libMesh::ParallelObject::n_processors</a></div><div class="ttdeci">processor_id_type n_processors() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00103">parallel_object.h:103</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_aabdd0e5938cd28818a10628cf2c716cd"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#aabdd0e5938cd28818a10628cf2c716cd">libMesh::MeshCommunication::find_global_indices</a></div><div class="ttdeci">void find_global_indices(const Parallel::Communicator &amp;communicator, const libMesh::BoundingBox &amp;, const ForwardIterator &amp;, const ForwardIterator &amp;, std::vector&lt; dof_id_type &gt; &amp;) const </div><div class="ttdoc">This method determines a globally unique, partition-agnostic index for each object in the input range...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication__global__indices_8C_source.html#l00748">mesh_communication_global_indices.C:748</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af18245d4f872c36a41fc74086bda3e80"><div class="ttname"><a href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00104">id_types.h:104</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html">libMesh::MeshCommunication</a></div><div class="ttdoc">This is the MeshCommunication class. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8h_source.html#l00050">mesh_communication.h:50</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a6775c045a6c8e84299b5467df9fc81ae"><div class="ttname"><a href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; IndexType &gt; as_range(const std::pair&lt; IndexType, IndexType &gt; &amp;p)</div><div class="ttdoc">Helper function that allows us to treat a homogenous pair as a range. </div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a18dea64f5cc7fa12c864d7571bb69d0b"><div class="ttname"><a href="namespacelibMesh.html#a18dea64f5cc7fa12c864d7571bb69d0b">libMesh::make_range</a></div><div class="ttdeci">IntRange&lt; T &gt; make_range(T beg, T end)</div><div class="ttdoc">The 2-parameter make_range() helper function returns an IntRange&amp;lt;T&amp;gt; when both input parameters are of...</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00134">int_range.h:134</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a427edcaf367f25545f4ca18de953ccbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::processor_pairs_to_interface_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::pair&lt; <a class="el" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a>, <a class="el" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> &gt;, std::set&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>processor_pair_to_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On the partitioning interface, a surface is shared by two and only two processors. </p>
<p>Try to find which pair of processors corresponds to which surfaces, and store their nodes. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00578">578</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="dof__object_8h_source.html#l00488">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a> , 以及 <a class="el" href="tecplot__io_8C_source.html#l00067">n_nodes</a>.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l00656">libMesh::Partitioner::set_interface_node_processor_ids_BFS()</a>, <a class="el" href="partitioner_8C_source.html#l00631">libMesh::Partitioner::set_interface_node_processor_ids_linear()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00737">libMesh::Partitioner::set_interface_node_processor_ids_petscpartitioner()</a>.</p>
<div class="fragment"><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;{</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;  processor_pair_to_nodes.clear();</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;  std::set&lt;dof_id_type&gt; mynodes;</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;  std::set&lt;dof_id_type&gt; neighbor_nodes;</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;  std::vector&lt;dof_id_type&gt; common_nodes;</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;  <span class="comment">// Loop over all the active elements</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : mesh.active_element_ptr_range())</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    {</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;      <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(elem);</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;      libmesh_assert_not_equal_to (elem-&gt;processor_id(), <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>);</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;      <span class="keyword">auto</span> <a class="code" href="tecplot__io_8C.html#ae4aba5fa8c8579c6576b4f087aefb091">n_nodes</a> = elem-&gt;n_nodes();</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;      <span class="comment">// prepare data for this element</span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;      mynodes.clear();</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;      neighbor_nodes.clear();</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;      common_nodes.clear();</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inode = 0; inode &lt; <a class="code" href="tecplot__io_8C.html#ae4aba5fa8c8579c6576b4f087aefb091">n_nodes</a>; inode++)</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        mynodes.insert(elem-&gt;node_id(inode));</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : elem-&gt;side_index_range())</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;        {</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;          <span class="keyword">auto</span> neigh = elem-&gt;neighbor_ptr(i);</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;          <span class="keywordflow">if</span> (neigh &amp;&amp; !neigh-&gt;is_remote() &amp;&amp; neigh-&gt;processor_id() != elem-&gt;processor_id())</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;            {</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;              neighbor_nodes.clear();</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;              common_nodes.clear();</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;              <span class="keyword">auto</span> neigh_n_nodes = neigh-&gt;n_nodes();</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inode = 0; inode &lt; neigh_n_nodes; inode++)</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;                neighbor_nodes.insert(neigh-&gt;node_id(inode));</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;              std::set_intersection(mynodes.begin(), mynodes.end(),</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;                                    neighbor_nodes.begin(), neighbor_nodes.end(),</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                                    std::back_inserter(common_nodes));</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;              <span class="keyword">auto</span> &amp; map_set = processor_pair_to_nodes[std::make_pair(std::min(elem-&gt;processor_id(), neigh-&gt;processor_id()),</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                                                                      std::max(elem-&gt;processor_id(), neigh-&gt;processor_id()))];</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;              <span class="keywordflow">for</span> (<span class="keyword">auto</span> global_node_id : common_nodes)</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                map_set.insert(global_node_id);</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;            }</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;        }</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    }</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;}</div>
<div class="ttc" id="tecplot__io_8C_html_ae4aba5fa8c8579c6576b4f087aefb091"><div class="ttname"><a href="tecplot__io_8C.html#ae4aba5fa8c8579c6576b4f087aefb091">n_nodes</a></div><div class="ttdeci">const dof_id_type n_nodes</div><div class="ttdef"><b>Definition:</b> <a href="tecplot__io_8C_source.html#l00067">tecplot_io.C:67</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdoc">An invalid processor_id to distinguish DoFs that have not been assigned to a processor. </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00488">dof_object.h:488</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae9ebf3a7dd7c2477a6b17862f2c0741f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::repartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repartitions the <code><a class="el" href="classlibMesh_1_1MeshBase.html" title="This is the MeshBase class. ">MeshBase</a></code> into <code>n</code> parts. </p>
<p>(Some partitioning algorithms can repartition more efficiently than computing a new partitioning from scratch.) The default behavior is to simply call this-&gt;partition(mesh,n). </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00262">262</a> 行定义.</p>

<p>参考 <a class="el" href="partitioner_8h_source.html#l00251">libMesh::Partitioner::_do_repartition()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ae5b70f8be225d006fb25ef1e6b82bc3a">libMesh::MeshBase::n_active_elem()</a>, <a class="el" href="partitioner_8C_source.html#l00344">libMesh::Partitioner::partition_unpartitioned_elements()</a>, <a class="el" href="mesh__base_8h_source.html#l01754">libMesh::MeshBase::set_n_partitions()</a>, <a class="el" href="partitioner_8C_source.html#l00851">libMesh::Partitioner::set_node_processor_ids()</a>, <a class="el" href="partitioner_8C_source.html#l00425">libMesh::Partitioner::set_parent_processor_ids()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00297">libMesh::Partitioner::single_partition()</a>.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l00255">libMesh::Partitioner::repartition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;{</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  <span class="comment">// we cannot partition into more pieces than we have</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;  <span class="comment">// active elements!</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_parts =</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    (std::min(mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#ae5b70f8be225d006fb25ef1e6b82bc3a">n_active_elem</a>(), <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a><span class="keyword">&gt;</span>(n)));</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  <span class="comment">// Set the number of partitions in the mesh</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#aa1d4be6015417d17b41780fbcf5472a2">set_n_partitions</a>()=n_parts;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  <span class="keywordflow">if</span> (n_parts == 1)</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    {</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;      this-&gt;<a class="code" href="classlibMesh_1_1Partitioner.html#a0fd1901649390e0e67d507a4b546a6d9">single_partition</a> (mesh);</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    }</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  <span class="comment">// First assign a temporary partitioning to any unpartitioned elements</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a496d076cc6dd052f3e448d6965e6654c">Partitioner::partition_unpartitioned_elements</a>(mesh, n_parts);</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  <span class="comment">// Call the partitioning function</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1Partitioner.html#a91df287a38324e9531b8aba0344ad184">_do_repartition</a>(mesh,n_parts);</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  <span class="comment">// Set the parent&#39;s processor ids</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a335c032a3e387485a7210ec806681c1a">Partitioner::set_parent_processor_ids</a>(mesh);</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  <span class="comment">// Set the node&#39;s processor ids</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#accc819bc421fd8e50323b46f9762c714">Partitioner::set_node_processor_ids</a>(mesh);</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ae5b70f8be225d006fb25ef1e6b82bc3a"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ae5b70f8be225d006fb25ef1e6b82bc3a">libMesh::MeshBase::n_active_elem</a></div><div class="ttdeci">virtual dof_id_type n_active_elem() const =0</div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a0fd1901649390e0e67d507a4b546a6d9"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a0fd1901649390e0e67d507a4b546a6d9">libMesh::Partitioner::single_partition</a></div><div class="ttdeci">bool single_partition(MeshBase &amp;mesh)</div><div class="ttdoc">Trivially &amp;quot;partitions&amp;quot; the mesh for one processor. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00297">partitioner.C:297</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_accc819bc421fd8e50323b46f9762c714"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#accc819bc421fd8e50323b46f9762c714">libMesh::Partitioner::set_node_processor_ids</a></div><div class="ttdeci">static void set_node_processor_ids(MeshBase &amp;mesh)</div><div class="ttdoc">This function is called after partitioning to set the processor IDs for the nodes. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00851">partitioner.C:851</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a91df287a38324e9531b8aba0344ad184"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a91df287a38324e9531b8aba0344ad184">libMesh::Partitioner::_do_repartition</a></div><div class="ttdeci">virtual void _do_repartition(MeshBase &amp;mesh, const unsigned int n)</div><div class="ttdoc">This is the actual re-partitioning method which can be overridden in derived classes. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00251">partitioner.h:251</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a496d076cc6dd052f3e448d6965e6654c"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a496d076cc6dd052f3e448d6965e6654c">libMesh::Partitioner::partition_unpartitioned_elements</a></div><div class="ttdeci">static void partition_unpartitioned_elements(MeshBase &amp;mesh)</div><div class="ttdoc">These functions assign processor IDs to newly-created elements (in parallel) which are currently assi...</div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00344">partitioner.C:344</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a335c032a3e387485a7210ec806681c1a"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a335c032a3e387485a7210ec806681c1a">libMesh::Partitioner::set_parent_processor_ids</a></div><div class="ttdeci">static void set_parent_processor_ids(MeshBase &amp;mesh)</div><div class="ttdoc">This function is called after partitioning to set the processor IDs for the inactive parent elements...</div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00425">partitioner.C:425</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_aa1d4be6015417d17b41780fbcf5472a2"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#aa1d4be6015417d17b41780fbcf5472a2">libMesh::MeshBase::set_n_partitions</a></div><div class="ttdeci">unsigned int &amp; set_n_partitions()</div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l01754">mesh_base.h:1754</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4a0bf09b329429cf110aca4907e880bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::repartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repartitions the <code><a class="el" href="classlibMesh_1_1MeshBase.html" title="This is the MeshBase class. ">MeshBase</a></code> into <code>mesh.n_processors()</code> parts. </p>
<p>This is required since some partitioning algorithms can repartition more efficiently than computing a new partitioning from scratch. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00255">255</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00103">libMesh::ParallelObject::n_processors()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00262">libMesh::Partitioner::repartition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;{</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1Partitioner.html#ae9ebf3a7dd7c2477a6b17862f2c0741f">repartition</a>(mesh,mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">n_processors</a>());</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a50719f74165b613ab929afd29b6d5f4a"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a50719f74165b613ab929afd29b6d5f4a">libMesh::ParallelObject::n_processors</a></div><div class="ttdeci">processor_id_type n_processors() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00103">parallel_object.h:103</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_ae9ebf3a7dd7c2477a6b17862f2c0741f"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#ae9ebf3a7dd7c2477a6b17862f2c0741f">libMesh::Partitioner::repartition</a></div><div class="ttdeci">void repartition(MeshBase &amp;mesh, const unsigned int n)</div><div class="ttdoc">Repartitions the MeshBase into n parts. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00262">partitioner.C:262</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7130d717b7a9e09615cf8affc729b743"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::set_interface_node_processor_ids_BFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nodes on the partitioning interface is clustered into two groups BFS (Breadth First Search)scheme for per pair of processors. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00656">656</a> 行定义.</p>

<p>参考 <a class="el" href="mesh__tools_8C_source.html#l00448">libMesh::MeshTools::build_nodes_to_elem_map()</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l00888">libMesh::MeshTools::find_nodal_neighbors()</a>, <a class="el" href="mesh__base_8h_source.html#l00571">libMesh::MeshBase::node_ref()</a>, <a class="el" href="dof__object_8h_source.html#l00898">libMesh::DofObject::processor_id()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00578">libMesh::Partitioner::processor_pairs_to_interface_nodes()</a>.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l00851">libMesh::Partitioner::set_node_processor_ids()</a>.</p>
<div class="fragment"><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;{</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;  <span class="comment">// I see occasional consistency failures when using this on a</span></div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;  <span class="comment">// distributed mesh</span></div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;  libmesh_experimental();</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;  std::map&lt;std::pair&lt;processor_id_type, processor_id_type&gt;, std::set&lt;dof_id_type&gt;&gt; processor_pair_to_nodes;</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a427edcaf367f25545f4ca18de953ccbc">processor_pairs_to_interface_nodes</a>(mesh, processor_pair_to_nodes);</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;  std::unordered_map&lt;dof_id_type, std::vector&lt;const Elem *&gt;&gt; nodes_to_elem_map;</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#a5aad7309726b936905141d30578ccd7b">MeshTools::build_nodes_to_elem_map</a>(mesh, nodes_to_elem_map);</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;  std::vector&lt;const Node *&gt;  neighbors;</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;  std::set&lt;dof_id_type&gt; neighbors_order;</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;  std::vector&lt;dof_id_type&gt; common_nodes;</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;  std::queue&lt;dof_id_type&gt; nodes_queue;</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  std::set&lt;dof_id_type&gt; visted_nodes;</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; pmap : processor_pair_to_nodes)</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;    {</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;      std::size_t n_own_nodes = pmap.second.size()/2;</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;      <span class="comment">// Initialize node assignment</span></div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> <span class="keywordtype">id</span> : pmap.second)</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;        mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">node_ref</a>(<span class="keywordtype">id</span>).<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>() = pmap.first.second;</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;      visted_nodes.clear();</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> <span class="keywordtype">id</span> : pmap.second)</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;        {</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;          mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">node_ref</a>(<span class="keywordtype">id</span>).<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>() = pmap.first.second;</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;          <span class="keywordflow">if</span> (visted_nodes.find(<span class="keywordtype">id</span>) != visted_nodes.end())</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;            {</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;              nodes_queue.push(<span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;              visted_nodes.insert(<span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;              <span class="keywordflow">if</span> (visted_nodes.size() &gt;= n_own_nodes)</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;            }</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;          <span class="keywordflow">while</span> (!nodes_queue.empty())</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;            {</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;              <span class="keyword">auto</span> &amp; node = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">node_ref</a>(nodes_queue.front());</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;              nodes_queue.pop();</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;              neighbors.clear();</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;              <a class="code" href="namespacelibMesh_1_1MeshTools.html#a28af775ac6c94887b61570603eff70b9">MeshTools::find_nodal_neighbors</a>(mesh, node, nodes_to_elem_map, neighbors);</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;              neighbors_order.clear();</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;              <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; neighbor : neighbors)</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;                neighbors_order.insert(neighbor-&gt;id());</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;              common_nodes.clear();</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;              std::set_intersection(pmap.second.begin(), pmap.second.end(),</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;                                    neighbors_order.begin(), neighbors_order.end(),</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                                    std::back_inserter(common_nodes));</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;              <span class="keywordflow">for</span> (<span class="keyword">auto</span> c_node : common_nodes)</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;                <span class="keywordflow">if</span> (visted_nodes.find(c_node) == visted_nodes.end())</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;                  {</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;                    nodes_queue.push(c_node);</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;                    visted_nodes.insert(c_node);</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;                    <span class="keywordflow">if</span> (visted_nodes.size() &gt;= n_own_nodes)</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;                      <span class="keywordflow">goto</span> queue_done;</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;                  }</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;              <span class="keywordflow">if</span> (visted_nodes.size() &gt;= n_own_nodes)</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;                <span class="keywordflow">goto</span> queue_done;</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;            }</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;        }</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    queue_done:</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> node : visted_nodes)</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;        mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">node_ref</a>(node).<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>() = pmap.first.first;</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;    }</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_af6e7cea860ccee9625012f9fcb0ae13b"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">libMesh::MeshBase::node_ref</a></div><div class="ttdeci">virtual const Node &amp; node_ref(const dof_id_type i) const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00571">mesh_base.h:571</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a5aad7309726b936905141d30578ccd7b"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a5aad7309726b936905141d30578ccd7b">libMesh::MeshTools::build_nodes_to_elem_map</a></div><div class="ttdeci">void build_nodes_to_elem_map(const MeshBase &amp;mesh, std::vector&lt; std::vector&lt; dof_id_type &gt;&gt; &amp;nodes_to_elem_map)</div><div class="ttdoc">After calling this function the input vector nodes_to_elem_map will contain the node to element conne...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00448">mesh_tools.C:448</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a28af775ac6c94887b61570603eff70b9"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a28af775ac6c94887b61570603eff70b9">libMesh::MeshTools::find_nodal_neighbors</a></div><div class="ttdeci">void find_nodal_neighbors(const MeshBase &amp;, const Node &amp;node, const std::vector&lt; std::vector&lt; const Elem * &gt;&gt; &amp;nodes_to_elem_map, std::vector&lt; const Node * &gt; &amp;neighbors)</div><div class="ttdoc">Given a mesh and a node in the mesh, the vector will be filled with every node directly attached to t...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00888">mesh_tools.C:888</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a427edcaf367f25545f4ca18de953ccbc"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a427edcaf367f25545f4ca18de953ccbc">libMesh::Partitioner::processor_pairs_to_interface_nodes</a></div><div class="ttdeci">static void processor_pairs_to_interface_nodes(MeshBase &amp;mesh, std::map&lt; std::pair&lt; processor_id_type, processor_id_type &gt;, std::set&lt; dof_id_type &gt;&gt; &amp;processor_pair_to_nodes)</div><div class="ttdoc">On the partitioning interface, a surface is shared by two and only two processors. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00578">partitioner.C:578</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_a0e8748b2c01f78902c9c432ad79cf546"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">libMesh::DofObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00898">dof_object.h:898</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae4517129393c07dfd490134e68136b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::set_interface_node_processor_ids_linear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nodes on the partitioning interface is linearly assigned to each pair of processors. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00631">631</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__base_8h_source.html#l00571">libMesh::MeshBase::node_ref()</a>, <a class="el" href="dof__object_8h_source.html#l00898">libMesh::DofObject::processor_id()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00578">libMesh::Partitioner::processor_pairs_to_interface_nodes()</a>.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l00851">libMesh::Partitioner::set_node_processor_ids()</a>.</p>
<div class="fragment"><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;{</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;  std::map&lt;std::pair&lt;processor_id_type, processor_id_type&gt;, std::set&lt;dof_id_type&gt;&gt; processor_pair_to_nodes;</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a427edcaf367f25545f4ca18de953ccbc">processor_pairs_to_interface_nodes</a>(mesh, processor_pair_to_nodes);</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; pmap : processor_pair_to_nodes)</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    {</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;      std::size_t n_own_nodes = pmap.second.size()/2, i = 0;</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> <span class="keywordtype">id</span> : pmap.second)</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;        {</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;          <span class="keyword">auto</span> &amp; node = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">node_ref</a>(<span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;          <span class="keywordflow">if</span> (i &lt;= n_own_nodes)</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;            node.<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>() = pmap.first.first;</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;            node.processor_id() = pmap.first.second;</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;          i++;</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;        }</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    }</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_af6e7cea860ccee9625012f9fcb0ae13b"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">libMesh::MeshBase::node_ref</a></div><div class="ttdeci">virtual const Node &amp; node_ref(const dof_id_type i) const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00571">mesh_base.h:571</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a427edcaf367f25545f4ca18de953ccbc"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a427edcaf367f25545f4ca18de953ccbc">libMesh::Partitioner::processor_pairs_to_interface_nodes</a></div><div class="ttdeci">static void processor_pairs_to_interface_nodes(MeshBase &amp;mesh, std::map&lt; std::pair&lt; processor_id_type, processor_id_type &gt;, std::set&lt; dof_id_type &gt;&gt; &amp;processor_pair_to_nodes)</div><div class="ttdoc">On the partitioning interface, a surface is shared by two and only two processors. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00578">partitioner.C:578</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_a0e8748b2c01f78902c9c432ad79cf546"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">libMesh::DofObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00898">dof_object.h:898</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a216c0efb66f5acc50dd15d9c6baf6311"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::set_interface_node_processor_ids_petscpartitioner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nodes on the partitioning interface is partitioned into two groups using a PETSc partitioner for each pair of processors. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00737">737</a> 行定义.</p>

<p>参考 <a class="el" href="mesh__tools_8C_source.html#l00448">libMesh::MeshTools::build_nodes_to_elem_map()</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l00888">libMesh::MeshTools::find_nodal_neighbors()</a>, <a class="el" href="wrapped__petsc_8h_source.html#l00109">libMesh::WrappedPetsc&lt; T &gt;::get()</a>, <a class="el" href="petsc__dm__wrapper_8C_source.html#l00061">libMesh::is</a>, <a class="el" href="libmesh__common_8h_source.html#l00516">libMesh::libmesh_ignore()</a>, <a class="el" href="mesh__base_8h_source.html#l00571">libMesh::MeshBase::node_ref()</a>, <a class="el" href="dof__object_8h_source.html#l00898">libMesh::DofObject::processor_id()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00578">libMesh::Partitioner::processor_pairs_to_interface_nodes()</a>.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l00851">libMesh::Partitioner::set_node_processor_ids()</a>.</p>
<div class="fragment"><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;{</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;  <a class="code" href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libmesh_ignore</a>(mesh); <span class="comment">// Only used if LIBMESH_HAVE_PETSC</span></div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;<span class="preprocessor">#if LIBMESH_HAVE_PETSC</span></div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="preprocessor"></span>  std::map&lt;std::pair&lt;processor_id_type, processor_id_type&gt;, std::set&lt;dof_id_type&gt;&gt; processor_pair_to_nodes;</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;  <a class="code" href="classlibMesh_1_1Partitioner.html#a427edcaf367f25545f4ca18de953ccbc">processor_pairs_to_interface_nodes</a>(mesh, processor_pair_to_nodes);</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;  std::vector&lt;std::vector&lt;const Elem *&gt;&gt; nodes_to_elem_map;</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#a5aad7309726b936905141d30578ccd7b">MeshTools::build_nodes_to_elem_map</a>(mesh, nodes_to_elem_map);</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;  std::vector&lt;const Node *&gt;  neighbors;</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;  std::set&lt;dof_id_type&gt; neighbors_order;</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;  std::vector&lt;dof_id_type&gt; common_nodes;</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;  std::vector&lt;dof_id_type&gt; rows;</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;  std::vector&lt;dof_id_type&gt; cols;</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;  std::map&lt;dof_id_type, dof_id_type&gt; global_to_local;</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; pmap : processor_pair_to_nodes)</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;    {</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;      rows.clear();</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;      rows.resize(pmap.second.size()+1);</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;      cols.clear();</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> <span class="keywordtype">id</span> : pmap.second)</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;        global_to_local[id] = i++;</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;      i = 0;</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">id</span> : pmap.second)</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;        {</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;          <span class="keyword">auto</span> &amp; node = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">node_ref</a>(<span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;          neighbors.clear();</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;          <a class="code" href="namespacelibMesh_1_1MeshTools.html#a28af775ac6c94887b61570603eff70b9">MeshTools::find_nodal_neighbors</a>(mesh, node, nodes_to_elem_map, neighbors);</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;          neighbors_order.clear();</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; neighbor : neighbors)</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;            neighbors_order.insert(neighbor-&gt;id());</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;          common_nodes.clear();</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;          std::set_intersection(pmap.second.begin(), pmap.second.end(),</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;                                neighbors_order.begin(), neighbors_order.end(),</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;                                std::back_inserter(common_nodes));</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;          rows[i+1] = rows[i] + cast_int&lt;dof_id_type&gt;(common_nodes.size());</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">auto</span> c_node : common_nodes)</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;            cols.push_back(global_to_local[c_node]);</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;          i++;</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;        }</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;      <span class="comment">// Next we construct an IS from a MatPartitioning</span></div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;      <a class="code" href="structlibMesh_1_1WrappedPetsc.html">WrappedPetsc&lt;IS&gt;</a> <a class="code" href="namespacelibMesh.html#aace8d3cee7f3ef6d701f5f18731a4969">is</a>;</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;      {</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;        PetscInt *adj_i, *adj_j;</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;        PetscCalloc1(rows.size(), &amp;adj_i);</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;        PetscCalloc1(cols.size(), &amp;adj_j);</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;        PetscInt rows_size = cast_int&lt;PetscInt&gt;(rows.size());</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;        <span class="keywordflow">for</span> (PetscInt ii=0; ii&lt;rows_size; ii++)</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;          adj_i[ii] = rows[ii];</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;        PetscInt cols_size = cast_int&lt;PetscInt&gt;(cols.size());</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;        <span class="keywordflow">for</span> (PetscInt ii=0; ii&lt;cols_size; ii++)</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;          adj_j[ii] = cols[ii];</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;        <span class="keyword">const</span> PetscInt sz = cast_int&lt;PetscInt&gt;(pmap.second.size());</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;        <span class="comment">// Create sparse matrix representing an adjacency list</span></div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;        <a class="code" href="structlibMesh_1_1WrappedPetsc.html">WrappedPetsc&lt;Mat&gt;</a> adj;</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;        MatCreateMPIAdj(PETSC_COMM_SELF, sz, sz, adj_i, adj_j, <span class="keyword">nullptr</span>, adj.get());</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;        <span class="comment">// Create MatPartitioning object</span></div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;        <a class="code" href="structlibMesh_1_1WrappedPetsc.html">WrappedPetsc&lt;MatPartitioning&gt;</a> part;</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;        MatPartitioningCreate(PETSC_COMM_SELF, part.get());</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;        <span class="comment">// Apply MatPartitioning, storing results in &quot;is&quot;</span></div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;        MatPartitioningSetAdjacency(part, adj);</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;        MatPartitioningSetNParts(part, 2);</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;        PetscObjectSetOptionsPrefix((PetscObject)(*part), <span class="stringliteral">&quot;balance_&quot;</span>);</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;        MatPartitioningSetFromOptions(part);</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;        MatPartitioningApply(part, is.<a class="code" href="structlibMesh_1_1WrappedPetsc.html#ad21aaccb13b0a3ca0bc9a1be13441586">get</a>());</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;      }</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;      PetscInt local_size;</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;      <span class="keyword">const</span> PetscInt *indices;</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;      ISGetLocalSize(is, &amp;local_size);</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;      ISGetIndices(is, &amp;indices);</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;      i = 0;</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">id</span> : pmap.second)</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;        {</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;          <span class="keyword">auto</span> &amp; node = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">node_ref</a>(<span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;          <span class="keywordflow">if</span> (indices[i])</div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;            node.<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>() = pmap.first.second;</div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;            node.processor_id() = pmap.first.first;</div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;</div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;          i++;</div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;        }</div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;      ISRestoreIndices(is, &amp;indices);</div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;    }</div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="preprocessor"></span>  libmesh_error_msg(<span class="stringliteral">&quot;PETSc is required&quot;</span>);</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;<span class="preprocessor"></span>}</div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_af6e7cea860ccee9625012f9fcb0ae13b"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">libMesh::MeshBase::node_ref</a></div><div class="ttdeci">virtual const Node &amp; node_ref(const dof_id_type i) const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00571">mesh_base.h:571</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a5aad7309726b936905141d30578ccd7b"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a5aad7309726b936905141d30578ccd7b">libMesh::MeshTools::build_nodes_to_elem_map</a></div><div class="ttdeci">void build_nodes_to_elem_map(const MeshBase &amp;mesh, std::vector&lt; std::vector&lt; dof_id_type &gt;&gt; &amp;nodes_to_elem_map)</div><div class="ttdoc">After calling this function the input vector nodes_to_elem_map will contain the node to element conne...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00448">mesh_tools.C:448</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a43f45640aab1af26176e69592c666432"><div class="ttname"><a href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libMesh::libmesh_ignore</a></div><div class="ttdeci">void libmesh_ignore(const Args &amp;...)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00516">libmesh_common.h:516</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a28af775ac6c94887b61570603eff70b9"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a28af775ac6c94887b61570603eff70b9">libMesh::MeshTools::find_nodal_neighbors</a></div><div class="ttdeci">void find_nodal_neighbors(const MeshBase &amp;, const Node &amp;node, const std::vector&lt; std::vector&lt; const Elem * &gt;&gt; &amp;nodes_to_elem_map, std::vector&lt; const Node * &gt; &amp;neighbors)</div><div class="ttdoc">Given a mesh and a node in the mesh, the vector will be filled with every node directly attached to t...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00888">mesh_tools.C:888</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a427edcaf367f25545f4ca18de953ccbc"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a427edcaf367f25545f4ca18de953ccbc">libMesh::Partitioner::processor_pairs_to_interface_nodes</a></div><div class="ttdeci">static void processor_pairs_to_interface_nodes(MeshBase &amp;mesh, std::map&lt; std::pair&lt; processor_id_type, processor_id_type &gt;, std::set&lt; dof_id_type &gt;&gt; &amp;processor_pair_to_nodes)</div><div class="ttdoc">On the partitioning interface, a surface is shared by two and only two processors. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00578">partitioner.C:578</a></div></div>
<div class="ttc" id="structlibMesh_1_1WrappedPetsc_html_ad21aaccb13b0a3ca0bc9a1be13441586"><div class="ttname"><a href="structlibMesh_1_1WrappedPetsc.html#ad21aaccb13b0a3ca0bc9a1be13441586">libMesh::WrappedPetsc::get</a></div><div class="ttdeci">T * get()</div><div class="ttdoc">获取托管对象的指针。 这用于模拟以下代码： KSP ksp; KSPCreate(comm, &amp;amp;ksp); 因为在这种上下文中，取包装对象的地址是没有意义的。 </div><div class="ttdef"><b>Definition:</b> <a href="wrapped__petsc_8h_source.html#l00109">wrapped_petsc.h:109</a></div></div>
<div class="ttc" id="namespacelibMesh_html_aace8d3cee7f3ef6d701f5f18731a4969"><div class="ttname"><a href="namespacelibMesh.html#aace8d3cee7f3ef6d701f5f18731a4969">libMesh::is</a></div><div class="ttdeci">PetscErrorCode PetscInt const PetscInt IS * is</div><div class="ttdef"><b>Definition:</b> <a href="petsc__dm__wrapper_8C_source.html#l00061">petsc_dm_wrapper.C:61</a></div></div>
<div class="ttc" id="structlibMesh_1_1WrappedPetsc_html"><div class="ttname"><a href="structlibMesh_1_1WrappedPetsc.html">libMesh::WrappedPetsc&lt; IS &gt;</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_a0e8748b2c01f78902c9c432ad79cf546"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">libMesh::DofObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00898">dof_object.h:898</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="accc819bc421fd8e50323b46f9762c714"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::set_node_processor_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is called after partitioning to set the processor IDs for the nodes. </p>
<p>By definition, a <a class="el" href="classlibMesh_1_1Node.html" title="A Node is like a Point, but with more information. ">Node</a>'s processor ID is the minimum processor ID for all of the elements which share the node. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00851">851</a> 行定义.</p>

<p>参考 <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a>, <a class="el" href="node_8C_source.html#l00078">libMesh::Node::choose_processor_id()</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="dof__object_8h_source.html#l00823">libMesh::DofObject::id()</a>, <a class="el" href="dof__object_8h_source.html#l00488">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="mesh__base_8h_source.html#l00201">libMesh::MeshBase::is_serial()</a>, <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>, <a class="el" href="mesh__communication_8C_source.html#l01308">mesh</a>, <a class="el" href="mesh__tools_8C_source.html#l00850">libMesh::MeshTools::n_elem()</a>, <a class="el" href="mesh__tools_8C_source.html#l00801">libMesh::MeshTools::n_levels()</a>, <a class="el" href="mesh__base_8h_source.html#l00571">libMesh::MeshBase::node_ref()</a>, <a class="el" href="libmesh_8C_source.html#l00872">libMesh::on_command_line()</a>, <a class="el" href="dof__object_8h_source.html#l00898">libMesh::DofObject::processor_id()</a>, <a class="el" href="partitioner_8C_source.html#l00656">libMesh::Partitioner::set_interface_node_processor_ids_BFS()</a>, <a class="el" href="partitioner_8C_source.html#l00631">libMesh::Partitioner::set_interface_node_processor_ids_linear()</a>, <a class="el" href="partitioner_8C_source.html#l00737">libMesh::Partitioner::set_interface_node_processor_ids_petscpartitioner()</a> , 以及 <a class="el" href="parallel__ghost__sync_8h_source.html#l00780">libMesh::Parallel::sync_node_data_by_element_id()</a>.</p>

<p>参考自 <a class="el" href="mesh__refinement_8C_source.html#l01468">libMesh::MeshRefinement::_refine_elements()</a>, <a class="el" href="unstructured__mesh_8C_source.html#l01130">libMesh::UnstructuredMesh::all_first_order()</a>, <a class="el" href="partitioner_8C_source.html#l00195">libMesh::Partitioner::partition()</a>, <a class="el" href="xdr__io_8C_source.html#l01420">libMesh::XdrIO::read()</a>, <a class="el" href="partitioner_8C_source.html#l00262">libMesh::Partitioner::repartition()</a> , 以及 <a class="el" href="boundary__info_8C_source.html#l00455">libMesh::BoundaryInfo::sync()</a>.</p>
<div class="fragment"><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;{</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;  LOG_SCOPE(<span class="stringliteral">&quot;set_node_processor_ids()&quot;</span>,<span class="stringliteral">&quot;Partitioner&quot;</span>);</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;  libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;  <span class="comment">// If we have any unpartitioned elements at this</span></div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;  <span class="comment">// stage there is a problem</span></div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a> (<a class="code" href="namespacelibMesh_1_1MeshTools.html#a20881e0b5de5ef63808dd24d90e70b2a">MeshTools::n_elem</a>(mesh.unpartitioned_elements_begin(),</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;                                    mesh.unpartitioned_elements_end()) == 0);</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;  <span class="comment">// Start from scratch here: nodes we used to own may not be</span></div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;  <span class="comment">// eligible for us to own any more.</span></div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : mesh.node_ptr_range())</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;    {</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;      node-&gt;processor_id() = <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>;</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;    }</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;  <span class="comment">// Loop over all the active elements</span></div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : mesh.active_element_ptr_range())</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;    {</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;      <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(elem);</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;      libmesh_assert_not_equal_to (elem-&gt;processor_id(), <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>);</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;      <span class="comment">// Consider updating the processor id on this element&#39;s nodes</span></div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="classlibMesh_1_1Node.html">Node</a> &amp; node : elem-&gt;node_ref_range())</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;        {</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;          <a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> &amp; pid = node.processor_id();</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;          pid = node.choose_processor_id(pid, elem-&gt;processor_id());</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;        }</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;    }</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;  <span class="comment">// How we finish off the node partitioning depends on our command</span></div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;  <span class="comment">// line options.</span></div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">bool</span> load_balanced_nodes_linear =</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;      <a class="code" href="namespacelibMesh.html#adc9fb0dafe70b50cd0848a8142cf57c0">libMesh::on_command_line</a> (<span class="stringliteral">&quot;--load-balanced-nodes-linear&quot;</span>);</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">bool</span> load_balanced_nodes_bfs =</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;       <a class="code" href="namespacelibMesh.html#adc9fb0dafe70b50cd0848a8142cf57c0">libMesh::on_command_line</a> (<span class="stringliteral">&quot;--load-balanced-nodes-bfs&quot;</span>);</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">bool</span> load_balanced_nodes_petscpartition =</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;      <a class="code" href="namespacelibMesh.html#adc9fb0dafe70b50cd0848a8142cf57c0">libMesh::on_command_line</a> (<span class="stringliteral">&quot;--load-balanced-nodes-petscpartitioner&quot;</span>);</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_load_balance_options = load_balanced_nodes_linear;</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;  n_load_balance_options += load_balanced_nodes_bfs;</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;  n_load_balance_options += load_balanced_nodes_petscpartition;</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;  libmesh_error_msg_if(n_load_balance_options &gt; 1,</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;                       <span class="stringliteral">&quot;Cannot perform more than one load balancing type at a time&quot;</span>);</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;  <span class="keywordflow">if</span> (load_balanced_nodes_linear)</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;    <a class="code" href="classlibMesh_1_1Partitioner.html#ae4517129393c07dfd490134e68136b42">set_interface_node_processor_ids_linear</a>(mesh);</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (load_balanced_nodes_bfs)</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;    <a class="code" href="classlibMesh_1_1Partitioner.html#a7130d717b7a9e09615cf8affc729b743">set_interface_node_processor_ids_BFS</a>(mesh);</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (load_balanced_nodes_petscpartition)</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;    <a class="code" href="classlibMesh_1_1Partitioner.html#a216c0efb66f5acc50dd15d9c6baf6311">set_interface_node_processor_ids_petscpartitioner</a>(mesh);</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;   <span class="comment">// Node balancing algorithm will response to assign owned nodes.</span></div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;   <span class="comment">// We still need to sync PIDs</span></div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;  {</div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;    <span class="comment">// For inactive elements, we will have already gotten most of</span></div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    <span class="comment">// these nodes, *except* for the case of a parent with a subset</span></div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <span class="comment">// of active descendants which are remote elements.  In that</span></div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;    <span class="comment">// case some of the parent nodes will not have been properly</span></div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;    <span class="comment">// handled yet on our processor.</span></div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;    <span class="comment">// We don&#39;t want to inadvertently give one of them an incorrect</span></div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;    <span class="comment">// processor id, but if we&#39;re not in serial then we have to</span></div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;    <span class="comment">// assign them temporary pids to make querying work, so we&#39;ll</span></div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;    <span class="comment">// save our *valid* pids before assigning temporaries.</span></div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;    <span class="comment">// Even in serial we&#39;ll want to check and make sure we&#39;re not</span></div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;    <span class="comment">// overwriting valid active node pids with pids from subactive</span></div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;    <span class="comment">// elements.</span></div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;    std::unordered_set&lt;dof_id_type&gt; bad_pids;</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : mesh.node_ptr_range())</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;      <span class="keywordflow">if</span> (node-&gt;processor_id() == <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>)</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;        bad_pids.insert(node-&gt;id());</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    <span class="comment">// If we assign our temporary ids by looping from finer elements</span></div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;    <span class="comment">// to coarser elements, we&#39;ll always get an id from the finest</span></div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;    <span class="comment">// ghost element we can see, which will usually be &quot;closer&quot; to</span></div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;    <span class="comment">// the true processor we want to query and so will reduce query</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;    <span class="comment">// cycles that don&#39;t reach that processor.</span></div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;    <span class="comment">// But we can still end up with a query cycle that dead-ends, so</span></div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    <span class="comment">// we need to prepare a &quot;push&quot; communication step here.</span></div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">bool</span> is_serial = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a3c7d22fed3feea4c9ebd1fb41e7dbb4f">is_serial</a>();</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    std::unordered_map</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;      &lt;<a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a>,</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;       std::unordered_map&lt;dof_id_type, processor_id_type&gt;&gt;</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;      potential_pids;</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">n_levels</a> = <a class="code" href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">MeshTools::n_levels</a>(mesh);</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = n_levels; level &gt; 0; --level)</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;      {</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(mesh.level_elements_begin(level-1),</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;                                    mesh.level_elements_end(level-1)))</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;          {</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;            libmesh_assert_not_equal_to (elem-&gt;processor_id(),</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;                                         <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>);</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;            <span class="keyword">const</span> processor_id_type elem_pid = elem-&gt;processor_id();</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;            <span class="comment">// Consider updating the processor id on this element&#39;s nodes</span></div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="classlibMesh_1_1Node.html">Node</a> &amp; node : elem-&gt;node_ref_range())</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;              {</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;                processor_id_type &amp; pid = node.processor_id();</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;                <span class="keywordflow">if</span> (bad_pids.count(node.id()))</div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;                  pid = node.choose_processor_id(pid, elem_pid);</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!is_serial)</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;                  potential_pids[elem_pid][node.id()] = pid;</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;              }</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;          }</div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;      }</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    <span class="keywordflow">if</span> (!is_serial)</div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;      {</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;        std::unordered_map</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;          &lt;<a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a>,</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;           std::vector&lt;std::pair&lt;dof_id_type, processor_id_type&gt;&gt;&gt;</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;          potential_pids_vecs;</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;</div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; pair : potential_pids)</div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;          potential_pids_vecs[pair.first].assign(pair.second.begin(), pair.second.end());</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;        <span class="keyword">auto</span> pids_action_functor =</div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;          [&amp; <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, &amp; bad_pids]</div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;          (processor_id_type <span class="comment">/* src_pid */</span>,</div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;           <span class="keyword">const</span> std::vector&lt;std::pair&lt;dof_id_type, processor_id_type&gt;&gt; &amp; data)</div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;          {</div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> pair : data)</div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;              {</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;                <a class="code" href="classlibMesh_1_1Node.html">Node</a> &amp; node = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">node_ref</a>(pair.first);</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;                processor_id_type &amp; pid = node.<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>();</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;                <span class="keyword">auto</span> it = bad_pids.find(pair.first);</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;                <span class="keywordflow">if</span> (it != bad_pids.end())</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;                  {</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;                    pid = pair.second;</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;                    bad_pids.erase(it);</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;                  }</div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;                  pid = node.<a class="code" href="classlibMesh_1_1Node.html#ae861c71635f1e57481c17ce9f977c058">choose_processor_id</a>(pid, pair.second);</div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;              }</div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;          };</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;</div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;        Parallel::push_parallel_vector_data</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;          (mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>(), potential_pids_vecs, pids_action_functor);</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;        <span class="comment">// Using default libMesh options, we&#39;ll just need to sync</span></div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;        <span class="comment">// between processors now.  The catch here is that we can&#39;t</span></div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;        <span class="comment">// initially trust Node::choose_processor_id() because some</span></div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;        <span class="comment">// of those node processor ids are the temporary ones.</span></div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;        CorrectProcIds correct_pids(mesh, bad_pids);</div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;        <a class="code" href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">Parallel::sync_node_data_by_element_id</a></div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;          (mesh, mesh.elements_begin(), mesh.elements_end(),</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;           <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(), <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(),</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;           correct_pids);</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;        <span class="comment">// But once we&#39;ve got all the non-temporary pids synced, we</span></div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;        <span class="comment">// may need to sync again to get any pids on nodes only</span></div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;        <span class="comment">// connected to subactive elements, for which *only*</span></div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;        <span class="comment">// &quot;temporary&quot; pids are possible.</span></div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;        bad_pids.clear();</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;        <a class="code" href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">Parallel::sync_node_data_by_element_id</a></div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;          (mesh,</div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;           mesh.elements_begin(), mesh.elements_end(),</div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;           <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(), <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(),</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;           correct_pids);</div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;      }</div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;  }</div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;</div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;  <span class="comment">// We can&#39;t assert that all nodes are connected to elements, because</span></div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;  <span class="comment">// a DistributedMesh with NodeConstraints might have pulled in some</span></div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;  <span class="comment">// remote nodes solely for evaluating those constraints.</span></div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;  <span class="comment">// MeshTools::libmesh_assert_connected_nodes(mesh);</span></div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;<span class="preprocessor"></span>  MeshTools::libmesh_assert_valid_procids&lt;Node&gt;(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;  <span class="comment">//MeshTools::libmesh_assert_canonical_node_procids(mesh);</span></div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;<span class="preprocessor"></span>}</div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a216c0efb66f5acc50dd15d9c6baf6311"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a216c0efb66f5acc50dd15d9c6baf6311">libMesh::Partitioner::set_interface_node_processor_ids_petscpartitioner</a></div><div class="ttdeci">static void set_interface_node_processor_ids_petscpartitioner(MeshBase &amp;mesh)</div><div class="ttdoc">Nodes on the partitioning interface is partitioned into two groups using a PETSc partitioner for each...</div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00737">partitioner.C:737</a></div></div>
<div class="ttc" id="classlibMesh_1_1Node_html"><div class="ttname"><a href="classlibMesh_1_1Node.html">libMesh::Node</a></div><div class="ttdoc">A Node is like a Point, but with more information. </div><div class="ttdef"><b>Definition:</b> <a href="node_8h_source.html#l00052">node.h:52</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a3c7d22fed3feea4c9ebd1fb41e7dbb4f"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a3c7d22fed3feea4c9ebd1fb41e7dbb4f">libMesh::MeshBase::is_serial</a></div><div class="ttdeci">virtual bool is_serial() const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00201">mesh_base.h:201</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_a7130d717b7a9e09615cf8affc729b743"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#a7130d717b7a9e09615cf8affc729b743">libMesh::Partitioner::set_interface_node_processor_ids_BFS</a></div><div class="ttdeci">static void set_interface_node_processor_ids_BFS(MeshBase &amp;mesh)</div><div class="ttdoc">Nodes on the partitioning interface is clustered into two groups BFS (Breadth First Search)scheme for...</div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00656">partitioner.C:656</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a20881e0b5de5ef63808dd24d90e70b2a"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a20881e0b5de5ef63808dd24d90e70b2a">libMesh::MeshTools::n_elem</a></div><div class="ttdeci">dof_id_type n_elem(const MeshBase::const_element_iterator &amp;begin, const MeshBase::const_element_iterator &amp;end)</div><div class="ttdoc">Count up the number of elements of a specific type (as defined by an iterator range). </div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00850">mesh_tools.C:850</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_af6e7cea860ccee9625012f9fcb0ae13b"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">libMesh::MeshBase::node_ref</a></div><div class="ttdeci">virtual const Node &amp; node_ref(const dof_id_type i) const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00571">mesh_base.h:571</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_ae4517129393c07dfd490134e68136b42"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#ae4517129393c07dfd490134e68136b42">libMesh::Partitioner::set_interface_node_processor_ids_linear</a></div><div class="ttdeci">static void set_interface_node_processor_ids_linear(MeshBase &amp;mesh)</div><div class="ttdoc">Nodes on the partitioning interface is linearly assigned to each pair of processors. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00631">partitioner.C:631</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af18245d4f872c36a41fc74086bda3e80"><div class="ttname"><a href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00104">id_types.h:104</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdoc">An invalid processor_id to distinguish DoFs that have not been assigned to a processor. </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00488">dof_object.h:488</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a78a93cd4ce160f40c758f96e2cadbe25"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">libMesh::Parallel::sync_node_data_by_element_id</a></div><div class="ttdeci">void sync_node_data_by_element_id(MeshBase &amp;mesh, const MeshBase::const_element_iterator &amp;range_begin, const MeshBase::const_element_iterator &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</div><div class="ttdoc">Synchronize data about a range of ghost nodes uniquely identified by an element id and local node id...</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00780">parallel_ghost_sync.h:780</a></div></div>
<div class="ttc" id="structlibMesh_1_1Parallel_1_1SyncEverything_html"><div class="ttname"><a href="structlibMesh_1_1Parallel_1_1SyncEverything.html">libMesh::Parallel::SyncEverything</a></div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00225">parallel_ghost_sync.h:225</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a6775c045a6c8e84299b5467df9fc81ae"><div class="ttname"><a href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; IndexType &gt; as_range(const std::pair&lt; IndexType, IndexType &gt; &amp;p)</div><div class="ttdoc">Helper function that allows us to treat a homogenous pair as a range. </div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ae15ece869d4ef3d283edb677942e8439"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">libMesh::MeshTools::n_levels</a></div><div class="ttdeci">unsigned int n_levels(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00801">mesh_tools.C:801</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1Node_html_ae861c71635f1e57481c17ce9f977c058"><div class="ttname"><a href="classlibMesh_1_1Node.html#ae861c71635f1e57481c17ce9f977c058">libMesh::Node::choose_processor_id</a></div><div class="ttdeci">processor_id_type choose_processor_id(processor_id_type pid1, processor_id_type pid2) const </div><div class="ttdoc">Return which of pid1 and pid2 would be preferred by the current load-balancing heuristic applied to t...</div><div class="ttdef"><b>Definition:</b> <a href="node_8C_source.html#l00078">node.C:78</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="namespacelibMesh_html_adc9fb0dafe70b50cd0848a8142cf57c0"><div class="ttname"><a href="namespacelibMesh.html#adc9fb0dafe70b50cd0848a8142cf57c0">libMesh::on_command_line</a></div><div class="ttdeci">bool on_command_line(std::string arg)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh_8C_source.html#l00872">libmesh.C:872</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_a0e8748b2c01f78902c9c432ad79cf546"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">libMesh::DofObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00898">dof_object.h:898</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a335c032a3e387485a7210ec806681c1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Partitioner::set_parent_processor_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is called after partitioning to set the processor IDs for the inactive parent elements. </p>
<p>A parent's processor ID is the same as its first child. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00425">425</a> 行定义.</p>

<p>参考 <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a>, <a class="el" href="elem_8h_source.html#l02164">libMesh::Elem::child_ref_range()</a>, <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="partitioner_8h_source.html#l00258">libMesh::Partitioner::communication_blocksize</a>, <a class="el" href="dof__object_8h_source.html#l00488">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="dof__object_8h_source.html#l00775">libMesh::DofObject::invalidate_processor_id()</a>, <a class="el" href="mesh__base_8h_source.html#l00201">libMesh::MeshBase::is_serial()</a>, <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>, <a class="el" href="libmesh__common_8h_source.html#l00516">libMesh::libmesh_ignore()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a807e5541b5e0608c8847daf6f3ffc1cf">libMesh::MeshBase::max_elem_id()</a>, <a class="el" href="mesh__tools_8C_source.html#l00850">libMesh::MeshTools::n_elem()</a>, <a class="el" href="elem_8h_source.html#l02843">libMesh::Elem::parent()</a>, <a class="el" href="dof__object_8h_source.html#l00898">libMesh::DofObject::processor_id()</a> , 以及 <a class="el" href="elem_8C_source.html#l01739">libMesh::Elem::total_family_tree()</a>.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l00195">libMesh::Partitioner::partition()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00262">libMesh::Partitioner::repartition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;{</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;  <span class="comment">// Ignore the parameter when !LIBMESH_ENABLE_AMR</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;  <a class="code" href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libmesh_ignore</a>(mesh);</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;  LOG_SCOPE(<span class="stringliteral">&quot;set_parent_processor_ids()&quot;</span>, <span class="stringliteral">&quot;Partitioner&quot;</span>);</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_AMR</span></div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;  <span class="comment">// If the mesh is serial we have access to all the elements,</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;  <span class="comment">// in particular all the active ones.  We can therefore set</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  <span class="comment">// the parent processor ids indirectly through their children, and</span></div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;  <span class="comment">// set the subactive processor ids while examining their active</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;  <span class="comment">// ancestors.</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;  <span class="comment">// By convention a parent is assigned to the minimum processor</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  <span class="comment">// of all its children, and a subactive is assigned to the processor</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  <span class="comment">// of its active ancestor.</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  <span class="keywordflow">if</span> (mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a3c7d22fed3feea4c9ebd1fb41e7dbb4f">is_serial</a>())</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    {</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : mesh.active_element_ptr_range())</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        {</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;          <span class="comment">// First set descendents</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;          std::vector&lt;Elem *&gt; subactive_family;</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;          elem-&gt;total_family_tree(subactive_family);</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; f : subactive_family)</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;            f-&gt;processor_id() = elem-&gt;processor_id();</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;          <span class="comment">// Then set ancestors</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;          <a class="code" href="classlibMesh_1_1Elem.html">Elem</a> * parent = elem-&gt;<a class="code" href="classlibMesh_1_1Elem.html#a7cdd994bb4245128f8617b62d7968e35">parent</a>();</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;          <span class="keywordflow">while</span> (parent)</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;            {</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;              <span class="comment">// invalidate the parent id, otherwise the min below</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;              <span class="comment">// will not work if the current parent id is less</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;              <span class="comment">// than all the children!</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;              parent-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#a080a5295fc4a41c1ab776a1a38c4be8d">invalidate_processor_id</a>();</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;              <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; child : parent-&gt;<a class="code" href="classlibMesh_1_1Elem.html#a9679723bb43c2f9264e22351467c9655">child_ref_range</a>())</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;                {</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;                  <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(!child.is_remote());</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;                  libmesh_assert_not_equal_to (child.processor_id(), <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>);</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;                  parent-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>() = std::min(parent-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>(),</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;                                                    child.processor_id());</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;                }</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;              parent = parent-&gt;<a class="code" href="classlibMesh_1_1Elem.html#a7cdd994bb4245128f8617b62d7968e35">parent</a>();</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;            }</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        }</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    }</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;  <span class="comment">// When the mesh is parallel we cannot guarantee that parents have access to</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  <span class="comment">// all their children.</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    {</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;      <span class="comment">// Setting subactive processor ids is easy: we can guarantee</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;      <span class="comment">// that children have access to all their parents.</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;      <span class="comment">// Loop over all the active elements in the mesh</span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; child : mesh.active_element_ptr_range())</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        {</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;          std::vector&lt;Elem *&gt; subactive_family;</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;          child-&gt;<a class="code" href="classlibMesh_1_1Elem.html#a1306f63d92eb41b6237cba0f1f791cc3">total_family_tree</a>(subactive_family);</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; f : subactive_family)</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;            f-&gt;processor_id() = child-&gt;processor_id();</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        }</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;      <span class="comment">// When the mesh is parallel we cannot guarantee that parents have access to</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;      <span class="comment">// all their children.</span></div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;      <span class="comment">// We will use a brute-force approach here.  Each processor finds its parent</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;      <span class="comment">// elements and sets the parent pid to the minimum of its</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;      <span class="comment">// semilocal descendants.</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;      <span class="comment">// A global reduction is then performed to make sure the true minimum is found.</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;      <span class="comment">// As noted, this is required because we cannot guarantee that a parent has</span></div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;      <span class="comment">// access to all its children on any single processor.</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;      libmesh_parallel_only(mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>());</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;      <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(<a class="code" href="namespacelibMesh_1_1MeshTools.html#a20881e0b5de5ef63808dd24d90e70b2a">MeshTools::n_elem</a>(mesh.unpartitioned_elements_begin(),</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                                       mesh.unpartitioned_elements_end()) == 0);</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> max_elem_id = mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a807e5541b5e0608c8847daf6f3ffc1cf">max_elem_id</a>();</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;      std::vector&lt;processor_id_type&gt;</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        parent_processor_ids (std::min(<a class="code" href="classlibMesh_1_1Partitioner.html#aeef033efe6d3a102444c47700d0ddab6">communication_blocksize</a>,</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                                       max_elem_id));</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> blk=0, last_elem_id=0; last_elem_id&lt;max_elem_id; blk++)</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        {</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;          last_elem_id =</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;            std::min(static_cast&lt;dof_id_type&gt;((blk+1)*<a class="code" href="classlibMesh_1_1Partitioner.html#aeef033efe6d3a102444c47700d0ddab6">communication_blocksize</a>),</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                     max_elem_id);</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> first_elem_id = blk*<a class="code" href="classlibMesh_1_1Partitioner.html#aeef033efe6d3a102444c47700d0ddab6">communication_blocksize</a>;</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;          std::fill (parent_processor_ids.begin(),</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;                     parent_processor_ids.end(),</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;                     <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>);</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;          <span class="comment">// first build up local contributions to parent_processor_ids</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;          <span class="keywordtype">bool</span> have_parent_in_block = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; parent : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(mesh.ancestor_elements_begin(),</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;                                        mesh.ancestor_elements_end()))</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;            {</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> parent_idx = parent-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#aeceebf9cd5d53b02df3cd1e9907139e2">id</a>();</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;              libmesh_assert_less (parent_idx, max_elem_id);</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;              <span class="keywordflow">if</span> ((parent_idx &gt;= first_elem_id) &amp;&amp;</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                  (parent_idx &lt;  last_elem_id))</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                {</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;                  have_parent_in_block = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;                  <a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> parent_pid = <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>;</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;                  std::vector&lt;const Elem *&gt; active_family;</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;                  parent-&gt;<a class="code" href="classlibMesh_1_1Elem.html#a8aa8d3ae40d28bc77aeac305bd9f4fcb">active_family_tree</a>(active_family);</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; f : active_family)</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;                    parent_pid = std::min (parent_pid, f-&gt;processor_id());</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;                  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> packed_idx = parent_idx - first_elem_id;</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;                  libmesh_assert_less (packed_idx, parent_processor_ids.size());</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                  parent_processor_ids[packed_idx] = parent_pid;</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                }</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;            }</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;          <span class="comment">// then find the global minimum</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;          mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>().min (parent_processor_ids);</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;          <span class="comment">// and assign the ids, if we have a parent in this block.</span></div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;          <span class="keywordflow">if</span> (have_parent_in_block)</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; parent : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(mesh.ancestor_elements_begin(),</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;                                          mesh.ancestor_elements_end()))</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;              {</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;                <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> parent_idx = parent-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#aeceebf9cd5d53b02df3cd1e9907139e2">id</a>();</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;                <span class="keywordflow">if</span> ((parent_idx &gt;= first_elem_id) &amp;&amp;</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;                    (parent_idx &lt;  last_elem_id))</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;                  {</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;                    <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> packed_idx = parent_idx - first_elem_id;</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;                    libmesh_assert_less (packed_idx, parent_processor_ids.size());</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;                    <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> parent_pid =</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                      parent_processor_ids[packed_idx];</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                    libmesh_assert_not_equal_to (parent_pid, <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>);</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                    parent-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>() = parent_pid;</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;                  }</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;              }</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;        }</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;    }</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="preprocessor">#endif // LIBMESH_ENABLE_AMR</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="preprocessor"></span>}</div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a3c7d22fed3feea4c9ebd1fb41e7dbb4f"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a3c7d22fed3feea4c9ebd1fb41e7dbb4f">libMesh::MeshBase::is_serial</a></div><div class="ttdeci">virtual bool is_serial() const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00201">mesh_base.h:201</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a20881e0b5de5ef63808dd24d90e70b2a"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a20881e0b5de5ef63808dd24d90e70b2a">libMesh::MeshTools::n_elem</a></div><div class="ttdeci">dof_id_type n_elem(const MeshBase::const_element_iterator &amp;begin, const MeshBase::const_element_iterator &amp;end)</div><div class="ttdoc">Count up the number of elements of a specific type (as defined by an iterator range). </div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00850">mesh_tools.C:850</a></div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html_a8aa8d3ae40d28bc77aeac305bd9f4fcb"><div class="ttname"><a href="classlibMesh_1_1Elem.html#a8aa8d3ae40d28bc77aeac305bd9f4fcb">libMesh::Elem::active_family_tree</a></div><div class="ttdeci">void active_family_tree(std::vector&lt; const Elem * &gt; &amp;active_family, bool reset=true) const </div><div class="ttdoc">Same as the family_tree() member, but only adds the active children. </div><div class="ttdef"><b>Definition:</b> <a href="elem_8C_source.html#l01755">elem.C:1755</a></div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html_a7cdd994bb4245128f8617b62d7968e35"><div class="ttname"><a href="classlibMesh_1_1Elem.html#a7cdd994bb4245128f8617b62d7968e35">libMesh::Elem::parent</a></div><div class="ttdeci">const Elem * parent() const </div><div class="ttdef"><b>Definition:</b> <a href="elem_8h_source.html#l02843">elem.h:2843</a></div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html"><div class="ttname"><a href="classlibMesh_1_1Elem.html">libMesh::Elem</a></div><div class="ttdoc">This is the base class from which all geometric element types are derived. </div><div class="ttdef"><b>Definition:</b> <a href="elem_8h_source.html#l00094">elem.h:94</a></div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html_a1306f63d92eb41b6237cba0f1f791cc3"><div class="ttname"><a href="classlibMesh_1_1Elem.html#a1306f63d92eb41b6237cba0f1f791cc3">libMesh::Elem::total_family_tree</a></div><div class="ttdeci">void total_family_tree(std::vector&lt; const Elem * &gt; &amp;family, bool reset=true) const </div><div class="ttdoc">Same as the family_tree() member, but also adds any subactive descendants. </div><div class="ttdef"><b>Definition:</b> <a href="elem_8C_source.html#l01739">elem.C:1739</a></div></div>
<div class="ttc" id="namespacelibMesh_html_af18245d4f872c36a41fc74086bda3e80"><div class="ttname"><a href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00104">id_types.h:104</a></div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html_a9679723bb43c2f9264e22351467c9655"><div class="ttname"><a href="classlibMesh_1_1Elem.html#a9679723bb43c2f9264e22351467c9655">libMesh::Elem::child_ref_range</a></div><div class="ttdeci">SimpleRange&lt; ChildRefIter &gt; child_ref_range()</div><div class="ttdoc">Returns a range with all children of a parent element, usable in range-based for loops. </div><div class="ttdef"><b>Definition:</b> <a href="elem_8h_source.html#l02164">elem.h:2164</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a43f45640aab1af26176e69592c666432"><div class="ttname"><a href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libMesh::libmesh_ignore</a></div><div class="ttdeci">void libmesh_ignore(const Args &amp;...)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00516">libmesh_common.h:516</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdoc">An invalid processor_id to distinguish DoFs that have not been assigned to a processor. </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00488">dof_object.h:488</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a6775c045a6c8e84299b5467df9fc81ae"><div class="ttname"><a href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; IndexType &gt; as_range(const std::pair&lt; IndexType, IndexType &gt; &amp;p)</div><div class="ttdoc">Helper function that allows us to treat a homogenous pair as a range. </div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a807e5541b5e0608c8847daf6f3ffc1cf"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a807e5541b5e0608c8847daf6f3ffc1cf">libMesh::MeshBase::max_elem_id</a></div><div class="ttdeci">virtual dof_id_type max_elem_id() const =0</div></div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_a080a5295fc4a41c1ab776a1a38c4be8d"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#a080a5295fc4a41c1ab776a1a38c4be8d">libMesh::DofObject::invalidate_processor_id</a></div><div class="ttdeci">void invalidate_processor_id()</div><div class="ttdoc">Sets the processor id to invalid_processor_id. </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00775">dof_object.h:775</a></div></div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_aeef033efe6d3a102444c47700d0ddab6"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#aeef033efe6d3a102444c47700d0ddab6">libMesh::Partitioner::communication_blocksize</a></div><div class="ttdeci">static const dof_id_type communication_blocksize</div><div class="ttdoc">The blocksize to use when doing blocked parallel communication. </div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8h_source.html#l00258">partitioner.h:258</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aeceebf9cd5d53b02df3cd1e9907139e2"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aeceebf9cd5d53b02df3cd1e9907139e2">libMesh::DofObject::id</a></div><div class="ttdeci">dof_id_type id() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00823">dof_object.h:823</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00067">id_types.h:67</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_a0e8748b2c01f78902c9c432ad79cf546"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">libMesh::DofObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00898">dof_object.h:898</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0fd1901649390e0e67d507a4b546a6d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::Partitioner::single_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trivially "partitions" the mesh for one processor. </p>
<p>Simply loops through the elements and assigns all of them to processor 0. Is is provided as a separate function so that derived classes may use it without reimplementing it.</p>
<p>Returns <code>true</code> iff any processor id was changed. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00297">297</a> 行定义.</p>

<p>参考 <a class="el" href="parallel__object_8h_source.html#l00097">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__base_8C_source.html#l00923">libMesh::MeshBase::redistribute()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00319">libMesh::Partitioner::single_partition_range()</a>.</p>

<p>参考自 <a class="el" href="subdomain__partitioner_8C_source.html#l00049">_do_partition()</a>, <a class="el" href="partitioner_8C_source.html#l00195">libMesh::Partitioner::partition()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00262">libMesh::Partitioner::repartition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;{</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  <span class="keywordtype">bool</span> changed_pid =</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    this-&gt;<a class="code" href="classlibMesh_1_1Partitioner.html#af26347358c79d17b006320e702f8bff4">single_partition_range</a>(mesh.elements_begin(),</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                                 mesh.elements_end());</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;  <span class="comment">// If we have a distributed mesh with an empty rank (or where rank</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;  <span class="comment">// 0 has only its own component of a disconnected mesh, I guess),</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  <span class="comment">// that rank might need to be informed of a change.</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;  mesh.<a class="code" href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">comm</a>().max(changed_pid);</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;  <span class="comment">// We may need to redistribute, in case someone (like our unit</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  <span class="comment">// tests) is doing something silly (like moving a whole</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  <span class="comment">// already-distributed mesh back onto rank 0).</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  <span class="keywordflow">if</span> (changed_pid)</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    mesh.<a class="code" href="classlibMesh_1_1MeshBase.html#a3a449a50a596d89c88b0bc3624d30d01">redistribute</a>();</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;  <span class="keywordflow">return</span> changed_pid;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1Partitioner_html_af26347358c79d17b006320e702f8bff4"><div class="ttname"><a href="classlibMesh_1_1Partitioner.html#af26347358c79d17b006320e702f8bff4">libMesh::Partitioner::single_partition_range</a></div><div class="ttdeci">bool single_partition_range(MeshBase::element_iterator it, MeshBase::element_iterator end)</div><div class="ttdoc">Slightly generalized version of single_partition which acts on a range of elements defined by the pai...</div><div class="ttdef"><b>Definition:</b> <a href="partitioner_8C_source.html#l00319">partitioner.C:319</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a20de1180df21bdc9e6ca6151ed4ffda9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a20de1180df21bdc9e6ca6151ed4ffda9">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00097">parallel_object.h:97</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a3a449a50a596d89c88b0bc3624d30d01"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a3a449a50a596d89c88b0bc3624d30d01">libMesh::MeshBase::redistribute</a></div><div class="ttdeci">virtual void redistribute()</div><div class="ttdoc">Redistribute elements between processors. </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8C_source.html#l00923">mesh_base.C:923</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af26347358c79d17b006320e702f8bff4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::Partitioner::single_partition_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibMesh_1_1MeshBase_1_1element__iterator.html">MeshBase::element_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibMesh_1_1MeshBase_1_1element__iterator.html">MeshBase::element_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slightly generalized version of single_partition which acts on a range of elements defined by the pair of iterators (it, end). </p>
<p>Returns <code>true</code> iff any processor id was changed. </p>

<p>在文件 <a class="el" href="partitioner_8C_source.html">partitioner.C</a> 第 <a class="el" href="partitioner_8C_source.html#l00319">319</a> 行定义.</p>

<p>参考 <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a> , 以及 <a class="el" href="dof__object_8h_source.html#l00898">libMesh::DofObject::processor_id()</a>.</p>

<p>参考自 <a class="el" href="linear__partitioner_8C_source.html#l00036">libMesh::LinearPartitioner::partition_range()</a>, <a class="el" href="metis__partitioner_8C_source.html#l00068">libMesh::MetisPartitioner::partition_range()</a>, <a class="el" href="mapped__subdomain__partitioner_8C_source.html#l00038">libMesh::MappedSubdomainPartitioner::partition_range()</a>, <a class="el" href="sfc__partitioner_8C_source.html#l00048">libMesh::SFCPartitioner::partition_range()</a>, <a class="el" href="centroid__partitioner_8C_source.html#l00037">libMesh::CentroidPartitioner::partition_range()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l00297">libMesh::Partitioner::single_partition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;{</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  LOG_SCOPE(<span class="stringliteral">&quot;single_partition_range()&quot;</span>, <span class="stringliteral">&quot;Partitioner&quot;</span>);</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;  <span class="keywordtype">bool</span> changed_pid = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">as_range</a>(it, end))</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    {</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;      <span class="keywordflow">if</span> (elem-&gt;processor_id())</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        changed_pid = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;      elem-&gt;processor_id() = 0;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;      <span class="comment">// Assign all this element&#39;s nodes to processor 0 as well.</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="classlibMesh_1_1Node.html">Node</a> &amp; node : elem-&gt;node_ref_range())</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        {</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;          <span class="keywordflow">if</span> (node.processor_id())</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            changed_pid = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;          node.processor_id() = 0;</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        }</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    }</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;  <span class="keywordflow">return</span> changed_pid;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1Node_html"><div class="ttname"><a href="classlibMesh_1_1Node.html">libMesh::Node</a></div><div class="ttdoc">A Node is like a Point, but with more information. </div><div class="ttdef"><b>Definition:</b> <a href="node_8h_source.html#l00052">node.h:52</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a6775c045a6c8e84299b5467df9fc81ae"><div class="ttname"><a href="namespacelibMesh.html#a6775c045a6c8e84299b5467df9fc81ae">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; IndexType &gt; as_range(const std::pair&lt; IndexType, IndexType &gt; &amp;p)</div><div class="ttdoc">Helper function that allows us to treat a homogenous pair as a range. </div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aab4b600c3ee52b7add448356ecdf4e0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9">PartitionerType</a> libMesh::SubdomainPartitioner::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>重载 <a class="el" href="classlibMesh_1_1Partitioner.html#af3834966dc7e94fa14bdfcbbd30a7ac8">libMesh::Partitioner</a> .</p>

<p>在文件 <a class="el" href="subdomain__partitioner_8C_source.html">subdomain_partitioner.C</a> 第 <a class="el" href="subdomain__partitioner_8C_source.html#l00043">43</a> 行定义.</p>

<p>参考 <a class="el" href="enum__partitioner__type_8h_source.html#l00041">libMesh::SUBDOMAIN_PARTITIONER</a>.</p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;{</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9a5e20e43cab58b6f9800f24c31167f3d3">SUBDOMAIN_PARTITIONER</a>;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_html_a26aa013c1fc1e7715b23527abdd1b8b9a5e20e43cab58b6f9800f24c31167f3d3"><div class="ttname"><a href="namespacelibMesh.html#a26aa013c1fc1e7715b23527abdd1b8b9a5e20e43cab58b6f9800f24c31167f3d3">libMesh::SUBDOMAIN_PARTITIONER</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__partitioner__type_8h_source.html#l00041">enum_partitioner_type.h:41</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a class="anchor" id="a7a6af170d354795a9bbdb89f94b72325"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>&gt; &gt; libMesh::Partitioner::_dual_graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dual graph corresponds to the mesh, and it is typically used in paritioner. </p>
<p>A vertex represents an element, and its neighbors are the element neighbors. </p>

<p>在文件 <a class="el" href="partitioner_8h_source.html">partitioner.h</a> 第 <a class="el" href="partitioner_8h_source.html#l00302">302</a> 行定义.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l01111">libMesh::Partitioner::build_graph()</a>.</p>

</div>
</div>
<a class="anchor" id="a4af7f29e6040ed94dbfed8a8688e80b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>, <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>&gt; libMesh::Partitioner::_global_index_by_pid_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps active element ids into a contiguous range, as needed by parallel partitioner. </p>

<p>在文件 <a class="el" href="partitioner_8h_source.html">partitioner.h</a> 第 <a class="el" href="partitioner_8h_source.html#l00286">286</a> 行定义.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l01067">libMesh::Partitioner::_find_global_index_by_pid_map()</a>, <a class="el" href="partitioner_8C_source.html#l01334">libMesh::Partitioner::assign_partitioning()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l01111">libMesh::Partitioner::build_graph()</a>.</p>

</div>
</div>
<a class="anchor" id="abd9ee6417201fee9c219347d095b68f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1Partitioner.html">Partitioner</a>&gt; libMesh::SubdomainPartitioner::_internal_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a> we use. </p>
<p>Public access via the <a class="el" href="classlibMesh_1_1SubdomainPartitioner.html#a4843abeb1af6f4359f5cf5f7dcfa3ff3" title="Get a reference to the Partitioner used internally by the SubdomainPartitioner. ">internal_partitioner()</a> member function. </p>

<p>在文件 <a class="el" href="subdomain__partitioner_8h_source.html">subdomain_partitioner.h</a> 第 <a class="el" href="subdomain__partitioner_8h_source.html#l00122">122</a> 行定义.</p>

<p>参考自 <a class="el" href="subdomain__partitioner_8C_source.html#l00049">_do_partition()</a> , 以及 <a class="el" href="subdomain__partitioner_8h_source.html#l00115">internal_partitioner()</a>.</p>

</div>
</div>
<a class="anchor" id="af355eb8c855fc5442531490a04dfe7e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classlibMesh_1_1Elem.html">Elem</a> *&gt; libMesh::Partitioner::_local_id_to_elem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="partitioner_8h_source.html">partitioner.h</a> 第 <a class="el" href="partitioner_8h_source.html#l00305">305</a> 行定义.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l01111">libMesh::Partitioner::build_graph()</a>.</p>

</div>
</div>
<a class="anchor" id="a232c493ab22b03ee4fb068dcd4703fc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>&gt; libMesh::Partitioner::_n_active_elem_on_proc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of active elements on each processor. </p>
<dl class="section note"><dt>注解</dt><dd>ParMETIS requires that each processor have some active elements; it will abort if any processor passes a nullptr _part array. </dd></dl>

<p>在文件 <a class="el" href="partitioner_8h_source.html">partitioner.h</a> 第 <a class="el" href="partitioner_8h_source.html#l00295">295</a> 行定义.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l01067">libMesh::Partitioner::_find_global_index_by_pid_map()</a>, <a class="el" href="partitioner_8C_source.html#l01334">libMesh::Partitioner::assign_partitioning()</a> , 以及 <a class="el" href="partitioner_8C_source.html#l01111">libMesh::Partitioner::build_graph()</a>.</p>

</div>
</div>
<a class="anchor" id="a1701ba592caafda75ba383d04bf1a47e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a>* libMesh::Partitioner::_weights</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The weights that might be used for partitioning. </p>

<p>在文件 <a class="el" href="partitioner_8h_source.html">partitioner.h</a> 第 <a class="el" href="partitioner_8h_source.html#l00281">281</a> 行定义.</p>

<p>参考自 <a class="el" href="metis__partitioner_8h_source.html#l00065">libMesh::MetisPartitioner::attach_weights()</a> , 以及 <a class="el" href="metis__partitioner_8C_source.html#l00068">libMesh::MetisPartitioner::partition_range()</a>.</p>

</div>
</div>
<a class="anchor" id="a24b119263f03f3d23380be5ab324a4ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::set&lt;<a class="el" href="namespacelibMesh.html#a634d676f703fd1cf217d85d6794abcb3">subdomain_id_type</a>&gt; &gt; libMesh::SubdomainPartitioner::chunks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each entry of "chunks" represents a set of subdomains which are to be partitioned together. </p>
<p>The internal <a class="el" href="classlibMesh_1_1Partitioner.html" title="The Partitioner class provides a uniform interface for partitioning algorithms. ">Partitioner</a> will be called once for each entry of chunks, and the resulting partitioning will simply be the union of all these partitionings. </p>

<p>在文件 <a class="el" href="subdomain__partitioner_8h_source.html">subdomain_partitioner.h</a> 第 <a class="el" href="subdomain__partitioner_8h_source.html#l00099">99</a> 行定义.</p>

<p>参考自 <a class="el" href="subdomain__partitioner_8C_source.html#l00049">_do_partition()</a>.</p>

</div>
</div>
<a class="anchor" id="aeef033efe6d3a102444c47700d0ddab6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> libMesh::Partitioner::communication_blocksize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>初始值:</b><div class="fragment"><div class="line">=</div>
<div class="line">  <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>(1000000)</div>
</div><!-- fragment -->
<p>The blocksize to use when doing blocked parallel communication. </p>
<p>This limits the maximum vector size which can be used in a single communication step. </p>

<p>在文件 <a class="el" href="partitioner_8h_source.html">partitioner.h</a> 第 <a class="el" href="partitioner_8h_source.html#l00258">258</a> 行定义.</p>

<p>参考自 <a class="el" href="partitioner_8C_source.html#l00425">libMesh::Partitioner::set_parent_processor_ids()</a>.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>/home/lwz/libmesh/include/partitioning/<a class="el" href="subdomain__partitioner_8h_source.html">subdomain_partitioner.h</a></li>
<li>/home/lwz/libmesh/src/partitioning/<a class="el" href="subdomain__partitioner_8C_source.html">subdomain_partitioner.C</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2023年 十二月 20日 星期三 12:09:38 , 为 libmesh解析使用  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
