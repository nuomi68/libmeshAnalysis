<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libmesh解析: libMesh::GhostingFunctor类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libmesh解析
   </div>
   <div id="projectbrief">本工作只是尝试解析原libmesh的代码,供学习使用</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li class="current"><a href="annotated.html"><span>类</span></a></li>
      <li><a href="files.html"><span>文件</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>类列表</span></a></li>
      <li><a href="classes.html"><span>类索引</span></a></li>
      <li><a href="inherits.html"><span>类继承关系</span></a></li>
      <li><a href="functions.html"><span>类成员</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>全部</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>类</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>命名空间</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>文件</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>函数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>变量</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>类型定义</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>枚举</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>枚举值</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>友元</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>页</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1GhostingFunctor.html">GhostingFunctor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="#pro-types">Protected 类型</a> &#124;
<a href="#pro-methods">Protected 成员函数</a> &#124;
<a href="#pro-attribs">Protected 属性</a> &#124;
<a href="#pro-static-attribs">静态 Protected 属性</a> &#124;
<a href="classlibMesh_1_1GhostingFunctor-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::GhostingFunctor类 参考<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This abstract base class defines the interface by which library code and user code can report associations between elements.  
 <a href="classlibMesh_1_1GhostingFunctor.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a>&gt;</code></p>
<div class="dynheader">
类 libMesh::GhostingFunctor 继承关系图:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:a676b8f239d71a5a8d035d9f460bdde4f"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; const <a class="el" href="classlibMesh_1_1Elem.html">Elem</a> <br class="typebreak"/>
*, const CouplingMatrix <br class="typebreak"/>
*, <a class="el" href="structlibMesh_1_1CompareDofObjectsByPIDAndThenID.html">CompareDofObjectsByPIDAndThenID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#a676b8f239d71a5a8d035d9f460bdde4f">map_type</a></td></tr>
<tr class="memdesc:a676b8f239d71a5a8d035d9f460bdde4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">What elements do we care about and what variables do we care about on each element?  <a href="#a676b8f239d71a5a8d035d9f460bdde4f">更多...</a><br/></td></tr>
<tr class="separator:a676b8f239d71a5a8d035d9f460bdde4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:aef0e63dd4ee5b529fd48b14e187cb5ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#aef0e63dd4ee5b529fd48b14e187cb5ac">GhostingFunctor</a> ()</td></tr>
<tr class="memdesc:aef0e63dd4ee5b529fd48b14e187cb5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aef0e63dd4ee5b529fd48b14e187cb5ac">更多...</a><br/></td></tr>
<tr class="separator:aef0e63dd4ee5b529fd48b14e187cb5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f74e15c69b01d44136bf4115fa9f211"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#a3f74e15c69b01d44136bf4115fa9f211">GhostingFunctor</a> (const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:a3f74e15c69b01d44136bf4115fa9f211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using mesh.  <a href="#a3f74e15c69b01d44136bf4115fa9f211">更多...</a><br/></td></tr>
<tr class="separator:a3f74e15c69b01d44136bf4115fa9f211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecfc3529efaad282b001e37517ac369"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#a4ecfc3529efaad282b001e37517ac369">GhostingFunctor</a> (const <a class="el" href="classlibMesh_1_1GhostingFunctor.html">GhostingFunctor</a> &amp;other)</td></tr>
<tr class="memdesc:a4ecfc3529efaad282b001e37517ac369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor.  <a href="#a4ecfc3529efaad282b001e37517ac369">更多...</a><br/></td></tr>
<tr class="separator:a4ecfc3529efaad282b001e37517ac369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811e8617e92cbb6ba1de6c75743fe377"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#a811e8617e92cbb6ba1de6c75743fe377">~GhostingFunctor</a> ()=default</td></tr>
<tr class="memdesc:a811e8617e92cbb6ba1de6c75743fe377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor; this is an abstract base class.  <a href="#a811e8617e92cbb6ba1de6c75743fe377">更多...</a><br/></td></tr>
<tr class="separator:a811e8617e92cbb6ba1de6c75743fe377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9912966faed03725df1c4653a6dc005f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classlibMesh_1_1GhostingFunctor.html">GhostingFunctor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#a9912966faed03725df1c4653a6dc005f">clone</a> () const </td></tr>
<tr class="memdesc:a9912966faed03725df1c4653a6dc005f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classlibMesh_1_1GhostingFunctor.html#a9912966faed03725df1c4653a6dc005f" title="A clone() is needed because GhostingFunctor can not be shared between different meshes. ">clone()</a> is needed because <a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> can not be shared between different meshes.  <a href="#a9912966faed03725df1c4653a6dc005f">更多...</a><br/></td></tr>
<tr class="separator:a9912966faed03725df1c4653a6dc005f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d688b123d7c565e1a5ae136fb6a8300"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#a1d688b123d7c565e1a5ae136fb6a8300">set_mesh</a> (const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> *<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="memdesc:a1d688b123d7c565e1a5ae136fb6a8300"><td class="mdescLeft">&#160;</td><td class="mdescRight">It should be called after cloning a ghosting functor.  <a href="#a1d688b123d7c565e1a5ae136fb6a8300">更多...</a><br/></td></tr>
<tr class="separator:a1d688b123d7c565e1a5ae136fb6a8300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdadb619386f44eff9fd190fc491c5d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#abdadb619386f44eff9fd190fc491c5d1">set_periodic_boundaries</a> (const <a class="el" href="classlibMesh_1_1PeriodicBoundaries.html">PeriodicBoundaries</a> *)</td></tr>
<tr class="separator:abdadb619386f44eff9fd190fc491c5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3177b115c64145747de955ab9ab90c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#aba3177b115c64145747de955ab9ab90c">get_mesh</a> () const </td></tr>
<tr class="memdesc:aba3177b115c64145747de955ab9ab90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mesh associated with ghosting functor.  <a href="#aba3177b115c64145747de955ab9ab90c">更多...</a><br/></td></tr>
<tr class="separator:aba3177b115c64145747de955ab9ab90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39911ad4559e25383fd094be15cdfc1b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#a39911ad4559e25383fd094be15cdfc1b">operator()</a> (const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;range_begin, const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;range_end, <a class="el" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a> p, <a class="el" href="classlibMesh_1_1GhostingFunctor.html#a676b8f239d71a5a8d035d9f460bdde4f">map_type</a> &amp;coupled_elements)=0</td></tr>
<tr class="memdesc:a39911ad4559e25383fd094be15cdfc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the specified range of active elements, what other elements currently living (whether local or ghosted) on this processor need to be coupled/ghosted to accommodate them? Don't bother to return any results which already have processor_id p.  <a href="#a39911ad4559e25383fd094be15cdfc1b">更多...</a><br/></td></tr>
<tr class="separator:a39911ad4559e25383fd094be15cdfc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc49f77df76394153ae617a000bf128"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#acbc49f77df76394153ae617a000bf128">mesh_reinit</a> ()</td></tr>
<tr class="memdesc:acbc49f77df76394153ae617a000bf128"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> subclasses which cache data will need to initialize that cache.  <a href="#acbc49f77df76394153ae617a000bf128">更多...</a><br/></td></tr>
<tr class="separator:acbc49f77df76394153ae617a000bf128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9571e0c0ae41d4b133083071e7ce787"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#af9571e0c0ae41d4b133083071e7ce787">dofmap_reinit</a> ()</td></tr>
<tr class="memdesc:af9571e0c0ae41d4b133083071e7ce787"><td class="mdescLeft">&#160;</td><td class="mdescRight">For algebraic ghosting or coupling functors we also call <a class="el" href="classlibMesh_1_1GhostingFunctor.html#af9571e0c0ae41d4b133083071e7ce787" title="For algebraic ghosting or coupling functors we also call dofmap_reinit() later, after dofs have been ...">dofmap_reinit()</a> later, after dofs have been distributed on the new mesh but before the functors have been queried for send_list or sparsity pattern calculations.  <a href="#af9571e0c0ae41d4b133083071e7ce787">更多...</a><br/></td></tr>
<tr class="separator:af9571e0c0ae41d4b133083071e7ce787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4502085eaa26f29a36cc008d4c5015"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#a2f4502085eaa26f29a36cc008d4c5015">redistribute</a> ()</td></tr>
<tr class="memdesc:a2f4502085eaa26f29a36cc008d4c5015"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> subclasses with relatively long-lasting caches may want to redistribute those caches whenever the relevant <a class="el" href="classlibMesh_1_1Mesh.html" title="The Mesh class is a thin wrapper, around the ReplicatedMesh class by default. ">Mesh</a> is redistributed; we will give them an opportunity when that happens.  <a href="#a2f4502085eaa26f29a36cc008d4c5015">更多...</a><br/></td></tr>
<tr class="separator:a2f4502085eaa26f29a36cc008d4c5015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eab28bbe2da68e6b8197b85ee811e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#a39eab28bbe2da68e6b8197b85ee811e1">delete_remote_elements</a> ()</td></tr>
<tr class="memdesc:a39eab28bbe2da68e6b8197b85ee811e1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> subclasses with relatively long-lasting caches may want to delete the no-longer-relevant parts of those caches after a redistribution is complete.  <a href="#a39eab28bbe2da68e6b8197b85ee811e1">更多...</a><br/></td></tr>
<tr class="separator:a39eab28bbe2da68e6b8197b85ee811e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:a103b37125ae9eaaadf6f7854df17faa2"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a103b37125ae9eaaadf6f7854df17faa2">get_info</a> ()</td></tr>
<tr class="memdesc:a103b37125ae9eaaadf6f7854df17faa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string containing the reference information.  <a href="#a103b37125ae9eaaadf6f7854df17faa2">更多...</a><br/></td></tr>
<tr class="separator:a103b37125ae9eaaadf6f7854df17faa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ce734a14ffd1dbb6496dab702da8e1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a13ce734a14ffd1dbb6496dab702da8e1">print_info</a> (std::ostream &amp;out_stream=<a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a>)</td></tr>
<tr class="memdesc:a13ce734a14ffd1dbb6496dab702da8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the reference information, by default to <code><a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></code>.  <a href="#a13ce734a14ffd1dbb6496dab702da8e1">更多...</a><br/></td></tr>
<tr class="separator:a13ce734a14ffd1dbb6496dab702da8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e74641afc6e2870c9e1ce412f8c44f"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a50e74641afc6e2870c9e1ce412f8c44f">n_objects</a> ()</td></tr>
<tr class="memdesc:a50e74641afc6e2870c9e1ce412f8c44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the number of outstanding (created, but not yet destroyed) objects.  <a href="#a50e74641afc6e2870c9e1ce412f8c44f">更多...</a><br/></td></tr>
<tr class="separator:a50e74641afc6e2870c9e1ce412f8c44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86837c50216b2ddb800b3836d2a08c09"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a86837c50216b2ddb800b3836d2a08c09">enable_print_counter_info</a> ()</td></tr>
<tr class="memdesc:a86837c50216b2ddb800b3836d2a08c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods to enable/disable the reference counter output from <a class="el" href="classlibMesh_1_1ReferenceCounter.html#a13ce734a14ffd1dbb6496dab702da8e1" title="Prints the reference information, by default to libMesh::out. ">print_info()</a>  <a href="#a86837c50216b2ddb800b3836d2a08c09">更多...</a><br/></td></tr>
<tr class="separator:a86837c50216b2ddb800b3836d2a08c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0a2d3d3c531f9f069b0d623d4ace0f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a5c0a2d3d3c531f9f069b0d623d4ace0f">disable_print_counter_info</a> ()</td></tr>
<tr class="separator:a5c0a2d3d3c531f9f069b0d623d4ace0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected 类型</h2></td></tr>
<tr class="memitem:adb5daadc989c1fe71ec8d173adf0ed1e"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
std::pair&lt; unsigned int, <br class="typebreak"/>
unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#adb5daadc989c1fe71ec8d173adf0ed1e">Counts</a></td></tr>
<tr class="memdesc:adb5daadc989c1fe71ec8d173adf0ed1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to log the information.  <a href="#adb5daadc989c1fe71ec8d173adf0ed1e">更多...</a><br/></td></tr>
<tr class="separator:adb5daadc989c1fe71ec8d173adf0ed1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected 成员函数</h2></td></tr>
<tr class="memitem:af0cd2f1fbd46c66dade1e750436ee7ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#af0cd2f1fbd46c66dade1e750436ee7ab">increment_constructor_count</a> (const std::string &amp;name) noexcept</td></tr>
<tr class="memdesc:af0cd2f1fbd46c66dade1e750436ee7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the construction counter.  <a href="#af0cd2f1fbd46c66dade1e750436ee7ab">更多...</a><br/></td></tr>
<tr class="separator:af0cd2f1fbd46c66dade1e750436ee7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769ddb2e2299db1aafcdfb33dfb830d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a769ddb2e2299db1aafcdfb33dfb830d8">increment_destructor_count</a> (const std::string &amp;name) noexcept</td></tr>
<tr class="memdesc:a769ddb2e2299db1aafcdfb33dfb830d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the destruction counter.  <a href="#a769ddb2e2299db1aafcdfb33dfb830d8">更多...</a><br/></td></tr>
<tr class="separator:a769ddb2e2299db1aafcdfb33dfb830d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected 属性</h2></td></tr>
<tr class="memitem:ad7380df13e94d2651ff2eb3941a408f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">_mesh</a></td></tr>
<tr class="separator:ad7380df13e94d2651ff2eb3941a408f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
静态 Protected 属性</h2></td></tr>
<tr class="memitem:a7c913252d05560f8bc7c75a63547c4c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlibMesh_1_1ReferenceCounter.html#adb5daadc989c1fe71ec8d173adf0ed1e">Counts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">_counts</a></td></tr>
<tr class="memdesc:a7c913252d05560f8bc7c75a63547c4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually holds the data.  <a href="#a7c913252d05560f8bc7c75a63547c4c3">更多...</a><br/></td></tr>
<tr class="separator:a7c913252d05560f8bc7c75a63547c4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c30f0f71dcd00f00faa8e46aa3e043"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlibMesh_1_1Threads_1_1atomic.html">Threads::atomic</a><br class="typebreak"/>
&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#ad2c30f0f71dcd00f00faa8e46aa3e043">_n_objects</a></td></tr>
<tr class="memdesc:ad2c30f0f71dcd00f00faa8e46aa3e043"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of objects.  <a href="#ad2c30f0f71dcd00f00faa8e46aa3e043">更多...</a><br/></td></tr>
<tr class="separator:ad2c30f0f71dcd00f00faa8e46aa3e043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedbd3a4ce19686187449a8a0557b74b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlibMesh_1_1Threads_1_1spin__mutex.html">Threads::spin_mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#abedbd3a4ce19686187449a8a0557b74b">_mutex</a></td></tr>
<tr class="memdesc:abedbd3a4ce19686187449a8a0557b74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutual exclusion object to enable thread-safe reference counting.  <a href="#abedbd3a4ce19686187449a8a0557b74b">更多...</a><br/></td></tr>
<tr class="separator:abedbd3a4ce19686187449a8a0557b74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f75e8a4a280f2c41636f2ae1307a311"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">_enable_print_counter</a> = true</td></tr>
<tr class="memdesc:a8f75e8a4a280f2c41636f2ae1307a311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to control whether reference count information is printed when print_info is called.  <a href="#a8f75e8a4a280f2c41636f2ae1307a311">更多...</a><br/></td></tr>
<tr class="separator:a8f75e8a4a280f2c41636f2ae1307a311"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>This abstract base class defines the interface by which library code and user code can report associations between elements. </p>
<p>These associations between elements may be used to keep copies of non-local elements retained on a distributed mesh, may be used to keep element degrees of freedom properly communicated on a distributed vector, and/or may be used to insert coupling entries between elements' degrees of freedom to a sparsity matrix.</p>
<p>We can think of three levels of "element dependencies". An element K1 has a coupling dependency on K2 if the dofs on K1 might (modulo the coupling matrix) need sparsity pattern entries for dofs on K2. An element K1 has an algebraic dependency on K2 if a processor which owns K1 might need to examine the solution dof values on K2. An element K1 has a geometric dependency on K2 if a processor which owns K1 might need to examine the geometry of K2. For any element K, we could call the set of coupling-ghosted ("coupled") elements C(K), call the set of algebraic-ghosted ("evaluable") elements E(K), and call the set of geometry-ghosted ("ghosted") elements G(K).</p>
<p>It should be safe to assume that, for any element K, C(K) implies E(K) implies G(K). These will be one-way implications in some problems and equality relations in others.</p>
<p>We can think of these as operators on sets of elements in the obvious way, e.g.: G({K}) = {G(Ki) for all Ki in {K}}.</p>
<p>The user should omit from their implementations relations which we already have enough information to understand implicitly. For instance, K is obviously in C(K), so a <a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> should never bother telling us so. We pass a processor_id_type parameter to the GhostingFunctor::operator(), e.g. when determining what ghosted elements need to be sent to that processor while redistributing, and a <a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> should not return any elements which already have that processor_id. We determine what ancestor elements should be ghosted based on what active elements are being ghosted, and a <a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> should not return any elements which are not active.</p>
<p>We may have a <a class="el" href="classlibMesh_1_1PeriodicBoundary.html" title="The definition of a periodic boundary. ">PeriodicBoundary</a>, a hanging node constraint equation, or a user-defined constraint equation which creates a dependency between two elements; if so then we don't need the user to also tell us about that relation. The <a class="el" href="classlibMesh_1_1DefaultCoupling.html" title="This class implements the default algebraic coupling in libMesh: elements couple to themselves...">DefaultCoupling</a> functor will make both direct and periodic neighbor elements algebraically ghosted by default.</p>
<p>However, note that geometric ghosting information needs to all be inferrable (e.g. with <a class="el" href="classlibMesh_1_1PeriodicBoundary.html" title="The definition of a periodic boundary. ">PeriodicBoundary</a> objects already all attached) <em>before</em> a mesh is prepared for use; otherwise ghost elements may be prematurely deleted and become unrecoverable.</p>
<p>For iterating over ghosted elements:</p>
<p>MeshBase::active_elements_begin() gives the first iterator to all geometrically ghosted elements. (this means all elements on any mesh which isn't distributed)</p>
<p>MeshBase::evaluable_elements_begin() gives the first iterator to all algebraically evaluable elements, which is a superset of all algebraically ghosted elements. (rarely a strict superset, but low order geometrically ghosted elements surrounded by enough algebraically ghosted elements may become evaluable "by accident")</p>
<p>Users may only care about a subset of variables in distant evaluable elements, so we could imagine defining E_v(K) for each variable number v, in which case E(K) under our previous definition is the union of E_v(K) forall v, and this is what would be included in G(K) when deciding what to ghost, but our send_list would only include the subset of variables we need, so communication and memory use would be much reduced. However, for efficiency and API simplicity, we instead define the isomorphic operator E'(K) which gives a set of ordered pairs of elements and variable-number-sets, from which a consistent E(K) would be derived by ignoring the variable-number-sets.</p>
<p>For C(K), there are similar issues: e.g. we may want some discontinuous variables to couple only within their own element but other discontinuous variables to couple in a DG/FVM way. This could extend to more than one variable index: i.e. a dof for variable v1 in element K1 would depend on a dof for variable v2 in element K2 iff K2 is in C_v1_v2(K1). This would induce a consistent E_v(K) = union of C_w_v(K) forall variable indices w. Again, the equivalent API alternative we use here is for C'(K) to return a set of ordered pairs of elements and variable-number-pair-sets.</p>
<p>We return variable-stuff-sets as pointers to CouplingMatrix. That way, in the common case where the user cares about all variables and couple to all variables, all the functor needs to return for variable-number-sets and variable-number-pair-sets is nullptr (which as in other <a class="el" href="namespacelibMesh.html" title="The libMesh namespace provides an interface to certain functionality in the library. ">libMesh</a> APIs will be interpreted and documented to mean the full set). In the common case where the user wants coupling between elements to match coupling within elements, the functor can return the same pointer as DofMap::_coupling_matrix. Even in the less common cases, the user can store common variable-number-sets and variable-number-pair sets as CouplingMatrix members of a functor object of their subclass, and setting up a few of those matrices then setting lots of those pointers is cheap.</p>
<p>The definition of the CouplingMatrix for a variable-dependent E' should be consistent with the requirements that would have been imposed had that matrix been used for a C'. In other words, if the returned CouplingMatrix CM has CM(i,j)==true for any i, then variable j will be evaluable on the algebraically ghosted element.</p>
<p>After a <a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> has been created, a reference to it can be passed to <a class="el" href="classlibMesh_1_1MeshBase.html#ace4f8cf8f3c150cd6c5203e593fd26b3" title="Adds a functor which can specify ghosting requirements for use on distributed meshes. ">MeshBase::add_ghosting_functor</a> to expand geometric ghosting, or to <a class="el" href="classlibMesh_1_1DofMap.html#a9a0c5eeda42bc54bb3ae1c2d05ec5227" title="Adds a functor which can specify algebraic ghosting requirements for use with distributed vectors...">DofMap::add_algebraic_ghosting_functor</a> to expand both algebraic and geometric ghosting, or to <a class="el" href="classlibMesh_1_1DofMap.html#ae17b27f47b3731f6ce72312edd957bf7" title="Adds a functor which can specify coupling requirements for creation of sparse matrices. ">DofMap::add_coupling_functor</a> to expand coupling along with both types of ghosting.</p>
<p>Note that when an element is specified in algebraic ghosting or coupling queries, only degrees of freedom for the variables supported on that element are thereby ghosted and/or coupled. Any unsupported variable dofs associated with the element's nodes (e.g. subdomain-restricted variables on a neighboring subdomain) will be unaffected.</p>
<p>Typical usage of the <a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> would be to add a geometric ghosting functor before the mesh preparation is completed; progmatically, this would be before <a class="el" href="classlibMesh_1_1MeshBase.html#a777f75448e842370b11b36988a02fabe">MeshBase::prepare_for_use()</a> is called, but many different <a class="el" href="namespacelibMesh.html" title="The libMesh namespace provides an interface to certain functionality in the library. ">libMesh</a> idioms internally call this function. The algebraic and coupling ghosting functors normally are added before <a class="el" href="classlibMesh_1_1EquationSystems.html#aa79320b68e236ece82d5b358721ebd13" title="初始化所有的系统 ">EquationSystems::init()</a> is called. However, in some circumstances, solution evaluation may be needed within the <a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> in order to determine the ghosting, in which case the appropriate functor would need to be added after <a class="el" href="classlibMesh_1_1EquationSystems.html#aa79320b68e236ece82d5b358721ebd13" title="初始化所有的系统 ">EquationSystems::init()</a>. In this case, the user will need to reinitialize certain parts of the <a class="el" href="classlibMesh_1_1DofMap.html" title="This class handles the numbering of degrees of freedom on a mesh. ">DofMap</a> for algebraic and coupling functors. For algebraic ghosting functors, the user will need to call <a class="el" href="classlibMesh_1_1DofMap.html#a114f4760a9d5c427c0f7e1823ec8b883" title="Clears the _send_list vector and then rebuilds it. ">DofMap::reinit_send_list()</a> and then reinitialize any NumericVectors that are GHOSTED, e.g. the <a class="el" href="classlibMesh_1_1System.html#a2554af18e189214007827b04f17ba017" title="All the values I need to compute my contribution to the simulation at hand. ">System::current_local_solution</a>. For coupling ghosting, the user will also need to recompute the sparsity pattern via <a class="el" href="classlibMesh_1_1DofMap.html#a6481536ea3c70d31fb18fa35bfc88e33" title="Clears the sparsity pattern. ">DofMap::clear_sparsity()</a> and then <a class="el" href="classlibMesh_1_1DofMap.html#a49379ce3a542eab41a8f8e44d0f154c2" title="Computes the sparsity pattern for the matrices corresponding to proc_id and sends that data to Linear...">DofMap::compute_sparsity()</a> and then reinitialize any <a class="el" href="classlibMesh_1_1SparseMatrix.html" title="这是一个通用的稀疏矩阵类。该类包含了必须在派生类中覆盖的纯虚拟成员。 使用一个公共的基类允许从不同的求解器包中以不同的格式统一访问稀疏矩阵。 ">SparseMatrix</a> objects attached to the <a class="el" href="classlibMesh_1_1System.html" title="Manages consistently variables, degrees of freedom, and coefficient vectors. ">System</a>, e.g. the system.get_system_matrix().</p>
<dl class="section author"><dt>作者</dt><dd>Roy H. Stogner </dd></dl>
<dl class="section date"><dt>日期</dt><dd>2016 </dd></dl>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00184">184</a> 行定义.</p>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a class="anchor" id="adb5daadc989c1fe71ec8d173adf0ed1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, std::pair&lt;unsigned int, unsigned int&gt; &gt; <a class="el" href="classlibMesh_1_1ReferenceCounter.html#adb5daadc989c1fe71ec8d173adf0ed1e">libMesh::ReferenceCounter::Counts</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data structure to log the information. </p>
<p>The log is identified by the class name. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00119">119</a> 行定义.</p>

</div>
</div>
<a class="anchor" id="a676b8f239d71a5a8d035d9f460bdde4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;const <a class="el" href="classlibMesh_1_1Elem.html">Elem</a>*, const CouplingMatrix*, <a class="el" href="structlibMesh_1_1CompareDofObjectsByPIDAndThenID.html">CompareDofObjectsByPIDAndThenID</a>&gt; <a class="el" href="classlibMesh_1_1GhostingFunctor.html#a676b8f239d71a5a8d035d9f460bdde4f">libMesh::GhostingFunctor::map_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What elements do we care about and what variables do we care about on each element? </p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00241">241</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a class="anchor" id="aef0e63dd4ee5b529fd48b14e187cb5ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::GhostingFunctor::GhostingFunctor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Empty in the base class. </p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00191">191</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;: <a class="code" href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">_mesh</a>(<span class="keyword">nullptr</span>) {}</div>
<div class="ttc" id="classlibMesh_1_1GhostingFunctor_html_ad7380df13e94d2651ff2eb3941a408f0"><div class="ttname"><a href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">libMesh::GhostingFunctor::_mesh</a></div><div class="ttdeci">const MeshBase * _mesh</div><div class="ttdef"><b>Definition:</b> <a href="ghosting__functor_8h_source.html#l00291">ghosting_functor.h:291</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3f74e15c69b01d44136bf4115fa9f211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::GhostingFunctor::GhostingFunctor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using mesh. </p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00196">196</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;: <a class="code" href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">_mesh</a>(&amp;<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>) {}</div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="classlibMesh_1_1GhostingFunctor_html_ad7380df13e94d2651ff2eb3941a408f0"><div class="ttname"><a href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">libMesh::GhostingFunctor::_mesh</a></div><div class="ttdeci">const MeshBase * _mesh</div><div class="ttdef"><b>Definition:</b> <a href="ghosting__functor_8h_source.html#l00291">ghosting_functor.h:291</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4ecfc3529efaad282b001e37517ac369"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::GhostingFunctor::GhostingFunctor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1GhostingFunctor.html">GhostingFunctor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy Constructor. </p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00201">201</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                                                 :</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;   ReferenceCountedObject&lt;GhostingFunctor&gt;(other),</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;   <a class="code" href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">_mesh</a> (other._mesh)</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  {}</div>
<div class="ttc" id="classlibMesh_1_1GhostingFunctor_html_ad7380df13e94d2651ff2eb3941a408f0"><div class="ttname"><a href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">libMesh::GhostingFunctor::_mesh</a></div><div class="ttdeci">const MeshBase * _mesh</div><div class="ttdef"><b>Definition:</b> <a href="ghosting__functor_8h_source.html#l00291">ghosting_functor.h:291</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a811e8617e92cbb6ba1de6c75743fe377"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual libMesh::GhostingFunctor::~GhostingFunctor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor; this is an abstract base class. </p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a class="anchor" id="a9912966faed03725df1c4653a6dc005f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1GhostingFunctor.html">GhostingFunctor</a>&gt; libMesh::GhostingFunctor::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classlibMesh_1_1GhostingFunctor.html#a9912966faed03725df1c4653a6dc005f" title="A clone() is needed because GhostingFunctor can not be shared between different meshes. ">clone()</a> is needed because <a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> can not be shared between different meshes. </p>
<p>The operations in <a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> are mesh dependent. </p>

<p>被 <a class="el" href="classlibMesh_1_1DefaultCoupling.html#a971cc3da44c4a4f0b2d2d4087e2f05ce">libMesh::DefaultCoupling</a>, <a class="el" href="classlibMesh_1_1PointNeighborCoupling.html#a0f12360986521700d00464c15fcea9e1">libMesh::PointNeighborCoupling</a> , 以及 <a class="el" href="classlibMesh_1_1SiblingCoupling.html#a244738d30e20de96dc5077c259a8c02d">libMesh::SiblingCoupling</a> 重载.</p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00215">215</a> 行定义.</p>

<p>参考自 <a class="el" href="mesh__base_8C_source.html#l00088">libMesh::MeshBase::MeshBase()</a>.</p>
<div class="fragment"><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;  { <span class="keywordflow">return</span> <span class="keyword">nullptr</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a39eab28bbe2da68e6b8197b85ee811e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::GhostingFunctor::delete_remote_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> subclasses with relatively long-lasting caches may want to delete the no-longer-relevant parts of those caches after a redistribution is complete. </p>

<p>被 <a class="el" href="classlibMesh_1_1PointNeighborCoupling.html#aa9b7fad6a95ed50550293013fed7b066">libMesh::PointNeighborCoupling</a>, <a class="el" href="classlibMesh_1_1DefaultCoupling.html#a858d80254050062832e421cf4cffad66">libMesh::DefaultCoupling</a> , 以及 <a class="el" href="classlibMesh_1_1GhostPointNeighbors.html#aba3c0adf0036ebcd1661d8e01d0d70c8">libMesh::GhostPointNeighbors</a> 重载.</p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00291">291</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;{};</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5c0a2d3d3c531f9f069b0d623d4ace0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ReferenceCounter::disable_print_counter_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="reference__counter_8C_source.html">reference_counter.C</a> 第 <a class="el" href="reference__counter_8C_source.html#l00100">100</a> 行定义.</p>

<p>参考 <a class="el" href="reference__counter_8h_source.html#l00143">libMesh::ReferenceCounter::_enable_print_counter</a>.</p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;{</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">_enable_print_counter</a> = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a8f75e8a4a280f2c41636f2ae1307a311"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">libMesh::ReferenceCounter::_enable_print_counter</a></div><div class="ttdeci">static bool _enable_print_counter</div><div class="ttdoc">Flag to control whether reference count information is printed when print_info is called...</div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00143">reference_counter.h:143</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af9571e0c0ae41d4b133083071e7ce787"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::GhostingFunctor::dofmap_reinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For algebraic ghosting or coupling functors we also call <a class="el" href="classlibMesh_1_1GhostingFunctor.html#af9571e0c0ae41d4b133083071e7ce787" title="For algebraic ghosting or coupling functors we also call dofmap_reinit() later, after dofs have been ...">dofmap_reinit()</a> later, after dofs have been distributed on the new mesh but before the functors have been queried for send_list or sparsity pattern calculations. </p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00272">272</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;{};</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a86837c50216b2ddb800b3836d2a08c09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ReferenceCounter::enable_print_counter_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods to enable/disable the reference counter output from <a class="el" href="classlibMesh_1_1ReferenceCounter.html#a13ce734a14ffd1dbb6496dab702da8e1" title="Prints the reference information, by default to libMesh::out. ">print_info()</a> </p>

<p>在文件 <a class="el" href="reference__counter_8C_source.html">reference_counter.C</a> 第 <a class="el" href="reference__counter_8C_source.html#l00094">94</a> 行定义.</p>

<p>参考 <a class="el" href="reference__counter_8h_source.html#l00143">libMesh::ReferenceCounter::_enable_print_counter</a>.</p>
<div class="fragment"><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;{</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">_enable_print_counter</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a8f75e8a4a280f2c41636f2ae1307a311"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">libMesh::ReferenceCounter::_enable_print_counter</a></div><div class="ttdeci">static bool _enable_print_counter</div><div class="ttdoc">Flag to control whether reference count information is printed when print_info is called...</div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00143">reference_counter.h:143</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a103b37125ae9eaaadf6f7854df17faa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string libMesh::ReferenceCounter::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a string containing the reference information. </p>

<p>在文件 <a class="el" href="reference__counter_8C_source.html">reference_counter.C</a> 第 <a class="el" href="reference__counter_8C_source.html#l00047">47</a> 行定义.</p>

<p>参考 <a class="el" href="reference__counter_8h_source.html#l00124">libMesh::ReferenceCounter::_counts</a> , 以及 <a class="el" href="elem__quality_8C_source.html#l00042">libMesh::Quality::name()</a>.</p>

<p>参考自 <a class="el" href="reference__counter_8C_source.html#l00081">libMesh::ReferenceCounter::print_info()</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;{</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="preprocessor">#if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) &amp;&amp; defined(DEBUG)</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  std::ostringstream oss;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  oss &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      &lt;&lt; <span class="stringliteral">&quot; ---------------------------------------------------------------------------- \n&quot;</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;| Reference count information                                                |\n&quot;</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;      &lt;&lt; <span class="stringliteral">&quot; ---------------------------------------------------------------------------- \n&quot;</span>;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; [<a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a>, cd] : <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">_counts</a>)</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    oss &lt;&lt; <span class="stringliteral">&quot;| &quot;</span> &lt;&lt; <a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a> &lt;&lt; <span class="stringliteral">&quot; reference count information:\n&quot;</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;|  Creations:    &quot;</span> &lt;&lt; cd.first    &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;|  Destructions: &quot;</span> &lt;&lt; cd.second &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  oss &lt;&lt; <span class="stringliteral">&quot; ---------------------------------------------------------------------------- \n&quot;</span>;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  <span class="keywordflow">return</span> oss.str();</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="preprocessor"></span>}</div>
<div class="ttc" id="namespacelibMesh_1_1Quality_html_a1d3617b89c15ade245910fc9a4ddfa34"><div class="ttname"><a href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">libMesh::Quality::name</a></div><div class="ttdeci">std::string name(const ElemQuality q)</div><div class="ttdoc">This function returns a string containing some name for q. </div><div class="ttdef"><b>Definition:</b> <a href="elem__quality_8C_source.html#l00042">elem_quality.C:42</a></div></div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a7c913252d05560f8bc7c75a63547c4c3"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">libMesh::ReferenceCounter::_counts</a></div><div class="ttdeci">static Counts _counts</div><div class="ttdoc">Actually holds the data. </div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00124">reference_counter.h:124</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aba3177b115c64145747de955ab9ab90c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a>* libMesh::GhostingFunctor::get_mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the mesh associated with ghosting functor. </p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00235">235</a> 行定义.</p>

<p>参考 <a class="el" href="ghosting__functor_8h_source.html#l00291">_mesh</a> , 以及 <a class="el" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert()</a>.</p>
<div class="fragment"><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;{ <a class="code" href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libmesh_assert</a>(<a class="code" href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">_mesh</a>); <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">_mesh</a>; }</div>
<div class="ttc" id="namespacelibMesh_html_a4f791f2cb1525c37e7916d564c3b3b78"><div class="ttname"><a href="namespacelibMesh.html#a4f791f2cb1525c37e7916d564c3b3b78">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(ctx)</div></div>
<div class="ttc" id="classlibMesh_1_1GhostingFunctor_html_ad7380df13e94d2651ff2eb3941a408f0"><div class="ttname"><a href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">libMesh::GhostingFunctor::_mesh</a></div><div class="ttdeci">const MeshBase * _mesh</div><div class="ttdef"><b>Definition:</b> <a href="ghosting__functor_8h_source.html#l00291">ghosting_functor.h:291</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af0cd2f1fbd46c66dade1e750436ee7ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ReferenceCounter::increment_constructor_count </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the construction counter. </p>
<p>Should be called in the constructor of any derived class that will be reference counted. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00183">183</a> 行定义.</p>

<p>参考 <a class="el" href="libmesh__common_8h_source.html#l00101">libMesh::err</a>, <a class="el" href="ostream__proxy_8h_source.html#l00217">libMesh::BasicOStreamProxy&lt; charT, traits &gt;::get()</a>, <a class="el" href="elem__quality_8C_source.html#l00042">libMesh::Quality::name()</a> , 以及 <a class="el" href="threads_8C_source.html#l00030">libMesh::Threads::spin_mtx</a>.</p>

<p>参考自 <a class="el" href="reference__counted__object_8h_source.html#l00074">libMesh::ReferenceCountedObject&lt; RBParametrized &gt;::ReferenceCountedObject()</a>.</p>
<div class="fragment"><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;{</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  libmesh_try</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  {</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    Threads::spin_mutex::scoped_lock lock(<a class="code" href="namespacelibMesh_1_1Threads.html#a29932e1987dacf7e89b1b27bb49bf0c9">Threads::spin_mtx</a>);</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    std::pair&lt;unsigned int, unsigned int&gt; &amp; p = <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">_counts</a>[<a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a>];</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    p.first++;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  }</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  libmesh_catch (...)</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <span class="keyword">auto</span> stream = <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a>.<a class="code" href="classlibMesh_1_1BasicOStreamProxy.html#ae2d18b50fc63d23e47d46fcee630b4f5">get</a>();</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    stream-&gt;exceptions(stream-&gt;goodbit); <span class="comment">// stream must not throw</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt; <span class="stringliteral">&quot;Encountered unrecoverable error while calling &quot;</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot;ReferenceCounter::increment_constructor_count() &quot;</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot;for a(n) &quot;</span> &lt;&lt; <a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a> &lt;&lt; <span class="stringliteral">&quot; object.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    std::terminate();</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  }</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_1_1Quality_html_a1d3617b89c15ade245910fc9a4ddfa34"><div class="ttname"><a href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">libMesh::Quality::name</a></div><div class="ttdeci">std::string name(const ElemQuality q)</div><div class="ttdoc">This function returns a string containing some name for q. </div><div class="ttdef"><b>Definition:</b> <a href="elem__quality_8C_source.html#l00042">elem_quality.C:42</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a74e5bc8a72d210b3d87b0221b1f69db1"><div class="ttname"><a href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a></div><div class="ttdeci">OStreamProxy err(std::cerr)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00101">libmesh_common.h:101</a></div></div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a7c913252d05560f8bc7c75a63547c4c3"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">libMesh::ReferenceCounter::_counts</a></div><div class="ttdeci">static Counts _counts</div><div class="ttdoc">Actually holds the data. </div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00124">reference_counter.h:124</a></div></div>
<div class="ttc" id="classlibMesh_1_1BasicOStreamProxy_html_ae2d18b50fc63d23e47d46fcee630b4f5"><div class="ttname"><a href="classlibMesh_1_1BasicOStreamProxy.html#ae2d18b50fc63d23e47d46fcee630b4f5">libMesh::BasicOStreamProxy::get</a></div><div class="ttdeci">streamT * get()</div><div class="ttdoc">Rather than implement every ostream/ios/ios_base function, we&amp;#39;ll be lazy and make esoteric uses go th...</div><div class="ttdef"><b>Definition:</b> <a href="ostream__proxy_8h_source.html#l00217">ostream_proxy.h:217</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Threads_html_a29932e1987dacf7e89b1b27bb49bf0c9"><div class="ttname"><a href="namespacelibMesh_1_1Threads.html#a29932e1987dacf7e89b1b27bb49bf0c9">libMesh::Threads::spin_mtx</a></div><div class="ttdeci">spin_mutex spin_mtx</div><div class="ttdoc">A convenient spin mutex object which can be used for obtaining locks. </div><div class="ttdef"><b>Definition:</b> <a href="threads_8C_source.html#l00030">threads.C:30</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a769ddb2e2299db1aafcdfb33dfb830d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ReferenceCounter::increment_destructor_count </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the destruction counter. </p>
<p>Should be called in the destructor of any derived class that will be reference counted. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00207">207</a> 行定义.</p>

<p>参考 <a class="el" href="libmesh__common_8h_source.html#l00101">libMesh::err</a>, <a class="el" href="ostream__proxy_8h_source.html#l00217">libMesh::BasicOStreamProxy&lt; charT, traits &gt;::get()</a>, <a class="el" href="elem__quality_8C_source.html#l00042">libMesh::Quality::name()</a> , 以及 <a class="el" href="threads_8C_source.html#l00030">libMesh::Threads::spin_mtx</a>.</p>

<p>参考自 <a class="el" href="reference__counted__object_8h_source.html#l00127">libMesh::ReferenceCountedObject&lt; RBParametrized &gt;::~ReferenceCountedObject()</a>.</p>
<div class="fragment"><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;{</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;  libmesh_try</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;  {</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    Threads::spin_mutex::scoped_lock lock(<a class="code" href="namespacelibMesh_1_1Threads.html#a29932e1987dacf7e89b1b27bb49bf0c9">Threads::spin_mtx</a>);</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    std::pair&lt;unsigned int, unsigned int&gt; &amp; p = <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">_counts</a>[<a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a>];</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    p.second++;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  }</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  libmesh_catch (...)</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  {</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="keyword">auto</span> stream = <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a>.<a class="code" href="classlibMesh_1_1BasicOStreamProxy.html#ae2d18b50fc63d23e47d46fcee630b4f5">get</a>();</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    stream-&gt;exceptions(stream-&gt;goodbit); <span class="comment">// stream must not throw</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt; <span class="stringliteral">&quot;Encountered unrecoverable error while calling &quot;</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot;ReferenceCounter::increment_destructor_count() &quot;</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot;for a(n) &quot;</span> &lt;&lt; <a class="code" href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">name</a> &lt;&lt; <span class="stringliteral">&quot; object.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    std::terminate();</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  }</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_1_1Quality_html_a1d3617b89c15ade245910fc9a4ddfa34"><div class="ttname"><a href="namespacelibMesh_1_1Quality.html#a1d3617b89c15ade245910fc9a4ddfa34">libMesh::Quality::name</a></div><div class="ttdeci">std::string name(const ElemQuality q)</div><div class="ttdoc">This function returns a string containing some name for q. </div><div class="ttdef"><b>Definition:</b> <a href="elem__quality_8C_source.html#l00042">elem_quality.C:42</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a74e5bc8a72d210b3d87b0221b1f69db1"><div class="ttname"><a href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a></div><div class="ttdeci">OStreamProxy err(std::cerr)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00101">libmesh_common.h:101</a></div></div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a7c913252d05560f8bc7c75a63547c4c3"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a7c913252d05560f8bc7c75a63547c4c3">libMesh::ReferenceCounter::_counts</a></div><div class="ttdeci">static Counts _counts</div><div class="ttdoc">Actually holds the data. </div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00124">reference_counter.h:124</a></div></div>
<div class="ttc" id="classlibMesh_1_1BasicOStreamProxy_html_ae2d18b50fc63d23e47d46fcee630b4f5"><div class="ttname"><a href="classlibMesh_1_1BasicOStreamProxy.html#ae2d18b50fc63d23e47d46fcee630b4f5">libMesh::BasicOStreamProxy::get</a></div><div class="ttdeci">streamT * get()</div><div class="ttdoc">Rather than implement every ostream/ios/ios_base function, we&amp;#39;ll be lazy and make esoteric uses go th...</div><div class="ttdef"><b>Definition:</b> <a href="ostream__proxy_8h_source.html#l00217">ostream_proxy.h:217</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Threads_html_a29932e1987dacf7e89b1b27bb49bf0c9"><div class="ttname"><a href="namespacelibMesh_1_1Threads.html#a29932e1987dacf7e89b1b27bb49bf0c9">libMesh::Threads::spin_mtx</a></div><div class="ttdeci">spin_mutex spin_mtx</div><div class="ttdoc">A convenient spin mutex object which can be used for obtaining locks. </div><div class="ttdef"><b>Definition:</b> <a href="threads_8C_source.html#l00030">threads.C:30</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acbc49f77df76394153ae617a000bf128"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::GhostingFunctor::mesh_reinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> subclasses which cache data will need to initialize that cache. </p>
<p>We call <a class="el" href="classlibMesh_1_1GhostingFunctor.html#acbc49f77df76394153ae617a000bf128" title="GhostingFunctor subclasses which cache data will need to initialize that cache. ">mesh_reinit()</a> whenever the relevant <a class="el" href="classlibMesh_1_1Mesh.html" title="The Mesh class is a thin wrapper, around the ReplicatedMesh class by default. ">Mesh</a> has changed, but before remote elements on a distributed mesh are deleted. </p>

<p>被 <a class="el" href="classlibMesh_1_1PointNeighborCoupling.html#a77e15d09362f560fb668a24042e82513">libMesh::PointNeighborCoupling</a>, <a class="el" href="classlibMesh_1_1DefaultCoupling.html#a90c0c8bceb7e4b92532f87061b9c8ead">libMesh::DefaultCoupling</a> , 以及 <a class="el" href="classlibMesh_1_1GhostPointNeighbors.html#a5a9e2eb845eb30dc7c63265a85368fe2">libMesh::GhostPointNeighbors</a> 重载.</p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00264">264</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;{};</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a50e74641afc6e2870c9e1ce412f8c44f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int libMesh::ReferenceCounter::n_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the number of outstanding (created, but not yet destroyed) objects. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00085">85</a> 行定义.</p>

<p>参考 <a class="el" href="reference__counter_8h_source.html#l00132">libMesh::ReferenceCounter::_n_objects</a>.</p>

<p>参考自 <a class="el" href="libmesh_8C_source.html#l00668">libMesh::LibMeshInit::~LibMeshInit()</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  { <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1ReferenceCounter.html#ad2c30f0f71dcd00f00faa8e46aa3e043">_n_objects</a>; }</div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_ad2c30f0f71dcd00f00faa8e46aa3e043"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#ad2c30f0f71dcd00f00faa8e46aa3e043">libMesh::ReferenceCounter::_n_objects</a></div><div class="ttdeci">static Threads::atomic&lt; unsigned int &gt; _n_objects</div><div class="ttdoc">The number of objects. </div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00132">reference_counter.h:132</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a39911ad4559e25383fd094be15cdfc1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::GhostingFunctor::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibMesh.html#af18245d4f872c36a41fc74086bda3e80">processor_id_type</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1GhostingFunctor.html#a676b8f239d71a5a8d035d9f460bdde4f">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>coupled_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the specified range of active elements, what other elements currently living (whether local or ghosted) on this processor need to be coupled/ghosted to accommodate them? Don't bother to return any results which already have processor_id p. </p>
<p>This API is new, and we should replace "ignoring those on
processor p" with "ignoring those which match a predicate
functor" eventually. </p>

<p>在 <a class="el" href="classlibMesh_1_1DefaultCoupling.html#a7e113b5c48963a9899d557c6c5d8a486">libMesh::DefaultCoupling</a>, <a class="el" href="classlibMesh_1_1PointNeighborCoupling.html#accfa6d2aafbd8816819e102649ad9b33">libMesh::PointNeighborCoupling</a>, <a class="el" href="classlibMesh_1_1GhostPointNeighbors.html#a57d83ee50f3ac97ca2dfc373e513b75e">libMesh::GhostPointNeighbors</a> , 以及 <a class="el" href="classlibMesh_1_1SiblingCoupling.html#abc8d3ddbb25b9e102a9d5f520477d725">libMesh::SiblingCoupling</a> 内被实现.</p>

</div>
</div>
<a class="anchor" id="a13ce734a14ffd1dbb6496dab702da8e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ReferenceCounter::print_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em> = <code><a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the reference information, by default to <code><a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></code>. </p>

<p>在文件 <a class="el" href="reference__counter_8C_source.html">reference_counter.C</a> 第 <a class="el" href="reference__counter_8C_source.html#l00081">81</a> 行定义.</p>

<p>参考 <a class="el" href="reference__counter_8h_source.html#l00143">libMesh::ReferenceCounter::_enable_print_counter</a> , 以及 <a class="el" href="reference__counter_8C_source.html#l00047">libMesh::ReferenceCounter::get_info()</a>.</p>

<p>参考自 <a class="el" href="libmesh_8C_source.html#l00668">libMesh::LibMeshInit::~LibMeshInit()</a>.</p>
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;{</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">_enable_print_counter</a>)</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    out_stream &lt;&lt; <a class="code" href="classlibMesh_1_1ReferenceCounter.html#a103b37125ae9eaaadf6f7854df17faa2">ReferenceCounter::get_info</a>();</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a103b37125ae9eaaadf6f7854df17faa2"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a103b37125ae9eaaadf6f7854df17faa2">libMesh::ReferenceCounter::get_info</a></div><div class="ttdeci">static std::string get_info()</div><div class="ttdoc">Gets a string containing the reference information. </div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8C_source.html#l00047">reference_counter.C:47</a></div></div>
<div class="ttc" id="classlibMesh_1_1ReferenceCounter_html_a8f75e8a4a280f2c41636f2ae1307a311"><div class="ttname"><a href="classlibMesh_1_1ReferenceCounter.html#a8f75e8a4a280f2c41636f2ae1307a311">libMesh::ReferenceCounter::_enable_print_counter</a></div><div class="ttdeci">static bool _enable_print_counter</div><div class="ttdoc">Flag to control whether reference count information is printed when print_info is called...</div><div class="ttdef"><b>Definition:</b> <a href="reference__counter_8h_source.html#l00143">reference_counter.h:143</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2f4502085eaa26f29a36cc008d4c5015"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::GhostingFunctor::redistribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classlibMesh_1_1GhostingFunctor.html" title="This abstract base class defines the interface by which library code and user code can report associa...">GhostingFunctor</a> subclasses with relatively long-lasting caches may want to redistribute those caches whenever the relevant <a class="el" href="classlibMesh_1_1Mesh.html" title="The Mesh class is a thin wrapper, around the ReplicatedMesh class by default. ">Mesh</a> is redistributed; we will give them an opportunity when that happens. </p>
<p>At the point in the code where this is called, element processor ids have been set to their new destinations, and those elements have been copied to their new destinations, but the elements have not yet been deleted by the processors which previously held them.. </p>

<p>被 <a class="el" href="classlibMesh_1_1PointNeighborCoupling.html#abc009f992a5bbd773619cce7ba94ed91">libMesh::PointNeighborCoupling</a>, <a class="el" href="classlibMesh_1_1DefaultCoupling.html#ac0871bfbad0f61233e052c64d52af33b">libMesh::DefaultCoupling</a> , 以及 <a class="el" href="classlibMesh_1_1GhostPointNeighbors.html#aa5b2bb0a8ade62879084a4cceab6e6e1">libMesh::GhostPointNeighbors</a> 重载.</p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00284">284</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;{};</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1d688b123d7c565e1a5ae136fb6a8300"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::GhostingFunctor::set_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> *&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It should be called after cloning a ghosting functor. </p>
<p>Ghosting functor is mesh dependent </p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00225">225</a> 行定义.</p>

<p>参考 <a class="el" href="ghosting__functor_8h_source.html#l00291">_mesh</a> , 以及 <a class="el" href="mesh__communication_8C_source.html#l01308">mesh</a>.</p>

<p>参考自 <a class="el" href="dof__map_8C_source.html#l01886">libMesh::DofMap::add_algebraic_ghosting_functor()</a> , 以及 <a class="el" href="dof__map_8C_source.html#l01861">libMesh::DofMap::add_coupling_functor()</a>.</p>
<div class="fragment"><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;{ <a class="code" href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">_mesh</a> = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>; }</div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01308">mesh_communication.C:1308</a></div></div>
<div class="ttc" id="classlibMesh_1_1GhostingFunctor_html_ad7380df13e94d2651ff2eb3941a408f0"><div class="ttname"><a href="classlibMesh_1_1GhostingFunctor.html#ad7380df13e94d2651ff2eb3941a408f0">libMesh::GhostingFunctor::_mesh</a></div><div class="ttdeci">const MeshBase * _mesh</div><div class="ttdef"><b>Definition:</b> <a href="ghosting__functor_8h_source.html#l00291">ghosting_functor.h:291</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abdadb619386f44eff9fd190fc491c5d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libMesh::GhostingFunctor::set_periodic_boundaries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1PeriodicBoundaries.html">PeriodicBoundaries</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>被 <a class="el" href="classlibMesh_1_1PointNeighborCoupling.html#a143a9b689037579d83277f9d5eca8e9a">libMesh::PointNeighborCoupling</a> , 以及 <a class="el" href="classlibMesh_1_1DefaultCoupling.html#a6a24bd845a9a9f854914c9fcdc88e67d">libMesh::DefaultCoupling</a> 重载.</p>

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00229">229</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;{}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a class="anchor" id="a7c913252d05560f8bc7c75a63547c4c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1ReferenceCounter.html#adb5daadc989c1fe71ec8d173adf0ed1e">ReferenceCounter::Counts</a> libMesh::ReferenceCounter::_counts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actually holds the data. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00124">124</a> 行定义.</p>

<p>参考自 <a class="el" href="reference__counter_8C_source.html#l00047">libMesh::ReferenceCounter::get_info()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f75e8a4a280f2c41636f2ae1307a311"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::ReferenceCounter::_enable_print_counter = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag to control whether reference count information is printed when print_info is called. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00143">143</a> 行定义.</p>

<p>参考自 <a class="el" href="reference__counter_8C_source.html#l00100">libMesh::ReferenceCounter::disable_print_counter_info()</a>, <a class="el" href="reference__counter_8C_source.html#l00094">libMesh::ReferenceCounter::enable_print_counter_info()</a> , 以及 <a class="el" href="reference__counter_8C_source.html#l00081">libMesh::ReferenceCounter::print_info()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7380df13e94d2651ff2eb3941a408f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a>* libMesh::GhostingFunctor::_mesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在文件 <a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a> 第 <a class="el" href="ghosting__functor_8h_source.html#l00291">291</a> 行定义.</p>

<p>参考自 <a class="el" href="ghosting__functor_8h_source.html#l00235">get_mesh()</a> , 以及 <a class="el" href="ghosting__functor_8h_source.html#l00225">set_mesh()</a>.</p>

</div>
</div>
<a class="anchor" id="abedbd3a4ce19686187449a8a0557b74b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1Threads_1_1spin__mutex.html">Threads::spin_mutex</a> libMesh::ReferenceCounter::_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutual exclusion object to enable thread-safe reference counting. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00137">137</a> 行定义.</p>

</div>
</div>
<a class="anchor" id="ad2c30f0f71dcd00f00faa8e46aa3e043"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1Threads_1_1atomic.html">Threads::atomic</a>&lt; unsigned int &gt; libMesh::ReferenceCounter::_n_objects</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of objects. </p>
<p>Print the reference count information when the number returns to 0. </p>

<p>在文件 <a class="el" href="reference__counter_8h_source.html">reference_counter.h</a> 第 <a class="el" href="reference__counter_8h_source.html#l00132">132</a> 行定义.</p>

<p>参考自 <a class="el" href="reference__counter_8h_source.html#l00085">libMesh::ReferenceCounter::n_objects()</a>, <a class="el" href="reference__counter_8h_source.html#l00150">libMesh::ReferenceCounter::ReferenceCounter()</a> , 以及 <a class="el" href="reference__counter_8h_source.html#l00171">libMesh::ReferenceCounter::~ReferenceCounter()</a>.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>/home/lwz/libmesh/include/ghosting/<a class="el" href="ghosting__functor_8h_source.html">ghosting_functor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2023年 十二月 20日 星期三 12:09:32 , 为 libmesh解析使用  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
